<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bing WebMaster -->
  <meta name="msvalidate.01" content="AB2FFF876C37F59D9121882CC8395DE5" />

  <title>Object-oriented Programming in Go Language</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://blog.codefarm.me/2017/05/21/object-oriented-programming-in-go-language/">
  <link rel="alternate" type="application/rss+xml" title="CODE FARM" href="https://blog.codefarm.me/feed.xml">

  <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->
<script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>

  
<!-- Google Analytics Website tracking -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-83971182-1', 'auto');
  ga('send', 'pageview');

</script>


  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SN88FJ18E5');
</script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">
    <h2 class="site-title">
      <a class="site-title" href="/">CODE FARM</a>
    </h2>

     <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
        <div class="trigger">
            <ul>
                <li><a href="/">home</a>
                <li><a href="/category">category</a>
                <li><a href="/tag">tag</a>
                <li><a href="/archive">archive</a>
                <li><a href="/about">about</a>
                <li><a href="https://resume.github.io/?qqbuby" target="_blank">R&eacute;sum&eacute;</a>
            </ul>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Object-oriented Programming in Go Language</h1>
    
    
    <p class="post-meta"><time datetime="2017-05-21T17:27:56+08:00" itemprop="datePublished">May 21, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <ul id="markdown-toc">
  <li><a href="#methods" id="markdown-toc-methods">Methods</a>    <ul>
      <li><a href="#method-declarations" id="markdown-toc-method-declarations">Method Declarations</a></li>
      <li><a href="#methods-with-a-pointer-receiver" id="markdown-toc-methods-with-a-pointer-receiver">Methods with a Pointer Receiver</a>        <ul>
          <li><a href="#nil-is-a-valid-receiver-value" id="markdown-toc-nil-is-a-valid-receiver-value">Nil Is a Valid Receiver Value</a></li>
        </ul>
      </li>
      <li><a href="#composing-types-by-struct-embedding" id="markdown-toc-composing-types-by-struct-embedding">Composing Types by Struct Embedding</a></li>
      <li><a href="#method-values-and-expressions" id="markdown-toc-method-values-and-expressions">Method Values and Expressions</a></li>
      <li><a href="#encapsulation" id="markdown-toc-encapsulation">Encapsulation</a></li>
    </ul>
  </li>
  <li><a href="#interfaces" id="markdown-toc-interfaces">Interfaces</a>    <ul>
      <li><a href="#interface-as-contracts" id="markdown-toc-interface-as-contracts">Interface as Contracts</a></li>
      <li><a href="#interface-types" id="markdown-toc-interface-types">Interface Types</a></li>
      <li><a href="#interface-satisfaction" id="markdown-toc-interface-satisfaction">Interface Satisfaction</a></li>
      <li><a href="#interface-values" id="markdown-toc-interface-values">Interface Values</a>        <ul>
          <li><a href="#caveat-an-interface-containing-a-nil-pointer-is-non-nil" id="markdown-toc-caveat-an-interface-containing-a-nil-pointer-is-non-nil">Caveat: An Interface Containing a Nil Pointer Is Non-Nil</a></li>
        </ul>
      </li>
      <li><a href="#type-assertions" id="markdown-toc-type-assertions">Type Assertions</a></li>
      <li><a href="#type-switches" id="markdown-toc-type-switches">Type Switches</a></li>
      <li><a href="#references" id="markdown-toc-references">References</a></li>
    </ul>
  </li>
</ul>

<hr />

<p>Since the early 1990s, object-oriented programming (OOP) has been the dominant programming paradigm in industry and education, and nearly all widely used languages developed since then have inlcuded support for it. Go is no exception.</p>

<h2 id="methods">Methods</h2>

<p>Although there is no universally accepted definition of object-oriented programming, for our purposes, an <strong><em>object</em></strong> is simply a value or variables that has methods, and a <strong><em>method</em></strong> is a function associated with a particular type. An object-oriented program is one that uses methods to express the properties and operations of each data structure so that clients need not access the object’s representation directly.</p>

<h3 id="method-declarations">Method Declarations</h3>

<p>A method is declared with variant of the ordinary function declaration in which an extra parameter appears before the function name. The parameter attachs the function to the type of that parameter.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">geometry</span>

<span class="k">import</span> <span class="s">"path"</span>

<span class="k">type</span> <span class="n">Point</span> <span class="k">struct</span><span class="p">{</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="c">// traditional funcitoni</span>
<span class="k">func</span> <span class="n">Distance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="n">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">maht</span><span class="o">.</span><span class="n">Hypot</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">X</span><span class="o">-</span><span class="n">q</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">Y</span><span class="o">-</span><span class="n">q</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// same thing, but as a method of the Point type</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">Point</span><span class="p">)</span> <span class="n">Distance</span><span class="p">(</span><span class="n">q</span> <span class="n">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">maht</span><span class="o">.</span><span class="n">Hypot</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">X</span><span class="o">-</span><span class="n">q</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">Y</span><span class="o">-</span><span class="n">q</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The extra parameter <code class="language-plaintext highlighter-rouge">p</code> is called the method’s <strong><em>receiver</em></strong>, a legacy from early object-oriented languages that described calling a method as “sending a message to an object”.</p>

<p>In Go, we don’t use a special name like <strong>this</strong> or <strong>self</strong> for the receiver; we choose receiver names just as we would for any other parameter. <strong>Since the receiver name will be frequently used, it’s a good idea to choose something short and to be consistent across methods. A common choice is the first letter of the type name, like <code class="language-plaintext highlighter-rouge">p</code> for <code class="language-plaintext highlighter-rouge">Point</code>.</strong></p>

<p>In a method call, the receiver argument appears before the method name. This parallels the declaration, in which the receiver parameter appears before the method name.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">:=</span> <span class="n">Point</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span>
<span class="n">q</span> <span class="o">:=</span> <span class="n">Point</span><span class="p">{</span><span class="m">4</span><span class="p">,</span> <span class="m">6</span><span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">Distance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span> <span class="c">// "5", function call</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>  <span class="c">// "5", method call</span>
</code></pre></div></div>

<p>There’s no conflict between the two declarations of functions called <code class="language-plaintext highlighter-rouge">Distance</code> above. The first declares a package-level function called <code class="language-plaintext highlighter-rouge">geometry.Distance</code>. The second declares a method of the type <code class="language-plaintext highlighter-rouge">Point</code>, so its name is <code class="language-plaintext highlighter-rouge">Point.Distance</code>.</p>

<p>The expression <code class="language-plaintext highlighter-rouge">p.Distance</code> is called a <strong><em>selector</em></strong>, because it select the appropriate <code class="language-plaintext highlighter-rouge">Distance</code> method for the receiver <code class="language-plaintext highlighter-rouge">p</code> of type <code class="language-plaintext highlighter-rouge">Point</code>. Selectors are also used to select fields of struct types, as in <code class="language-plaintext highlighter-rouge">p.X</code>. <strong>Since methods and fields inhabit the same name space, declaring a method <code class="language-plaintext highlighter-rouge">X</code> on the struct <code class="language-plaintext highlighter-rouge">Point</code> would be ambiguous and the compiler will reject it.</strong></p>

<h3 id="methods-with-a-pointer-receiver">Methods with a Pointer Receiver</h3>

<p>Because calling a function makes a copy of each argument value, if a function needs to update a variable, of if an argument is so large that we wish to avoid copying it, we must pass the address of the variable using a pointer. The same goes for methods that need to update receiver variable: we attach them to the pointer type, such as <code class="language-plaintext highlighter-rouge">*Point</code>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Point</span><span class="p">)</span> <span class="n">ScaleBy</span><span class="p">(</span><span class="n">factor</span> <span class="n">flaot64</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">p</span><span class="o">.</span><span class="n">X</span> <span class="o">*=</span> <span class="n">factor</span>
	<span class="n">p</span><span class="o">.</span><span class="n">Y</span> <span class="o">*=</span> <span class="n">factor</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The name of this method is <code class="language-plaintext highlighter-rouge">(*Point).ScaleBy</code>. The parentheses are neccessary; without them, the expression would be parsed as <code class="language-plaintext highlighter-rouge">*(Point.ScaleBy)</code>.</p>

<p><strong>In a realistic program, convention dictates that if any method of <code class="language-plaintext highlighter-rouge">Point</code> has a pointer receiver, the <em>all</em> methods of <code class="language-plaintext highlighter-rouge">Point</code> should have a pointer receiver, even ones that don’t strictly need it.</strong></p>

<p>Named types (<code class="language-plaintext highlighter-rouge">Point</code>) and pointers to them (<code class="language-plaintext highlighter-rouge">*Point</code>) are the only types that may appear in a receiver declaration. Furthermore, to avoid ambiguities, method declarations are not permitted on named types that are themselves pointer types:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">P</span> <span class="o">*</span><span class="kt">int</span>
<span class="k">func</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span> <span class="c">// compile error: invalid receiver type</span>
</code></pre></div></div>

<p>If the receiver <code class="language-plaintext highlighter-rouge">p</code> is a <em>variable</em> of type <code class="language-plaintext highlighter-rouge">Point</code> but the method requires a <code class="language-plaintext highlighter-rouge">*Point</code> receiver, we can use this shorthand:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="o">.</span><span class="n">ScaleBy</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
</code></pre></div></div>

<p>and the compiler will perform an implicity <code class="language-plaintext highlighter-rouge">&amp;p</code> on the variable. This works only for variables, including struct field like <code class="language-plaintext highlighter-rouge">p.X</code> and array or slice elements like <code class="language-plaintext highlighter-rouge">perim[0]</code>. We cannot call a <code class="language-plaintext highlighter-rouge">*Point</code> method on a non-addressable <code class="language-plaintext highlighter-rouge">Point</code> receiver, because there’s no way to obtain the address of a temporary value.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// compile error: cannot call pointer method on Point literal</span>
<span class="c">// compile error: cannot take the address of Point literal</span>
<span class="n">Point</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span><span class="o">.</span><span class="n">ScaleBy</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
</code></pre></div></div>

<p>But we <strong><em>can</em></strong> call a <code class="language-plaintext highlighter-rouge">Point</code> method like <code class="language-plaintext highlighter-rouge">Point.Distance</code> with a <code class="language-plaintext highlighter-rouge">*Point</code> reciver, because there is a way to obtain the value from the address: just load the value pointed to by the receiver. The compiler inserts an implicit <code class="language-plaintext highlighter-rouge">*</code> operation for us. The two function call are equivalent:</p>

<p>Either the receiver argument has the same type as the receiver parameter, for example both have type <code class="language-plaintext highlighter-rouge">T</code> or both have type <code class="language-plaintext highlighter-rouge">*T</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">Point</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c">// Point</span>
	<span class="n">pptr</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>        <span class="c">// Point</span>
</code></pre></div></div>

<p>If all the methods of a named type <code class="language-plaintext highlighter-rouge">T</code> have a receiver type of <code class="language-plaintext highlighter-rouge">T</code> itself (not <code class="language-plaintext highlighter-rouge">*T</code>), it is safe to copy instances of that type; calling any of its methods necessarily makes a copy. But if any method has a pointer receiver, you should avoid copying instances of <code class="language-plaintext highlighter-rouge">T</code> because doing so may violate internal invariants.</p>

<h4 id="nil-is-a-valid-receiver-value">Nil Is a Valid Receiver Value</h4>

<p>Just as some functions allow nil pointers as arguments, so do some methods for their receiver, especially if <strong>nil</strong> is a meaningful zero value of the type, as with maps and slices.</p>

<p>When you define a type whose methods allow <strong>nil</strong> as a receiver value, it’s worth pointing this out explicitly in its documentation comment.</p>

<h3 id="composing-types-by-struct-embedding">Composing Types by Struct Embedding</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"image/color"</span>

<span class="k">type</span> <span class="n">Point</span> <span class="k">struct</span><span class="p">{</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="k">type</span> <span class="n">ColoredPoint</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Point</span>
	<span class="n">Color</span> <span class="n">clor</span><span class="o">.</span><span class="n">RGBA</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We could have defined <code class="language-plaintext highlighter-rouge">ColoredPoint</code> as a struct of three fields, but instead we <strong><em>embedded</em></strong> a <code class="language-plaintext highlighter-rouge">Point</code> to provide the <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">Y</code> fields. A similar mechanism applies to the <em>methods</em> of <code class="language-plaintext highlighter-rouge">Point</code>. We can call methods of the embedded <code class="language-plaintext highlighter-rouge">Point</code> field using a receiver of type <code class="language-plaintext highlighter-rouge">ColoredPoint</code>, even though <code class="language-plaintext highlighter-rouge">ColoredPoint</code> has no declared methods:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">red</span> <span class="o">:=</span> <span class="n">color</span><span class="o">.</span><span class="n">RGBA</span><span class="p">{</span><span class="m">255</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">255</span><span class="p">}</span>
	<span class="n">blue</span> <span class="o">:=</span> <span class="n">color</span><span class="o">.</span><span class="n">RGBA</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">255</span><span class="p">,</span> <span class="m">255</span><span class="p">}</span>
	<span class="k">var</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ColoredPoint</span><span class="p">{</span><span class="n">Point</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">},</span> <span class="n">red</span><span class="p">}</span>
	<span class="k">var</span> <span class="n">q</span> <span class="o">=</span> <span class="n">ColoredPoint</span><span class="p">{</span><span class="n">Point</span><span class="p">{</span><span class="m">5</span><span class="p">,</span> <span class="m">4</span><span class="p">},</span> <span class="n">blue</span><span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">Point</span><span class="p">))</span> <span class="c">// "5"</span>
	<span class="n">p</span><span class="o">.</span><span class="n">ScaleBy</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
	<span class="n">q</span><span class="o">.</span><span class="n">ScaleBy</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">Point</span><span class="p">))</span> <span class="c">// "10"</span>
</code></pre></div></div>

<p>The methods of <code class="language-plaintext highlighter-rouge">Point</code> have been <strong><em>prometed</em></strong> to <code class="language-plaintext highlighter-rouge">ColoredPoint</code>.</p>

<p>Notice the calls to <code class="language-plaintext highlighter-rouge">Distance</code> above. <code class="language-plaintext highlighter-rouge">Distance</code> has a parameter of type <code class="language-plaintext highlighter-rouge">Point</code>, and <code class="language-plaintext highlighter-rouge">q</code> is not a <code class="language-plaintext highlighter-rouge">Point</code>, so although <code class="language-plaintext highlighter-rouge">q</code> does have an embedded field of that type, we must explicitly select it. Attempting to pass <code class="language-plaintext highlighter-rouge">q</code> would be an error:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c">// compile error: cannot use q (type ColoredPoint) as type Point in argument to p.Point.Distance</span>
</code></pre></div></div>

<p>A <code class="language-plaintext highlighter-rouge">ColoredPoint</code> is not a <code class="language-plaintext highlighter-rouge">Point</code>, but it “has a” <code class="language-plaintext highlighter-rouge">Point</code>, and it has two additional methods <code class="language-plaintext highlighter-rouge">Distance</code> and <code class="language-plaintext highlighter-rouge">ScaleBy</code> promoted from <code class="language-plaintext highlighter-rouge">Point</code>. If you prefer to think in terms of implementation, the embedded field instructs the compiler to generate additional wrapper that delegate to the declared method, equivalent to these:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">ColoredPoint</span><span class="p">)</span> <span class="n">Distance</span><span class="p">(</span><span class="n">q</span> <span class="n">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">Point</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">ColoredPont</span><span class="p">)</span> <span class="n">ScaleBy</span><span class="p">(</span><span class="n">factor</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">Point</span><span class="o">.</span><span class="n">ScaleBy</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When <code class="language-plaintext highlighter-rouge">Point.Distance</code> is called by the first of these wrapper methods, its receiver value is <code class="language-plaintext highlighter-rouge">p.Point</code>, not <code class="language-plaintext highlighter-rouge">p</code>, and there is no way for the method to access the <code class="language-plaintext highlighter-rouge">ColoredPoint</code> in which the <code class="language-plaintext highlighter-rouge">Point</code> is embedded.</p>

<p>A struct type may have more than one anonymous field. <strong>When the compiler resolves a selector such as <code class="language-plaintext highlighter-rouge">p.ScaleBy</code> to a method, it first looks for directly method named <code class="language-plaintext highlighter-rouge">ScaleBy</code>, then for methods promoted once from <code class="language-plaintext highlighter-rouge">ColoredPoint</code>’s embedded fields, then for methods promoted twich from embedded fileds within <code class="language-plaintext highlighter-rouge">Point</code> and <code class="language-plaintext highlighter-rouge">RGBA</code>, and so on.</strong> <strong>The compiler reports an error if the selector was ambiguous because two methods were promoted from the same rank.</strong></p>

<p>With embedding, it’s possible and sometimes useful for <strong><em>unmamed</em></strong> struct types to have methods too. The following example shows part of a simple cache implemented using two package-level variable, a mutex and the map that it guards:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="p">(</span>
	<span class="n">mu</span>      <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span> <span class="c">// guards mapping</span>
	<span class="n">mapping</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">Lookup</span><span class="p">(</span><span class="n">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The version below is funcitonally equivalent but groups together the two related variables in a single package-level variable, <code class="language-plaintext highlighter-rouge">cache</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
	<span class="n">mapping</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}{</span>
	<span class="n">mapping</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Lookup</span><span class="p">(</span><span class="n">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="n">cache</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">cache</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The new variable gives more expressive names to the variables related to the cache, and because the <code class="language-plaintext highlighter-rouge">sync.Mutex</code> field is embeed witin it, its <code class="language-plaintext highlighter-rouge">Lock</code> and <code class="language-plaintext highlighter-rouge">Unlock</code> methods are promoted to the unnamed type, allowing us to lock the <code class="language-plaintext highlighter-rouge">cache</code> with a self-explanatory syntax.</p>

<h3 id="method-values-and-expressions">Method Values and Expressions</h3>

<p>Usually we select and call a method in the same expression, as in <code class="language-plaintext highlighter-rouge">p.Distance</code>, but it’s possible to separate these two operations. The selector <code class="language-plaintext highlighter-rouge">p.Distance</code> yields a <strong><em>method value</em></strong>, a function that binds a method (<code class="language-plaintext highlighter-rouge">Point.Distance</code>) to a specific receiver value <code class="language-plaintext highlighter-rouge">p</code>. This function can then be invoked without a receiver value; it needs only the non-receiver arguments.</p>

<p>For example, the function <code class="language-plaintext highlighter-rouge">time.AfterFunc</code> calls a function value after a specified delay. This program uses it to launch the rocket <code class="language-plaintext highlighter-rouge">r</code> after 10 seconds:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Rocket</span> <span class="k">struct</span> <span class="p">{</span> <span class="c">/* ... */</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">Rocket</span><span class="p">)</span> <span class="n">Launch</span><span class="p">()</span> <span class="p">{</span> <span class="c">/*...*/</span> <span class="p">}</span>

<span class="n">r</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">Rocket</span><span class="p">)</span>
<span class="n">time</span><span class="o">.</span><span class="n">AfterFunc</span><span class="p">(</span><span class="m">10</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">,</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">r</span><span class="o">.</span><span class="n">Launch</span><span class="p">()</span> <span class="p">})</span>
</code></pre></div></div>

<p>The method values syntax is shorter:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">time</span><span class="o">.</span><span class="n">AfterFunc</span><span class="p">(</span><span class="m">10</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">Launch</span><span class="p">)</span>
</code></pre></div></div>

<p>Related to the method value is the <strong><em>method expression</em></strong>. When calling a method, as opposed to an ordinary function, we must supply the receiver in a special way using the selector syntax. A method expression, written <code class="language-plaintext highlighter-rouge">T.f</code> or <code class="language-plaintext highlighter-rouge">(*T).f</code> where <code class="language-plaintext highlighter-rouge">T</code> is a type, yield a function value with a regular first parameter taking the place of the receiver, so it can be called in the usual way.</p>

<p>In the following example, the variable <code class="language-plaintext highlighter-rouge">op</code> represents either the addition or the subtraction method of type <code class="language-plaintext highlighter-rouge">Point</code>, and the <code class="language-plaintext highlighter-rouge">Path.TranslateBy</code> calls it for each point in the <code class="language-plaintext highlighter-rouge">Path</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Point</span> <span class="k">struct</span><span class="p">{</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">Point</span><span class="p">)</span> <span class="n">Add</span><span class="p">(</span><span class="n">q</span> <span class="n">Point</span><span class="p">)</span> <span class="n">Point</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Point</span><span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">X</span> <span class="o">+</span> <span class="n">q</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">Y</span> <span class="o">+</span> <span class="n">q</span><span class="o">.</span><span class="n">Y</span><span class="p">}</span> <span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">Point</span><span class="p">)</span> <span class="n">Sub</span><span class="p">(</span><span class="n">q</span> <span class="n">Point</span><span class="p">)</span> <span class="n">Point</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Point</span><span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span> <span class="n">q</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">Y</span> <span class="o">-</span> <span class="n">q</span><span class="o">.</span><span class="n">Y</span><span class="p">}</span> <span class="p">}</span>

<span class="k">type</span> <span class="n">Path</span> <span class="p">[]</span><span class="n">Point</span>

<span class="k">func</span> <span class="p">(</span><span class="n">path</span> <span class="n">Path</span><span class="p">)</span> <span class="n">TranslateBy</span><span class="p">(</span><span class="n">offset</span> <span class="n">Point</span><span class="p">,</span> <span class="n">add</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">op</span> <span class="k">func</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="n">Point</span><span class="p">)</span> <span class="n">Point</span>
	<span class="k">if</span> <span class="n">add</span> <span class="p">{</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="n">Add</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="n">Sub</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">path</span> <span class="p">{</span>
		<span class="c">// Call either path[i].Add(offset) or path[i].Sub(offset).</span>
		<span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">offset</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="encapsulation">Encapsulation</h3>

<p>Go has only one mechnism to control the visibility of names: capitalized identifiers are exported from the package in which they are defined, and uncaptitalized names are not. The same mechanism that limits access to memebers of a package also limits access to the fields of a struct or the methods of a type. As a consequnce, to encapsulation an object, we must make it struct.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">IntSet</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">words</span> <span class="p">[]</span><span class="kt">uint64</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We could instead define <code class="language-plaintext highlighter-rouge">IntSet</code> as a slice type as follows:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">IntSet</span> <span class="p">[]</span><span class="kt">uint64</span>
</code></pre></div></div>

<p>Although this version of <code class="language-plaintext highlighter-rouge">IntSet</code> would be essentially equivalent, it would allow clients from other packages to read and modify the slice directly.</p>

<p>Another consequence of this name-based mechanism is that the unit of encapsulation is the package, not the type as in many other languages. The fields of a struct type are visible to all code within the same package. Whether the code appears in a function or a method makes no difference.</p>

<p>Function that merely access or modify interal values of a type, such as the method of the <code class="language-plaintext highlighter-rouge">Logger</code> type from <code class="language-plaintext highlighter-rouge">log</code> package, below, are called <strong><em>getters</em></strong> and <strong><em>setters</em></strong>. However, when naming a getter method, we usually omit the <strong>Get</strong> prefix. This preference for brevity extends to all methods, not just field accessors, and to other redundant prefixes as well, such as <code class="language-plaintext highlighter-rouge">Fetch</code>, <code class="language-plaintext highlighter-rouge">Find</code>, and <code class="language-plaintext highlighter-rouge">Lookup</code>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">log</span>

<span class="k">type</span> <span class="n">Logger</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">flags</span>  <span class="kt">int</span>
	<span class="n">prefix</span> <span class="kt">string</span>
	<span class="c">// ...</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">Logger</span><span class="p">)</span> <span class="n">Flags</span><span class="p">()</span> <span class="kt">int</span>
<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">Logger</span><span class="p">)</span> <span class="n">SetFlags</span><span class="p">(</span><span class="n">flag</span> <span class="kt">int</span><span class="p">)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">Logger</span><span class="p">)</span> <span class="n">Prefix</span><span class="p">()</span> <span class="kt">string</span>
<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">Logger</span><span class="p">)</span> <span class="n">SetPrefix</span><span class="p">(</span><span class="n">prefix</span> <span class="kt">string</span><span class="p">)</span>
</code></pre></div></div>

<p>Encapsulation is not always desirable. By revealing its represention as an <code class="language-plaintext highlighter-rouge">int64</code> number of nanoseconds, <code class="language-plaintext highlighter-rouge">time.Duration</code> lets us use all the usual arithmetic and comparsion operations with durations, and even to define constants of this type:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">const</span> <span class="n">day</span> <span class="o">=</span> <span class="m">24</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Hour</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%t</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">day</span><span class="p">)</span> <span class="c">// %!t(time.Duration=86400000000000)</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="interfaces">Interfaces</h2>

<p>Interface types express generalizations or abstractions about the behaviors of other types. By generalizing, interfaces let us write functions that are more flexible and adaptable because they are not tied to the details of one particular implementation.</p>

<p>Many object-oriented languages have some notion of interface, but what makes Go’s interfaces so distinctive is they are <strong><em>satisfied implicitly</em></strong>. In other words, there’s no need to declare all the interfaces that a given concrete type satisfies; simply possessing the necessary methods is enough. This design lets you create new interfaces that are satisfied by existing concrete types without changing the existing types, which is particularly useful for types defined in packages that you don’t control.</p>

<h3 id="interface-as-contracts">Interface as Contracts</h3>

<p>A concrete type specifies the exact representation of its values and exposes the intrinsic operations of that representation, such as arithmetric for numbers, or indexing, <em>append</em>, and <em>range</em> for slices. A concrete type may also provide additional behaviors through its methods. <strong>When you have a value of a concrete type, you knonw exactly what it <em>is</em> and what you can <em>do</em> with it.</strong></p>

<p>An interface is an <strong><em>abstract type</em></strong>. It doesn’t expose the representation or iternal structure of its values, or the set of basic operations they support; it reveals only some of their methods. <strong>When you have a value of an interface type, you know nothing about what it <em>is</em>; you know only what it can <em>do</em>, or more precisely, what behaviors are provided by its methods.</strong></p>

<h3 id="interface-types">Interface Types</h3>

<p>An interface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface.</p>

<p>The <strong>io.Writer</strong> type is one of the most widely used interfaces because it provides an abstraction of all the types to which bytes can be written, which includes files, memory buffers, network connections, HTTP clients, archivers, hashers, and so on. The <strong>io</strong> package defines many other useful interfaces. A <strong>Reader</strong> represents any type from which you can read bytes, and a <strong>Closer</strong> is any value that you can close, such as a file or a network connection.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">io</span>

<span class="k">type</span> <span class="n">Writer</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Write</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Reader</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Closer</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Looking farther, we find declarations of new interface types as combinations of existing ones.</p>

<p>Here are two examples:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">io</span>

<span class="c">// ReadWriter is the interface that groups the basic Read and Write methods.</span>
<span class="k">type</span> <span class="n">ReadWriter</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Reader</span>
	<span class="n">Writer</span>
<span class="p">}</span>

<span class="c">// ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.</span>
<span class="k">type</span> <span class="n">ReadWriteCloser</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Reader</span>
	<span class="n">Writer</span>
	<span class="n">Closer</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The syntax used above, which resembles struct embedding, lets us name another interface as a shorthand for writting out all of its methods. This is called <strong><em>embedding</em></strong> an interface.</p>

<h3 id="interface-satisfaction">Interface Satisfaction</h3>

<p>A type *statisfies an interface if it possesses all the methods the interface requires. For example, an <strong>*os.File</strong> satisfies <strong>io.Reader</strong>, <strong>Writer</strong>, <strong>Closer</strong>, and <strong>ReadWriter</strong>. A <strong>*bytes.Buffer</strong> satisfies <strong>Reader</strong>, <strong>Writer</strong>, and <strong>ReadWriter</strong>, but does not satisfy <strong>Closer</strong> because it does not have a <strong>Close</strong> method.</p>

<p>The assignability rule for interfaces is very simple: an expression may be assigned to an interface only if its type satifies the interface. So:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>         <span class="c">// OK: *os.File has Write method</span>
	<span class="n">w</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span> <span class="c">// OK: *bytes.Buffer has Write method</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span>       <span class="c">// compile error: time.Duration lacks Write method</span>

	<span class="k">var</span> <span class="n">rwc</span> <span class="n">io</span><span class="o">.</span><span class="n">ReadWriteCloser</span>
	<span class="n">rwc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>         <span class="c">// OK: *os.File has Read, Write, Close methods</span>
	<span class="n">rwc</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span> <span class="c">// compile error: *bytes.Buffer lacks Close method</span>
</code></pre></div></div>

<p>This rule applies even when the right-hand side is itself an interface:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">w</span> <span class="o">=</span> <span class="n">rwc</span> <span class="c">// OK: io.ReadWriteCloser has Write method</span>
	<span class="n">rwc</span> <span class="o">=</span> <span class="n">w</span> <span class="c">// compile error: io.Writer lacks Close method</span>
</code></pre></div></div>

<p>The type <strong>interface{}</strong>, which is called the <strong><em>empty interface</em></strong> type places no demands on the types that statisfy it, we can assign <strong><em>any</em></strong> value to the empty interface.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">any</span> <span class="k">interface</span><span class="p">{}</span>
	<span class="n">any</span> <span class="o">=</span> <span class="no">true</span>
	<span class="n">any</span> <span class="o">=</span> <span class="m">12.34</span>
	<span class="n">any</span> <span class="o">=</span> <span class="s">"hello"</span>
	<span class="n">any</span> <span class="o">=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">"one"</span><span class="o">:</span> <span class="m">1</span><span class="p">}</span>
	<span class="n">any</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span>
</code></pre></div></div>

<p>Since interface satisfcation depends only on the methods of the two type involved, there is no need to declare the relationship between a concrete type and the interface it satifies. That said, it is occasionally useful to document and assert the relationship when it is intended but not otherwise enforced by the program. The declaration below assets at compile time that a value of type <strong>*bytes.Buffer</strong> satifies <strong>io.Writer</strong>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="c">// *bytes.Buffer must satisfy io.Writer</span>
	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span>
</code></pre></div></div>

<p>We needn’t allocate a new variable since any value of type <strong>*bytes.Buffer</strong> will do, even <strong>nil</strong>, which we writes as <strong>(*bytes.Buffer)(nil)</strong> using an explicit conversion. And since we never intend to refer to <strong>w</strong>, we can replace it with the blank identifier. Together, these changes give us this more frugal variant:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="c">// *bytes.Buffer must satisfy io.Writer</span>
	<span class="k">var</span> <span class="n">_</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)(</span><span class="no">nil</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="interface-values">Interface Values</h3>

<p>Conceptually, a value of an interface type, or <strong><em>interface value</em></strong>, has two components, a concrete type and a value of that type. These are called the interface’s <strong><em>dynamic type</em></strong> and <strong><em>dynamic value</em></strong>.</p>

<p>For a statically typed language like Go, types are a compile-time concept, so a type is not a value. In our conceptual model, a set of values called <strong><em>type descriptors</em></strong> provide information about each type, such as its name and methods. In an interface value, the type component is represented by the appropriate type descriptor.</p>

<p><strong>The zero value for an interface has both its type and value components set to <em>nil</em></strong>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span>
</code></pre></div></div>

<p><img src="/assets/gopl/a-nil-interface-value.png" alt="A nil interface value" title="A nil interface value" /></p>

<p><strong>An interface value is described as nil or non-nil based on its dynamic type</strong>, so this is a nil interface value.</p>

<p>The below statement assigns a value of type <strong>*os.File</strong> to <strong>w</strong>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>
</code></pre></div></div>

<p>This assignment involves an implicit conversion from a concrete type to an interface type, and is equivalent to the explicit conversion <strong>io.Writer(os.Stdout)</strong>. A conversion of this kind, whether explicit or implicit, captures the type and the value of its operand. The interface values’ dynamic type is set to the type descriptor for the pointer type <strong>*os.File</strong>, and its dynamic value holds a copy of <strong>os.Stdout</strong>, which is a pointer to the <strong>os.File</strong> variable representing the standard output of process.</p>

<p><img src="/assets/gopl/an-interface-value-containing-an-os-File-pointer.png" alt="An interface value containing an *os.File pointer" /></p>

<p>Calling the <strong>Write</strong> method on an interface value containing an <strong>*os.File</strong> pointer causes the <strong>(*os.File).Write</strong> method to be called. The call prints <strong>“hello”</strong>.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">w</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"hello"</span><span class="p">))</span>         <span class="c">// "hello"</span>
</code></pre></div></div>

<p>In general, we cannot know at compile time that what the dynamic type of an interface value will be, so a call through an interface must use <strong><em>dynamic dispatch</em></strong>. Instead of a direct call, the compiler must generate code to obtain the address of the method named <strong>Write</strong> from the type descriptor, then make an indirect call to the address. The receiver argument for the  call is a copy of the interface’s dynamic value, <strong>os.Stdout</strong>. The effect is as if we had make this call directly:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">os</span><span class="o">.</span><span class="n">Stdout</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"hello"</span><span class="p">))</span> <span class="c">// "hello"</span>
</code></pre></div></div>

<p>Interface values may be compared using <code class="language-plaintext highlighter-rouge">==</code> and <code class="language-plaintext highlighter-rouge">!=</code>. Two interface values are equal if both are nil, or if their dynamic types are identical and their dynmaic values are equal according to the usual behavior of <code class="language-plaintext highlighter-rouge">==</code> for that type. However, if two interface values are compared and have the same dynamic type, but the that type is not comparable (a slice, for instance), then the comparision fails with a panic:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">x</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="c">// panic: comparing uncomparable type []int</span>
</code></pre></div></div>

<h4 id="caveat-an-interface-containing-a-nil-pointer-is-non-nil">Caveat: An Interface Containing a Nil Pointer Is Non-Nil</h4>

<p>A nil interface value, which contains no value at all, is not the same as an interface value containing a pointer that happens to be nil.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"bytes"</span>
	<span class="s">"io"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">buf</span> <span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span>
	<span class="k">var</span> <span class="n">out</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span>
	<span class="n">out</span> <span class="o">=</span> <span class="n">buf</span> <span class="c">// NOTE: subtly incorrect!</span>
	<span class="k">if</span> <span class="n">out</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">out</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"done!</span><span class="se">\n</span><span class="s">"</span><span class="p">))</span> <span class="c">// panic: runtime error: invalid memory address or nil pointer dereference</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/gopl/a-non-nil-interface-containing-a-nil-pointer.png" alt="A non-nil interface containing a nil pointer" /></p>

<hr />

<h3 id="type-assertions">Type Assertions</h3>

<p>A <strong><em>type assertion</em></strong> is an operation applied to an interface value. Syntactically, it looks like <strong>x.(T)</strong>, where <strong>x</strong> is an expression of an interface type and <strong>T</strong> is a type, called the “asserted” type. A type assertion checks that the dynamic type of its operand matches the asserted type.</p>

<p><strong>A type assertion to a concrete type extracts the concrete value from its operand.</strong> If the check fails, then the operation panics.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>
	<span class="n">f</span> <span class="o">:=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">)</span>      <span class="c">// success: f == os.Stdout</span>
	<span class="n">c</span> <span class="o">:=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span> <span class="c">// panic: interface holds *os.File, not *bytes.Buffer</span>
</code></pre></div></div>
<p><strong>A type assertion to an interface type changes the type of the expression</strong>, making a different (and usually larger) set of methods accessible, but it preserves the dynamic type and value components inside the interface.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>
	<span class="n">rw</span> <span class="o">:=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">ReadWriter</span><span class="p">)</span> <span class="c">// success: *os.File has both Read and Write</span>

	<span class="n">w</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">ByteCounter</span><span class="p">)</span>
	<span class="n">rw</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">ReadWriter</span><span class="p">)</span> <span class="c">// panic: *ByteCounter has no Read method</span>
</code></pre></div></div>

<p>No matter what type was asserted, <strong>if the operand is a nil interface value, the value assertion fails</strong>.</p>

<p>If the type assertion appears is an assignment in which two results are expected, such as the following declarations, the operation does not panic on failure but instead returns an additional second result, a boolean indicating success.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>
	<span class="n">f</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">)</span>      <span class="c">// success:  ok, f == os.Stdout</span>
	<span class="n">b</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span> <span class="c">// failure: !ok, b == nil</span>
</code></pre></div></div>

<p>When the operand of a type assertion is a variable, rather than invent another name for the new local variable, you’ll sometimes see the original name reused, shadowing the original, like this:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="n">w</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>
	<span class="k">if</span> <span class="n">w</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="n">w</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"Hello world"</span><span class="p">))</span>
		<span class="c">// ...use w...</span>
	<span class="p">}</span>
</code></pre></div></div>

<h3 id="type-switches">Type Switches</h3>

<p>Interfaces are used in two distinct styles. In the first style, exemplified by <strong>io.Reader</strong>, <strong>io.Writer</strong>, <strong>fmt.Stringer</strong>, <strong>sort.Interface</strong>, <strong>http.Handler</strong>, and <strong>error</strong>, an interface’s methods express the similarities of the concrete types that satisfy the interface but hide the representation detail and intrinsic operations of those concrete types. <strong>The emphasis is on the methods, not on the concrete types.</strong></p>

<p>The second style exploits the ablility of an interface value to hold values of a variety of concrete types and considers the interface to be the <strong>union</strong> of those types. Type assertions are used to discriminate among these types dynamically and treat each case differently. In this style, <strong>the emphasis is on the concrete types that satisfy the interface</strong>, not on the interface’s methods (if indeed it has any), and there is no hiding of information.</p>

<p>Go’s API for quering an SQL database, like those of other languages, lets us cleanly separate the fixed part of a query from the variable parts. An example client might look like this:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"database/sql"</span>

<span class="k">func</span> <span class="n">listTracks</span><span class="p">(</span><span class="n">db</span> <span class="n">sql</span><span class="o">.</span><span class="n">DB</span><span class="p">,</span> <span class="n">artist</span> <span class="kt">string</span><span class="p">,</span> <span class="n">minYear</span><span class="p">,</span> <span class="n">maxYear</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">result</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">Exec</span><span class="p">(</span>
		<span class="s">"SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?"</span><span class="p">,</span>
		<span class="n">artist</span><span class="p">,</span> <span class="n">minYear</span><span class="p">,</span> <span class="n">maxYear</span><span class="p">)</span>
	<span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <strong>Exec</strong> method replace each ‘<strong>?</strong>’ in the query string with an SQL literal denoting the coresponding argument value, which may be a boolean, a number, a string, or <strong>nil</strong>. Within <strong>Exec</strong>, we might find a function like the one below, which converts each argument value to its literal SQL notation.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">sqlQuote</span><span class="p">(</span><span class="n">x</span> <span class="k">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">"NULL"</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">uint</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">b</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">bool</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">b</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">"TRUE"</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="s">"FALSE"</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">s</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">sqlQuoteString</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c">// (not shown)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"unexpected type %T: %v"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A <strong>switch</strong> statement simplifies an <strong>if-else</strong> chain that performs a series of value equality tests. An analogous <strong>type switch</strong> statement simplifies an <strong>if-else</strong> chain of type assertions.</p>

<p>In its simplest form, a type switch looks like an oridinary switch statement in which the operand is <strong>x.(type)</strong>—that’s literally the keyword <strong>type</strong>—and each case has one or more types. <strong>A type switch enables a multi-way branch based on the interface value’s dynamic type.</strong> The <strong>nil</strong> case matchs if <strong>x == nil</strong>, and the <strong>default</strong> case matches if no other case does. No <strong>fallthrough</strong> is allowed. A type switch for <strong>sqlQuote</strong> would have these cases:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">switch</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="no">nil</span><span class="o">:</span> <span class="c">// ...</span>
	<span class="k">case</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">uint</span><span class="o">:</span> <span class="c">// ...</span>
	<span class="k">case</span> <span class="kt">bool</span><span class="o">:</span> <span class="c">// ...</span>
	<span class="k">case</span> <span class="kt">string</span><span class="o">:</span> <span class="c">// ...</span>
	<span class="k">default</span><span class="o">:</span> <span class="c">// ...</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>Typically, the type switch statement has an extended form that binds the extracted value to a new variable within each case:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">switch</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// ...</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>Like a <strong>switch</strong> statement, a type switch implicitly creates a lexical block, so the declration of the new variable called <strong>x</strong> does not conflict with a variable <strong>x</strong> in an outer block. Each <strong>case</strong> also implicitly creates a separate lexical block.</p>

<p>Rewriting <strong>sqlQuote</strong> to use the extended form of type switch makes it significantly clearer:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">sqlQuote</span><span class="p">(</span><span class="n">x</span> <span class="k">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="no">nil</span><span class="o">:</span>
		<span class="k">return</span> <span class="s">"NULL"</span>
	<span class="k">case</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">uint</span><span class="o">:</span>
		<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c">// x has type interface{} here.</span>
	<span class="k">case</span> <span class="kt">bool</span><span class="o">:</span>
		<span class="k">if</span> <span class="n">x</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">"TRUE"</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="s">"FALSE"</span>
	<span class="k">case</span> <span class="kt">string</span><span class="o">:</span>
		<span class="k">return</span> <span class="n">sqlQuoteString</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c">// (not shown)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"unexpected type %T: %v"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="references">References</h3>

<ol>
  <li>Alan A. A. Donovan, Brian W. Kernighan. The Go Programming Language, 2015.11.</li>
  <li><a href="https://golang.org/ref/spec#Interface_types">Interface types</a>, The Go Programming Language Specification.</li>
  <li><a href="https://golang.org/doc/effective_go.html#interface-names">Interface names</a>, Effective Go - The Go Programming Language</li>
</ol>

  </div>

  <ul class="post-navigation">
    <li>
      
      <a href="/2017/05/21/deffered-function-calls-in-go-language/">&laquo; Deffered Function Calls in Go Language</a>
      
    </li>
    <li>
      
      <a href="/2017/06/11/goroutines-and-channels-in-go-lanugage/">Goroutines and Channels in Go Lanugage &raquo;</a>
      
    </li>
  </ul>
</article>

      </div>
    </div>

    <footer class="site-footer">
  <div class="license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details open>
    <summary>Extral Links</summary>
    <div>
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>


<!-- https://github.com/bryanbraun/anchorjs -->
<script src="/js/anchor.min.js"></script>
<script>
  anchors.add();
  anchors.remove(".site-title");
</script>




  </body>

</html>
