<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bing WebMaster -->
  <meta name="msvalidate.01" content="AB2FFF876C37F59D9121882CC8395DE5" />

  <title>TCP/IP: Internet Protocol</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://blog.codefarm.me/2022/11/22/tcp-ip-internet-protocol/">
  <link rel="alternate" type="application/rss+xml" title="CODE FARM" href="https://blog.codefarm.me/feed.xml">

  <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->
<script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>

  
<!-- Google Analytics Website tracking -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-83971182-1', 'auto');
  ga('send', 'pageview');

</script>


  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SN88FJ18E5');
</script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">
    <h2 class="site-title">
      <a class="site-title" href="/">CODE FARM</a>
    </h2>

     <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
        <div class="trigger">
            <ul>
                <li><a href="/">home</a>
                <li><a href="/category">category</a>
                <li><a href="/tag">tag</a>
                <li><a href="/archive">archive</a>
                <li><a href="/about">about</a>
                <li><a href="https://resume.github.io/?qqbuby" target="_blank">R&eacute;sum&eacute;</a>
            </ul>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">TCP/IP: Internet Protocol</h1>
    
    
    <p class="post-meta"><time datetime="2022-11-22T09:17:14+08:00" itemprop="datePublished">Nov 22, 2022</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#ipv4-and-ipv6-headers">1. IPv4 and IPv6 Headers</a>
<ul class="sectlevel2">
<li><a href="#ip-header-fields">1.1. IP Header Fields</a></li>
<li><a href="#the-internet-checksum">1.2. The Internet Checksum</a></li>
</ul>
</li>
<li><a href="#ip-forwarding">2. IP Forwarding</a>
<ul class="sectlevel2">
<li><a href="#forwarding-table">2.1. Forwarding Table</a></li>
<li><a href="#ip-forwarding-actions">2.2. IP Forwarding Actions</a></li>
<li><a href="#direct-delivery-and-indirect-delivery">2.3. Direct delivery and indirect delivery</a></li>
</ul>
</li>
<li><a href="#mobile-ip">3. Mobile IP</a>
<ul class="sectlevel2">
<li><a href="#the-basic-model-for-ip-mobility-bidirectional-tunneling">3.1. The Basic Model for IP Mobility: Bidirectional Tunneling</a></li>
</ul>
</li>
<li><a href="#host-processing-of-ip-datagrams">4. Host Processing of IP Datagrams</a>
<ul class="sectlevel2">
<li><a href="#host-models">4.1. Host Models</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>IP is the workhorse protocol of the TCP/IP protocol suite. All TCP, UDP, ICMP, and IGMP data gets transmitted as IP datagrams. IP provides a <strong><em>best-effort</em></strong>, <strong><em>connectionless</em></strong> datagram delivery service.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ipv4-and-ipv6-headers">1. IPv4 and IPv6 Headers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The normal size of the IPv4 header is 20 bytes, unless <em>options</em> are present (which is rare).</p>
</div>
<div class="paragraph">
<p>The IPv6 header is twice as large but never has any options, may have <em>extension headers</em>.</p>
</div>
<div class="paragraph">
<p>The most significant bit of headers and datagrams is numbered 0 at the left, and the least significant bit of a 32-bit value is numbered 31 on the right.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The 4 bytes in a 32-bit value are transmitted in the following order: bits <em>0–7</em> first, then bits <em>8–15</em>, then <em>16–23</em>, and bits <em>24–31</em> last.</p>
</li>
<li>
<p>This is called <strong>big endian byte ordering</strong>, which is the byte ordering required for all binary integers in the TCP/IP headers as they traverse a network. It is also called <strong>network byte order</strong>.</p>
</li>
<li>
<p>Computer CPUs that store binary integers in other formats, such as the <strong>little endian</strong> format, must convert the header values into network byte order for transmission and back again for reception.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>lscpu
<span class="go">Architecture:                    x86_64</span>
<span class="go">CPU op-mode(s):                  32-bit, 64-bit</span>
<span class="hll"><span class="go">Byte Order:                      Little Endian</span>
</span><span class="go">Model name:                      Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/internet-protocol/ipv4-datagram.png" alt="IPv4 Datagram" width="55%" height="55%">
</div>
<div class="title">Figure 1. The IPv4 datagram format.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The header is of variable size, limited to fifteen 32-bit words (60 bytes) by the 4-bit <em>IHL</em> field.</p>
</li>
<li>
<p>A typical IPv4 header contains 20 bytes (no options).</p>
</li>
<li>
<p>The source and destination addresses are 32 bits long.</p>
</li>
<li>
<p>Most of the second 32-bit word is used for the IPv4 <em>fragmentation</em> function.</p>
</li>
<li>
<p>A header <em>checksum</em> helps ensure that the fields in the header are delivered correctly to the proper destination but does not protect the data.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/internet-protocol/ipv6-datagram.png" alt="IPv6 Datagram" width="55%" height="55%">
</div>
<div class="title">Figure 2. The IPv6 datagram format.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The IPv6 header is of fixed size (40 bytes) and contains 128-bit <em>source</em> and <em>destination</em> addresses.</p>
</li>
<li>
<p>The <em>Next Header</em> field is used to indicate the presence and types of additional extension headers that follow the IPv6 header, forming a <em>daisy chain of headers</em> that may include special extensions or processing directives.</p>
</li>
<li>
<p>Application data follows the header chain, usually immediately following a transport-layer header.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="ip-header-fields">1.1. IP Header Fields</h3>
<div class="paragraph">
<p>The first field (only 4 bits or one nibble wide) is the <em>Version</em> field.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It contains the version number of the IP datagram: <em>4</em> for IPv4 and <em>6</em> for IPv6.</p>
</li>
<li>
<p>The headers for both IPv4 and IPv6 share the location of the <em>Version</em> field but no others.</p>
</li>
<li>
<p>Thus, the two protocols are not directly interoperable—a host or router must handle either IPv4 or IPv6 (or both, called <strong><em>dual stack</em></strong>) separately.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Internet Header Length (IHL)</em> field is the number of 32-bit words in the IPv4 header, including any options.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Because this is also a 4-bit field, the IPv4 header is limited to a maximum of fifteen 32-bit words or 60 bytes.</p>
<div class="paragraph">
<p>The normal value of this field (when no options are present) is 5.</p>
</div>
</li>
<li>
<p>There is no such field in IPv6 because the header length is fixed at 40 bytes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Following the header length, the original specification of IPv4 [RFC0791] specified a <em>Type of Service (ToS)</em> byte, and IPv6 [RFC2460] specified the equivalent <em>Traffic Class</em> byte.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use of these never became widespread, so eventually this 8-bit field was split into two smaller parts and redefined by a set of RFCs ([RFC3260] [RFC3168][RFC2474] and others).</p>
<div class="ulist">
<ul>
<li>
<p>The first 6 bits are now called the <em>Differentiated Services</em> Field (<em>DS</em> Field), and the last 2 bits are the <em>Explicit Congestion Notification</em> (<em>ECN</em>) field or indicator bits.</p>
</li>
<li>
<p>These RFCs now apply to both IPv4 and IPv6.</p>
</li>
</ul>
</div>
</li>
<li>
<p>These fields are used for special processing of the datagram when it is forwarded.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Total Length</em> field is the total length of the IPv4 datagram in bytes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using this field and the <em>IHL</em> field, we know where the data portion of the datagram starts, and its length.</p>
</li>
<li>
<p>Because this is a 16-bit field, the maximum size of an IPv4 datagram (including header) is 65,535 bytes.</p>
</li>
<li>
<p>Although it is possible to send a 65,535-byte IP datagram, most link layers (such as Ethernet) are not able to carry one this large without fragmenting it (chopping it up) into smaller pieces.</p>
<div class="paragraph">
<p>Furthermore, a host is not required to be able to receive an IPv4 datagram larger than <em>576</em> bytes.</p>
</div>
<div class="paragraph">
<p>In IPv6 a host must be able to process a datagram at least as large as the MTU of the link to which it is attached, and the minimum link MTU is <em>1280</em> bytes.</p>
</div>
<div class="paragraph">
<p>When an IPv4 datagram is fragmented into multiple smaller fragments, each of which itself is an independent IP datagram, the <em>Total Length</em> field reflects the length of the particular fragment.</p>
</div>
<div class="paragraph">
<p>In IPv6, fragmentation is not supported by the header, and the length is instead given by the <em>Payload Length</em> field.</p>
</div>
<div class="paragraph">
<p>This field measures the length of the IPv6 datagram not including the length of the header; extension headers, however, are included in the <em>Payload Length</em> field.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Identification</em> field helps indentify each datagram sent by an IPv4 host.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To ensure that the fragments of one datagram are not confused with those of another, the sending host normally increments an internal counter by 1 each time a datagram is sent (from one of its IP addresses) and copies the value of the counter into the IPv4 <em>Identification</em> field.</p>
</li>
<li>
<p>The <em>Identification</em>, <em>Flags</em> and <em>Fragment Offset</em> fields are most important for implementing fragmentation.</p>
<div class="paragraph">
<p>In IPv6, this field shows up in the <em>Fragmentation extension header</em>.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Time-to-Live</em> field, or <em>TTL</em>, sets an upper limit on the number of routers through which a datagram can pass.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is initialized by the sender to some value (<em>64</em> is recommended [RFC1122], although <em>128</em> or <em>255</em> is not uncommon) and decremented by <em>1</em> by every router that forwards the datagram.</p>
</li>
<li>
<p>When this field reaches <em>0</em>, the datagram is thrown away, and the sender is notified with an <em>ICMP</em> message.</p>
<div class="paragraph">
<p>This prevents packets from getting caught in the network forever should an unwanted routing loop occur.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Protocol</em> field in the IPv4 header contains a number indicating the type of data found in the payload portion of the datagram.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The most common values are <em>17</em> (for UDP) and <em>6</em> (for TCP).</p>
</li>
<li>
<p>This provides a demultiplexing feature so that the IP protocol can be used to carry payloads of more than one protocol type.</p>
</li>
<li>
<p>Although this field originally specified the <em>transport-layer protocol</em> the datagram is encapsulating, it is now understood to identify the encapsulated protocol, which may or not be a transport protocol.</p>
<div class="paragraph">
<p>For example, other encapsulations are possible, such as <em>IPv4-in-IPv4</em> (value <em>4</em>).</p>
</div>
</li>
<li>
<p>The official list of the possible values of the Protocol field is given in the assigned numbers page [AN].</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Next Header</em> field in the IPv6 header generalizes the <em>Protocol</em> field from IPv4.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is used to indicate the type of header following the IPv6 header.</p>
</li>
<li>
<p>This field may contain any values defined for the IPv4 <em>Protocol</em> field, or any of the values associated with the IPv6 extension headers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Header Checksum</em> field is calculated over the IPv4 header only.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This is important to understand because it means that the payload of the IPv4 datagram (e.g., TCP or UDP data) is not checked for correctness by the IP protocol.</p>
</li>
<li>
<p>Perhaps surprisingly, the IPv6 header does not have any checksum field.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Every IP datagram contains the <em>Source IP Address</em> of the sender of the datagram and the <em>Destination IP Address</em> of where the datagram is destined.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>These are 32-bit values for IPv4 and 128-bit values for IPv6, and they usually identify a single interface on a computer, although multicast and broadcast addresses  violate this rule.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="the-internet-checksum">1.2. The Internet Checksum</h3>
<div class="paragraph">
<p>The Internet checksum is a 16-bit mathematical sum used to determine, with reasonably high probability, whether a received message or portion of a message matches the one sent.</p>
</div>
<div class="paragraph">
<p>Note that the Internet checksum algorithm is not the same as the common <em>cyclic redundancy check</em> (CRC), which offers stronger protection.</p>
</div>
<div class="paragraph">
<p>To compute the IPv4 header checksum for an outgoing datagram,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the value of the datagram&#8217;s <em>Checksum</em> field is first set to 0.</p>
</li>
<li>
<p>Then, the 16-bit one&#8217;s complement sum of the header is calculated (the entire header is considered a sequence of 16-bit words).</p>
</li>
<li>
<p>The 16-bit one&#8217;s complement of this sum is then stored in the <em>Checksum</em> field to make the datagram ready for transmission.</p>
<div class="paragraph">
<p>One&#8217;s complement addition can be implemented by "end-round-carry addition": when a carry bit is produced using conventional (two&#8217;s complement) addition, the carry is added back in as a 1 value.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>When an IPv4 datagram is received, a checksum is computed across the whole header, including the value of the <em>Checksum</em> field itself. Assuming there are no errors, the computed checksum value is always 0 (a one&#8217;s complement of the value <em>FFFF</em>).</p>
</div>
<div class="paragraph">
<p>Note that for any nontrivial packet or header, the value of the <em>Checksum</em> field in the packet can never be <em>FFFF</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If it were, the sum (prior to the final one&#8217;s complement operation at the sender) would have to have been 0.</p>
</li>
<li>
<p>No sum can ever be 0 using one&#8217;s complement addition unless all the bytes are 0—something that never happens with any legitimate IPv4 header.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the header is found to be bad (the computed checksum is nonzero), the IPv4 implementation discards the received datagram.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No error message is generated.</p>
</li>
<li>
<p>It is up to the higher layers to somehow detect the missing datagram and retransmit if necessary.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/internet-protocol/internet-checksum-computed-check.png" alt="Internet checksum" width="55%" height="55%">
</div>
<div class="title">Figure 3. The Internet checksum is the one&#8217;s complement of a one&#8217;s complement 16-bit sum of the data being checksummed (zero padding is used if the number of bytes being summed is odd). If the data being summed includes a <em>Checksum</em> field, the field is first set to 0 prior to the checksum operation and then filled in with the computed checksum. To check whether an incoming block of data that contains a <em>Checksum</em> field (header, payload, etc.) is valid, the same type of checksum is computed over the whole block (including the <em>Checksum</em> field). Because the <em>Checksum</em> field is essentially the inverse of the checksum of the rest of the data, computing the checksum on correctly received data should produce a value of 0.</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">45 10 01 48 00 00 00 00 10 11 70 c4 c0 a8 5b fe c0 a8 5b 82

| 45 10 | Version, IHL, DS, ECN  | 0100 0101 0001 0000

| 01 48 | Total Length           | 0000 0001 0100 1000
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0100 0110 0101 1000
<span class="go">| 00 00 | Identification         | 0000 0000 0000 0000
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0100 0110 0101 1000
<span class="go">| 00 00 | Flags, Fragment Offset | 0000 0000 0000 0000
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0100 0110 0101 1000
<span class="go">| 10 11 | TTL, Protocol          | 0001 0000 0001 0001
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0101 0110 0110 1001
<span class="go">| 70 c4 | Checksum               | 0111 0000 1100 0100
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0101 0110 0110 1001
<span class="go">| c0 a8 | Source Address         | 1100 0000 1010 1000
                                 1 0001 0111 0001 0001
                                 +                   1
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0001 0111 0001 0010 <span class="c"># round-carry</span>
<span class="go">| 5b fe | Source Address         | 0101 1011 1111 1110
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0111 0011 0001 0000
<span class="go">| c0 a8 | Destination Address    | 1100 0000 1010 1000
</span><span class="gp">                                =&gt;</span><span class="w"> </span>0011 0011 1011 1001 <span class="c"># round-carry</span>
<span class="go">| 5b 82 | Destination Address    | 0101 1011 1000 0010
</span><span class="gp">                                =&gt;</span><span class="w"> </span>1000 1111 0011 1011
<span class="gp">                                =&gt;</span><span class="w"> </span>0111 0000 1100 0100 <span class="c"># one's complement (i.e. checksum)</span>
<span class="gp">                                =&gt;</span><span class="w"> </span>1111 1111 1111 1111 <span class="c"># computed including the Checksum field</span>
<span class="gp">                                =&gt;</span><span class="w"> </span>0000 0000 0000 0000 <span class="c"># one's complement (correct)</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ip-forwarding">2. IP Forwarding</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Conceptually, IP forwarding is simple, especially for a host.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the destination is directly connected to the host (e.g., a point-to-point link) or on a shared network (e.g., Ethernet), the IP datagram is sent directly to the destination—a router is not required or used.</p>
</li>
<li>
<p>Otherwise, the host sends the datagram to a single router (called the <em>default router</em>) and lets the router deliver the datagram to its destination.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>What differentiates a host from a router to IP is how IP datagrams are handled: a host never forwards datagrams it does not originate, whereas routers do.</p>
</div>
<div class="paragraph">
<p>In our general scheme, the IP protocol can receive a datagram either</p>
</div>
<div class="ulist">
<ul>
<li>
<p>from another protocol on the same machine (TCP, UDP, etc.)</p>
</li>
<li>
<p>or from a network interface.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The IP layer has some information in memory, usually called a <strong><em>routing table</em></strong> or <strong><em>forwarding table</em></strong>, which it searches each time it receives a datagram to send.</p>
</div>
<div class="paragraph">
<p>When a datagram is received from a network interface, IP first checks if the <em>destination IP address</em> is one of</p>
</div>
<div class="ulist">
<ul>
<li>
<p>its own IP addresses (i.e., one of the IP addresses associated with one of its network interfaces)</p>
</li>
<li>
<p>or some other address for which it should receive traffic such as an IP broadcast or multicast address.</p>
<div class="paragraph">
<p>If so, the datagram is delivered to the protocol module specified by the <em>Protocol</em> field in the IPv4 header or <em>Next Header</em> field in the IPv6 header.</p>
</div>
<div class="paragraph">
<p>If the datagram is not destined for one of the IP addresses being used locally by the IP module, then</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(1) if the IP layer was configured to act as a router, the datagram is forwarded;</p>
</li>
<li>
<p>or (2) the datagram is silently discarded.</p>
</li>
<li>
<p>Under some circumstances (e.g., no route is known in case 1), an ICMP message may be sent back to the source indicating an error condition.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="forwarding-table">2.1. Forwarding Table</h3>
<div class="paragraph">
<p>The IP protocol standards do not dictate the precise data required to be in a <em>forwarding table</em>, as this choice is left up to the implementer of the IP protocol.</p>
</div>
<div class="paragraph">
<p>Nevertheless, several key pieces of information are generally required to implement the forwarding table for IP.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Destination</strong>: This contains a 32-bit field (or 128-bit field for IPv6) used for matching the result of a masking operation.</p>
<div class="paragraph">
<p>The destination can be as simple as zero, for a <em>default route</em> covering all destinations, or as long as the full length of an IP address, in the case of a <em>host route</em> that describes only a single destination.</p>
</div>
</li>
<li>
<p><strong>Mask</strong>: This contains a 32-bit field (128-bit field for IPv6) applied as a bitwise <em>AND</em> mask to the destination IP address of a datagram being looked up in the <em>forwarding table</em>.</p>
<div class="paragraph">
<p>The masked result is compared with the set of destinations in the <em>forwarding table entries</em>.</p>
</div>
</li>
<li>
<p><strong>Next-hop</strong>: This contains the 32-bit IPv4 address or 128-bit IPv6 address of the next IP entity (<em>router</em> or <em>host</em>) to which the datagram should be sent.</p>
<div class="paragraph">
<p>The next-hop entity is typically on a network shared with the system performing the forwarding lookup, meaning the two share the same network prefix.</p>
</div>
</li>
<li>
<p><strong>Interface</strong>: This contains an identifier used by the IP layer to reference the network interface that should be used to send the datagram to its next hop.</p>
<div class="paragraph">
<p>For example, it could refer to a host&#8217;s 802.11 wireless interface, a wired Ethernet interface, or a PPP interface associated with a serial port.</p>
</div>
<div class="paragraph">
<p>If the forwarding system is also the sender of the IP datagram, this field is used in selecting which source IP address to use on the outgoing datagram.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>ip r
<span class="go">default via 192.168.91.2 dev ens32 onlink
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128
192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138

</span><span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>route <span class="nt">-n</span>
<span class="go">Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.91.2    0.0.0.0         UG    0      0        0 ens32
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
192.168.91.0    0.0.0.0         255.255.255.0   U     0      0        0 ens32
192.168.91.0    0.0.0.0         255.255.255.0   U     0      0        0 ens34</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">PS C:\&gt;</span><span class="w"> </span>route print <span class="nt">-4</span>
<span class="go">===========================================================================
Interface List
 10...48 2a e3 94 1e 19 ......Intel(R) Ethernet Connection (10) I219-V
  6...02 00 4c 4f 4f 50 ......Microsoft KM-TEST Loopback Adapter
  5...8c c6 81 fe 82 c5 ......Microsoft Wi-Fi Direct Virtual Adapter
</span><span class="gp">  8...8e c6 81 fe 82 c4 ......Microsoft Wi-Fi Direct Virtual Adapter #</span>2
<span class="go"> 19...00 50 56 c0 00 01 ......VMware Virtual Ethernet Adapter for VMnet1
  9...00 50 56 c0 00 08 ......VMware Virtual Ethernet Adapter for VMnet8
 13...8c c6 81 fe 82 c4 ......Intel(R) Wireless-AC 9560 160MHz
  1...........................Software Loopback Interface 1
===========================================================================

IPv4 Route Table
===========================================================================
Network Destination        Netmask          Gateway       Interface  Metric
          0.0.0.0          0.0.0.0   10.170.109.254    10.170.109.10     35
     10.170.108.0    255.255.254.0         On-link     10.170.109.10    291
    10.170.109.10  255.255.255.255         On-link     10.170.109.10    291
   10.170.109.255  255.255.255.255         On-link     10.170.109.10    291
        127.0.0.0        255.0.0.0         On-link         127.0.0.1    331
        127.0.0.1  255.255.255.255         On-link         127.0.0.1    331
  127.255.255.255  255.255.255.255         On-link         127.0.0.1    331
      169.254.0.0      255.255.0.0         On-link     169.254.24.54    281
    169.254.24.54  255.255.255.255         On-link     169.254.24.54    281
  169.254.255.255  255.255.255.255         On-link     169.254.24.54    281
     192.168.56.0    255.255.255.0         On-link      192.168.56.1    291
     192.168.56.1  255.255.255.255         On-link      192.168.56.1    291
   192.168.56.255  255.255.255.255         On-link      192.168.56.1    291
     192.168.91.0    255.255.255.0         On-link      192.168.91.1    291
     192.168.91.1  255.255.255.255         On-link      192.168.91.1    291
   192.168.91.255  255.255.255.255         On-link      192.168.91.1    291
        224.0.0.0        240.0.0.0         On-link         127.0.0.1    331
        224.0.0.0        240.0.0.0         On-link      192.168.56.1    291
        224.0.0.0        240.0.0.0         On-link      192.168.91.1    291
        224.0.0.0        240.0.0.0         On-link     169.254.24.54    281
        224.0.0.0        240.0.0.0         On-link     10.170.109.10    291
  255.255.255.255  255.255.255.255         On-link         127.0.0.1    331
  255.255.255.255  255.255.255.255         On-link      192.168.56.1    291
  255.255.255.255  255.255.255.255         On-link      192.168.91.1    291
  255.255.255.255  255.255.255.255         On-link     169.254.24.54    281
  255.255.255.255  255.255.255.255         On-link     10.170.109.10    291
===========================================================================
Persistent Routes:
  None</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>IP forwarding is performed on a <strong><em>hop-by-hop</em></strong> basis.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The routers and hosts do not contain the complete forwarding path to any destination.</p>
</li>
<li>
<p>IP forwarding provides the IP address of only the next-hop entity to which the datagram is sent.</p>
</li>
<li>
<p>It is assumed that the next hop is really <em>closer</em> to the destination than the forwarding system is, and that the next-hop router is directly connected to (i.e., shares a common network prefix with) the forwarding system.</p>
</li>
<li>
<p>It is also generally assumed that no <em>loops</em> are constructed between the next hops so that a datagram does not circulate around the network until its <em>TTL</em> or <em>hop limit</em> expires.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="ip-forwarding-actions">2.2. IP Forwarding Actions</h3>
<div class="paragraph">
<p>When the IP layer in a host or router needs to send an IP datagram to a next-hop router or host, it first examines the destination IP address (<em>D</em>) in the datagram.</p>
</div>
<div class="paragraph">
<p>Using the value <em>D</em>, the following <strong><em>longest prefix match algorithm</em></strong> is executed on the forwarding table:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Search the table for all entries for which the following property holds: (<em>D ^ m<sub>j</sub></em>) = <em>d<sub>j</sub></em>,</p>
<div class="paragraph">
<p>where <em>m<sub>j</sub></em> is the value of the mask field associated with the forwarding entry <em>e<sub>j</sub></em> having index <em>j</em>,</p>
</div>
<div class="paragraph">
<p>and <em>d<sub>j</sub></em> is the value of the destination field associated with <em>e<sub>j</sub></em>.</p>
</div>
<div class="paragraph">
<p>If the destination IP address <em>D</em> is bitwise <em>ANDed</em> with the mask in each forwarding table entry (<em>m<sub>j</sub></em>),</p>
</div>
<div class="paragraph">
<p>and the result is compared against the destination in the same forwarding table entry (<em>d<sub>j</sub></em>),</p>
</div>
<div class="paragraph">
<p>the entry (<em>e<sub>j</sub></em> here) is a match for the destination IP address.</p>
</div>
<div class="paragraph">
<p>When a match happens, the algorithm notes the entry index (<em>j</em> here) and how many bits in the mask <em>m<sub>j</sub></em> were set to <em>1</em>, and the more bits set to <em>1</em>, the better the match.</p>
</div>
</li>
<li>
<p>The best matching entry <em>e<sub>k</sub></em> (i.e., the one with the largest number of <em>1</em> bits in its mask <em>m<sub>k</sub></em>) is selected, and its next-hop field <em>n<sub>k</sub></em> is used as the next-hop IP address in forwarding the datagram.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If no matches in the forwarding table are found, the datagram is undeliverable.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the undeliverable datagram was generated locally (on this host), a <em>host unreachable</em> error is normally returned to the application that generated the datagram.</p>
</li>
<li>
<p>On a router, an <em>ICMP</em> message is normally sent back to the host that sent the datagram.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In some circumstances, more than one entry may match an equal number of <em>1</em> bits.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This can happen, for example, when more than one default route is available (e.g., when attached to more than one ISP, called <em>multihoming</em>).</p>
</li>
<li>
<p>The end-system behavior in such cases is not set by standards and is instead specific to the operating system&#8217;s protocol implementation.</p>
</li>
<li>
<p>A common behavior is for the system to simply choose the first match.</p>
</li>
<li>
<p>More sophisticated systems may attempt to <em>load-balance</em> or <em>split traffic</em> across the multiple routes.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="direct-delivery-and-indirect-delivery">2.3. Direct delivery and indirect delivery</h3>
<div class="paragraph">
<p>Where all systems are using the same network prefix, is called <em>direct delivery</em>, and the other case is called <em>indirect delivery</em>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/internet-protocol/direct-delivery-and-indirect-delivery.png" alt="Direct delivery and indirect delivery" width="55%" height="55%">
</div>
<div class="title">Figure 4. Direct delivery and indirect delivery</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Direct delivery does not require the presence of a router—IP datagrams are encapsulated in a link-layer frame that directly identifies the source and destination.</p>
</li>
<li>
<p>Indirect delivery involves a router—data is forwarded to the router using the router&#8217;s link-layer address as the destination link-layer address.</p>
</li>
<li>
<p>The router&#8217;s IP address does not appear in the IP datagram (unless the router itself is the source or destination, or when source routing is used).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the following table, the destination IPv4 address <em>D</em> (<em>10.0.0.9</em>) matches both the first and second forwarding table entries.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Because it matches the second entry better (<em>25</em> bits instead of none), the <em>gateway</em> or <em>next-hop</em> address is <em>10.0.0.100</em>, the address <em>S</em>.</p>
</li>
<li>
<p>Thus, the gateway portion of the entry contains the address of the sending host&#8217;s own network interface (no router is referenced), indicating that direct delivery is to be used to send the datagram.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all" style="width: 90%;">
<caption class="title">Table 1. The (unicast) IPv4 forwarding table at host <em>S</em> contains only two entries.</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Destination</th>
<th class="tableblock halign-left valign-top">Mask</th>
<th class="tableblock halign-left valign-top">Gateway (Next Hop)</th>
<th class="tableblock halign-left valign-top">Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.100</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">255.255.255.128</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.100</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>Host <em>S</em> is configured with IPv4 address and subnet mask <em>10.0.0.100/25</em>.</p>
</li>
<li>
<p>Datagrams destined for addresses in the range <em>10.0.0.1</em> through <em>10.0.0.126</em> use the second forwarding table entry and are sent using <em>direct delivery</em>.</p>
</li>
<li>
<p>All other datagrams use the first entry and are given to router <em>R</em> with IPv4 address <em>10.0.0.1</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The datagram is encapsulated in a lower-layer frame destined for the target host <em>D</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the lower-layer address of the target host is unknown, the <em>ARP</em> protocol (for IPv4) or <em>Neighbor Solicitation</em> (for IPv6) operation may be invoked at this point to determine the correct lower-layer address, <em>D</em>.</p>
</li>
<li>
<p>Once known, the destination address in the datagram is <em>D</em>'s IPv4 address (10.0.0.9), and <em>D</em> is placed in the Destination IP Address field in the lower-layer header.</p>
</li>
<li>
<p>The switch delivers the frame to <em>D</em> based solely on the link-layer address <em>D</em>; it pays no attention to the IP addresses.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>ip n
<span class="go">172.17.0.2 dev docker0 lladdr 02:42:ac:11:00:02 STALE
192.168.91.254 dev ens32 lladdr 00:50:56:fc:89:96 STALE
192.168.91.1 dev ens32 lladdr 00:50:56:c0:00:08 REACHABLE
192.168.91.2 dev ens34 lladdr 00:50:56:e9:f6:27 STALE
192.168.91.2 dev ens32 lladdr 00:50:56:e9:f6:27 STALE
192.168.91.138 dev ens32  FAILED
fe80::50c2:d6ef:87fb:1b7b dev ens34 lladdr 00:50:56:c0:00:08 STALE

</span><span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>arp <span class="nt">-n</span>
<span class="go">Address                  HWtype  HWaddress           Flags Mask            Iface
172.17.0.2               ether   02:42:ac:11:00:02   C                     docker0
192.168.91.254           ether   00:50:56:fc:89:96   C                     ens32
192.168.91.1             ether   00:50:56:c0:00:08   C                     ens32
192.168.91.2             ether   00:50:56:e9:f6:27   C                     ens34
192.168.91.2             ether   00:50:56:e9:f6:27   C                     ens32
192.168.91.138                   (incomplete)                              ens32</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all" style="width: 90%;">
<caption class="title">Table 2. The (unicast) IPv4 forwarding table at router <em>R1</em> contains only two entries.</caption>
<colgroup>
<col style="width: 22.2222%;">
<col style="width: 22.2222%;">
<col style="width: 22.2222%;">
<col style="width: 22.2222%;">
<col style="width: 11.1112%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Destination</th>
<th class="tableblock halign-left valign-top">Mask</th>
<th class="tableblock halign-left valign-top">Gateway (Next Hop)</th>
<th class="tableblock halign-left valign-top">Interface</th>
<th class="tableblock halign-left valign-top">Note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">70.231.159.254</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">70.231.132.85</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NAT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">255.255.255.128</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0.0.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NAT</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>The forwarding table at <em>R1</em> indicates that address translation should be performed for traffic.</p>
</li>
<li>
<p>The router has a private address on one side (<em>10.0.0.1</em>) and a public address on the other (<em>70.231.132.85</em>).</p>
</li>
<li>
<p>Address translation is used to make datagrams originating on the <em>10.0.0.0/25</em> network appear to the Internet as though they had been sent from <em>70.231.132.85</em>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">node-0:~$</span><span class="w"> </span>ip r
<span class="go">default via 192.168.91.2 dev ens32 onlink
192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128
192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138

</span><span class="gp">node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>ip r del default
<span class="go">
</span><span class="gp">node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>ip r add default via 192.168.91.137 dev ens32
<span class="go">
</span><span class="gp">node-0:~$</span><span class="w"> </span>ip r
<span class="go">default via 192.168.91.137 dev ens32
192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128
192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.138</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">node-1:~$</span><span class="w"> </span>ip r
<span class="go">default via 192.168.91.2 dev ens32
192.168.56.0/24 dev ens36 proto kernel scope link src 192.168.56.128
192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.137
192.168.91.0/24 dev ens34 proto kernel scope link src 192.168.91.131
192.168.91.0/24 dev ens33 proto kernel scope link src 192.168.91.129

</span><span class="gp">node-1:~$</span><span class="w"> </span><span class="nb">sudo </span>sysctl net.ipv4.ip_forward<span class="o">=</span>1
<span class="go">net.ipv4.ip_forward = 1</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">PS C:\&gt;</span><span class="w"> </span>ipconfig
<span class="go">
Wireless LAN adapter Wi-Fi:

   Connection-specific DNS Suffix  . : xxxxxxxxx
   Link-local IPv6 Address . . . . . : fe80::20b2:4f30:ed18:5956%13
   IPv4 Address. . . . . . . . . . . : 10.170.109.10
   Subnet Mask . . . . . . . . . . . : 255.255.254.0
   Default Gateway . . . . . . . . . : 10.170.109.254</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>traceroute <span class="nt">-I</span> 10.170.109.10
<span class="go">traceroute to 10.170.109.10 (10.170.109.10), 30 hops max, 60 byte packets
 1  node-1 (192.168.91.137)  0.256 ms  0.223 ms  0.252 ms
 2  192.168.91.2 (192.168.91.2)  0.269 ms  0.256 ms  0.235 ms
 3  10.170.109.10 (10.170.109.10)  0.727 ms  0.871 ms  1.175 ms</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mobile-ip">3. Mobile IP</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Mobile IP</strong> is based on the idea that a host has a <em>home</em> network but may visit other networks from time to time.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>While at home, ordinary forwarding is performed.</p>
</li>
<li>
<p>When away from home, the host keeps the IP address it would ordinarily use at home, but some special <em>routing</em> and <em>forwarding</em> tricks are used to make the host appear to the network, and to the other systems with which it communicates, as though it is attached to its home network.</p>
<div class="paragraph">
<p>The scheme depends on a special type of router called a <em>home agent</em> that helps provide routing for mobile nodes.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most of the complexity in <strong>MIPv6</strong> involves signaling messages and how they are secured. These messages use various forms of the Mobility extension header (Next Header field value <em>135</em>, often just called the <em>mobility header</em>), so Mobile IP is, in effect, a special protocol of its own.</p>
</div>
<div class="sect2">
<h3 id="the-basic-model-for-ip-mobility-bidirectional-tunneling">3.1. The Basic Model for IP Mobility: Bidirectional Tunneling</h3>
<div class="paragraph">
<p>The following figure shows the entities involved in making <em>MIPv6</em> work. Much of the terminology also applies to <em>MIPv4</em> [RFC5944].</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A host that might move is called a <em>mobile node</em> (MN), and the hosts with which it is communicating are called <em>correspondent nodes</em> (CNs).</p>
</li>
<li>
<p>The MN is given an IP address chosen from the network prefix used in its <em>home network</em>. This address is known as its <em>home address</em> (HoA).</p>
<div class="paragraph">
<p>When it travels to a <em>visited network</em>, it is given an additional address, called its <em>care-of-address</em> (CoA).</p>
</div>
</li>
<li>
<p>In the basic model, whenever a CN communicates with an MN, the traffic is routed through the MN&#8217;s <em>home agent</em> (HA).</p>
<div class="paragraph">
<p>HAs are a special type of router deployed in the network infrastructure like other important systems (e.g., routers and Web servers).</p>
</div>
</li>
<li>
<p>The association between an MN&#8217;s HoA and its CoA is called a <em>binding</em> for the MN.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/internet-protocol/mobile-ip-model.png" alt="Basic MIPV6 Model" width="55%" height="55%">
</div>
<div class="title">Figure 5. Mobile IP supports the ability of nodes to change their point of network attachment and keep network connections operating. The mobile node’s home agent helps to forward traffic for mobiles it serves and also plays a role in route optimization, which can substantially improve routing performance by allowing mobile and correspondent nodes to communicate directly.</div>
</div>
<div class="paragraph">
<p>The basic model works in cases where an MN&#8217;s CNs do not engage in the MIPv6 protocol. This model is also used for network mobility (called <em>NEMO</em> [RFC3963]), when an entire network is mobile.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the MN (or mobile network router) attaches to a new point in the network, it receives its CoA and sends a <em>binding update</em> message to its HA. The HA responds with a <em>binding acknowledgment</em>.</p>
</li>
<li>
<p>Assuming that all goes well, traffic between the MN and CNs is thereafter routed through the MN&#8217;s HA using a two-way form of IPv6 packet tunneling[RFC2473] called <em>bidirectional tunneling</em>.</p>
<div class="paragraph">
<p>These messages are ordinarily protected using <em>IPsec</em> with the <em>Encapsulating Security Payload</em> (ESP).</p>
</div>
<div class="paragraph">
<p>Doing so ensures that an HA is not fooled into accepting a binding update from a fake MN.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="host-processing-of-ip-datagrams">4. Host Processing of IP Datagrams</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although routers do not ordinarily have to consider which IP addresses to place in the <em>Source IP Address</em> and <em>Destination IP Address</em> fields of the packets they forward, hosts must consider both.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Applications such as Web browsers may attempt to make connections to a named host or server that can have multiple addresses.</p>
</li>
<li>
<p>The client system making such connections may also have multiple addresses.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="host-models">4.1. Host Models</h3>
<div class="paragraph">
<p>Although it may appear to be a straightforward decision to determine whether a received unicast datagram matches one of a host&#8217;s IP addresses and should be processed, this decision depends on the <em>host model</em> of the receiving system [RFC1122] and is most relevant for multihomed hosts.</p>
</div>
<div class="paragraph">
<p>There are two host models, the <strong>strong host model</strong> and the <strong>weak host model</strong>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the <em>strong host model</em>, a datagram is accepted for delivery to the local protocol stack only if the IP address contained in the <em>Destination IP Address</em> field matches one of those configured on the interface upon which the datagram arrived.</p>
</li>
<li>
<p>In systems implementing the <em>weak host model</em>, the opposite is true—a datagram carrying a destination address matching any of the local addresses may arrive on any interface and is processed by the receiving protocol stack, irrespective of the network interface upon which it arrived.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Host models also apply to sending behavior. That is, a host using the strong host model sends datagrams from a particular interface only if one of the interface&#8217;s configured addresses matches the <em>Source IP Address</em> field in the datagram being sent.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/internet-protocol/host-model.png" alt="Host Model" width="45%" height="45%">
</div>
<div class="title">Figure 6. Hosts may be connected by more than one interface. In such cases, they must decide which addresses to use for the <em>Source IP Address</em> and <em>Destination IP Address</em> fields of the packets they exchange. The addresses used result from a combination of each host&#8217;s forwarding table, application of an address selection algorithm [RFC 3484], and whether hosts are operating using a <em>weak</em> or <em>strong host model</em>.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>In this example, two hosts (A and B) are connected through the global Internet but also through a local network.</p>
</li>
<li>
<p>If host A is set up to conform to the <em>strong host model</em>, packets it receives destined for <em>203.0.113.1</em> from the Internet or destined for <em>192.0.2.1</em> from the local network are dropped.</p>
</li>
<li>
<p>This situation can arise, for example, if host B is configured to obey the <em>weak host model</em>.</p>
<div class="ulist">
<ul>
<li>
<p>It may choose to send packets to <em>192.0.2.1</em> using the local network (e.g., because doing so may be cheaper or faster).</p>
</li>
<li>
<p>This situation seems unfortunate, as A receives what appear to be perfectly legitimate packets, yet drops them merely because it is operating according to the strong host model.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The host model, for both sending and receiving behavior, can be configured in some operating systems.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In Windows (Vista and later), strong host behavior is the default for sending and receiving for IPv4 and IPv6.</p>
</li>
<li>
<p>In Linux, the IP behavior defaults to the weak host model.</p>
</li>
<li>
<p>BSD (including Mac OS X) uses the strong hostmodel.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In Windows, the following commands can be used to configure weak host receive and send behavior, respectively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bat"><span class="kd">C</span>:\&gt; <span class="nb">netsh</span> <span class="kd">interface</span> <span class="kd">ipvX</span> <span class="kd">set</span> <span class="kd">interface</span> <span class="o">&lt;</span><span class="kd">ifname</span><span class="o">&gt;</span> <span class="kd">weakhostreceive</span><span class="o">=</span><span class="kd">Yabled</span>
<span class="kd">C</span>:\&gt; <span class="nb">netsh</span> <span class="kd">interface</span> <span class="kd">ipvX</span> <span class="kd">set</span> <span class="kd">interface</span> <span class="o">&lt;</span><span class="kd">ifname</span><span class="o">&gt;</span> <span class="kd">weakhostsend</span><span class="o">=</span><span class="kd">Yabled</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For these commands, <em>&lt;ifname&gt;</em> is replaced with the appropriate interface name; <em>X</em> is replaced with either 4 or 6, depending on which version of IP is being configured; and <em>Y</em> is replaced with either <em>en</em> or <em>dis</em>, depending on whether weak behavior is to be enabled or disabled, respectively.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">netsh interface ipv4&gt;</span>show interfaces
<span class="go">
Idx     Met         MTU          State                Name
---  ----------  ----------  ------------  ---------------------------
  1          75  4294967295  connected     Loopback Pseudo-Interface 1
 13          35        1500  connected     Wi-Fi
 10           5        1500  disconnected  Ethernet

</span><span class="gp">netsh interface ipv4&gt;</span>show interfaces <span class="nv">interface</span><span class="o">=</span><span class="s2">"Wi-Fi"</span>
<span class="go">
Interface Wi-Fi Parameters
----------------------------------------------
Weak Host Sends                    : disabled
Weak Host Receives                 : disabled</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="tcp_ip_vol_1"></a>[1] Kevin Fall, W. Stevens <em>TCP/IP Illustrated: The Protocols, Volume 1</em>. 2nd edition, Addison-Wesley Professional, 2011</p>
</li>
</ul>
</div>
</div>
</div>
  </div>

  <ul class="post-navigation">
    <li>
      
      <a href="/2022/11/17/tcp-ip-link-layer/">&laquo; TCP/IP: Link Layer</a>
      
    </li>
    <li>
      
      <a href="/2022/11/24/oracle-database-architecture/">Oracle Database Architecture &raquo;</a>
      
    </li>
  </ul>
</article>

      </div>
    </div>

    <footer class="site-footer">
  <div class="license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details open>
    <summary>Extral Links</summary>
    <div>
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>


<!-- https://github.com/bryanbraun/anchorjs -->
<script src="/js/anchor.min.js"></script>
<script>
  anchors.add();
  anchors.remove(".site-title");
</script>




  </body>

</html>
