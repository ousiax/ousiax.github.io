<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bing WebMaster -->
  <meta name="msvalidate.01" content="AB2FFF876C37F59D9121882CC8395DE5" />

  <title>Golang Learning Notes</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://blog.codefarm.me/2020/04/07/golang-learning-notes/">
  <link rel="alternate" type="application/rss+xml" title="CODE FARM" href="https://blog.codefarm.me/feed.xml">

  <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->
<script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>

  
<!-- Google Analytics Website tracking -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-83971182-1', 'auto');
  ga('send', 'pageview');

</script>


  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SN88FJ18E5');
</script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">
    <h2 class="site-title">
      <a class="site-title" href="/">CODE FARM</a>
    </h2>

     <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
        <div class="trigger">
            <ul>
                <li><a href="/">home</a>
                <li><a href="/category">category</a>
                <li><a href="/tag">tag</a>
                <li><a href="/archive">archive</a>
                <li><a href="/about">about</a>
                <li><a href="https://resume.github.io/?qqbuby" target="_blank">R&eacute;sum&eacute;</a>
            </ul>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Golang Learning Notes</h1>
    
    
    <p class="post-meta"><time datetime="2020-04-07T09:24:39+08:00" itemprop="datePublished">Jun 13, 2022</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#foramtting">Foramtting</a></li>
<li><a href="#commentary">Commentary</a></li>
<li><a href="#names">Names</a>
<ul class="sectlevel2">
<li><a href="#package-names">Package names</a></li>
<li><a href="#getters">Getters</a></li>
<li><a href="#interface-names">Interface names</a></li>
<li><a href="#mixedcaps">MixedCaps</a></li>
</ul>
</li>
<li><a href="#semicolons">Semicolons</a></li>
<li><a href="#control-structures">Control structures</a>
<ul class="sectlevel2">
<li><a href="#if">If</a></li>
<li><a href="#for">For</a></li>
<li><a href="#switch">Switch</a>
<ul class="sectlevel3">
<li><a href="#type-switch">Type switch</a></li>
</ul>
</li>
<li><a href="#select">Select</a></li>
<li><a href="#break-continue-and-goto">Break, Continue and Goto</a></li>
<li><a href="#fallthrough">Fallthrough</a></li>
<li><a href="#defer">Defer</a></li>
</ul>
</li>
<li><a href="#functions">Functions</a>
<ul class="sectlevel2">
<li><a href="#multiple-return-values">Multiple return values</a></li>
<li><a href="#named-result-parameters">Named result parameters</a></li>
<li><a href="#defer-2">Defer</a></li>
</ul>
</li>
<li><a href="#data-types">Data types</a>
<ul class="sectlevel2">
<li><a href="#strings-bytes-runes-and-characters">Strings, bytes, runes and characters</a></li>
<li><a href="#pointers">Pointers</a></li>
<li><a href="#structs">Structs</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#slices">Slices</a></li>
<li><a href="#maps">Maps</a></li>
<li><a href="#functions-2">Functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#interfaces">Interfaces</a></li>
<li><a href="#embedding-interfaces-and-structs">Embedding: interfaces and structs</a></li>
<li><a href="#channels">Channels</a></li>
<li><a href="#type-conversions">Type conversions</a></li>
<li><a href="#type-parameters-and-generics">Type parameters and Generics</a></li>
</ul>
</li>
<li><a href="#fmt-printf">fmt.Printf</a></li>
<li><a href="#initialization">Initialization</a>
<ul class="sectlevel2">
<li><a href="#constants">Constants</a></li>
<li><a href="#allocation-with-new-and-make">Allocation with <strong>new</strong> and <strong>make</strong></a></li>
<li><a href="#the-init-function">The <strong>init</strong> function</a></li>
<li><a href="#zero-values">Zero values</a></li>
</ul>
</li>
<li><a href="#concurrency">Concurrency</a>
<ul class="sectlevel2">
<li><a href="#race-conditions">Race Conditions</a></li>
<li><a href="#race-detector">Race Detector</a></li>
<li><a href="#happen-before">Happen before</a></li>
<li><a href="#share-by-communicating">Share by communicating</a></li>
<li><a href="#goroutines">Goroutines</a></li>
<li><a href="#channels-2">Channels</a></li>
<li><a href="#parallelization">Parallelization</a></li>
</ul>
</li>
<li><a href="#errors">Errors</a>
<ul class="sectlevel2">
<li><a href="#panic">Panic</a></li>
<li><a href="#recover">Recover</a></li>
</ul>
</li>
<li><a href="#testing">Testing</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<hr>
</div>
</div>
<div class="sect1">
<h2 id="foramtting">Foramtting</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With Go we take an unusual approach and let the machine take care of most formatting issues. The <code>gofmt</code> program (also available as <code>go fmt</code>, which operates at the package level rather than source file level) reads a Go program and emits the source in a standard style of indentation and vertical alignment, retaining and if necessary reformatting comments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="nv">$ </span><span class="nb">cat </span>formatting.go <span class="o">&amp;&amp;</span> gofmt formatting.go</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">package</span> <span class="n">formatting</span>
<span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>

        <span class="n">name</span> <span class="kt">string</span> <span class="c">// name of the object</span>
            <span class="n">value</span> <span class="kt">int</span> <span class="c">// its value</span>
        <span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">package</span> <span class="n">formatting</span>

<span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">name</span>  <span class="kt">string</span> <span class="c">// name of the object</span>
    <span class="n">value</span> <span class="kt">int</span>    <span class="c">// its value</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="commentary">Commentary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Go provides C-style <code>/* */</code> block comments and C&#43;&#43;-style <code>//</code> line comments. Line comments are the norm; block comments appear mostly as package comments, but are useful within an expression or to disable large swaths of code.</p>
</div>
<div class="paragraph">
<p>The program&#8212;&#8203;and web server--<code>godoc</code> processes Go source files to extract documentation about the contents of the package. Comments that appear before top-level declarations, with no intervening newlines, are extracted along with the declaration to serve as explanatory text for the item. The nature and style of these comments determines the quality of the documentation godoc produces.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">/*
Package regexp implements a simple library for regular expressions.

The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/</span>
<span class="k">package</span> <span class="n">regexp</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="nv">$ </span>go doc <span class="nb">builtin </span>new</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">package</span> <span class="n">builtin</span> <span class="c">// import "builtin"</span>

<span class="k">func</span> <span class="nb">new</span><span class="p">(</span><span class="n">Type</span><span class="p">)</span> <span class="o">*</span><span class="n">Type</span>
    <span class="n">The</span> <span class="nb">new</span> <span class="n">built</span><span class="o">-</span><span class="n">in</span> <span class="n">function</span> <span class="n">allocates</span> <span class="n">memory</span><span class="o">.</span> <span class="n">The</span> <span class="n">first</span> <span class="n">argument</span> <span class="n">is</span> <span class="n">a</span> <span class="k">type</span><span class="p">,</span>
    <span class="n">not</span> <span class="n">a</span> <span class="n">value</span><span class="p">,</span> <span class="n">and</span> <span class="n">the</span> <span class="n">value</span> <span class="n">returned</span> <span class="n">is</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">newly</span> <span class="n">allocated</span> <span class="n">zero</span>
    <span class="n">value</span> <span class="n">of</span> <span class="n">that</span> <span class="k">type</span><span class="o">.</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="nv">$ </span>go doc <span class="nb">sync </span>Mutex</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">package</span> <span class="n">sync</span> <span class="c">// import "sync"</span>

<span class="k">type</span> <span class="n">Mutex</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="c">// Has unexported fields.</span>
<span class="p">}</span>
    <span class="n">A</span> <span class="n">Mutex</span> <span class="n">is</span> <span class="n">a</span> <span class="n">mutual</span> <span class="n">exclusion</span> <span class="n">lock</span><span class="o">.</span> <span class="n">The</span> <span class="n">zero</span> <span class="n">value</span> <span class="k">for</span> <span class="n">a</span> <span class="n">Mutex</span> <span class="n">is</span> <span class="n">an</span>
    <span class="n">unlocked</span> <span class="n">mutex</span><span class="o">.</span>

    <span class="n">A</span> <span class="n">Mutex</span> <span class="n">must</span> <span class="n">not</span> <span class="n">be</span> <span class="n">copied</span> <span class="n">after</span> <span class="n">first</span> <span class="n">use</span><span class="o">.</span>

<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">Mutex</span><span class="p">)</span> <span class="n">Lock</span><span class="p">()</span>
<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">Mutex</span><span class="p">)</span> <span class="n">Unlock</span><span class="p">()</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="names">Names</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The visibility of a name outside a package is determined by whether its first character is upper case.</p>
</div>
<div class="sect2">
<h3 id="package-names">Package names</h3>
<div class="ulist">
<ul>
<li>
<p>By convention, packages are given lower case, single-word names; there should be no need for underscores or mixedCaps.</p>
</li>
<li>
<p>Another convention is that the package name is the base name of its source directory; the package in <code>src/encoding/base64</code> is imported as "<code class="code">encoding/base64</code>" but has name <code>base64</code>, not <code>encoding_base64</code> and not <code>encodingBase64</code>.</p>
</li>
<li>
<p>Use the package structure to help you choose good names.</p>
<div class="ulist">
<ul>
<li>
<p>The importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid stutter.</p>
</li>
<li>
<p>For instance, the buffered reader type in the <code>bufio</code> package is called <code>Reader</code>, not <code>BufReader</code>, because users see it as <code>bufio.Reader</code>, which is a clear, concise name.</p>
</li>
<li>
<p>Moreover, because imported entities are always addressed with their package name, <code>bufio.Reader</code> does not conflict with <code>io.Reader</code>.</p>
</li>
<li>
<p>Similarly, the function to make new instances of <code>ring.Ring</code>—which is the definition of a constructor in Go—would normally be called <code>NewRing</code>, but since <code>Ring</code> is the only type exported by the package, and since the package is called <code>ring</code>, it&#8217;s called just <code>New</code>, which clients of the package see as <code>ring.New</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="getters">Getters</h3>
<div class="ulist">
<ul>
<li>
<p>Go doesn&#8217;t provide automatic support for getters and setters.</p>
</li>
<li>
<p>There&#8217;s nothing wrong with providing getters and setters yourself, and it&#8217;s often appropriate to do so, but <strong>it&#8217;s neither idiomatic nor necessary to put <code>Get</code> into the getter&#8217;s name.</strong></p>
</li>
<li>
<p>If you have a field called <code>owner</code> (lower case, unexported), the getter method should be called <code>Owner</code> (upper case, exported), not <code>GetOwner</code>.</p>
</li>
<li>
<p>A setter function, if needed, will likely be called <code>SetOwner</code>.</p>
</li>
<li>
<p>Both names read well in practice:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="n">owner</span> <span class="o">:=</span> <span class="n">obj</span><span class="o">.</span><span class="n">Owner</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">owner</span> <span class="o">!=</span> <span class="n">user</span> <span class="p">{</span>
      <span class="n">obj</span><span class="o">.</span><span class="n">SetOwner</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
  <span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="interface-names">Interface names</h3>
<div class="ulist">
<ul>
<li>
<p>By convention, one-method interfaces are named by the method name plus an <code>-er</code> suffix or similar modification to construct an agent noun: <code>Reader</code>, <code>Writer</code>, <code>Formatter</code>, <code>CloseNotifier</code> etc.</p>
</li>
<li>
<p>There are a number of such names and it&#8217;s productive to honor them and the function names they capture.</p>
</li>
<li>
<p><code>Read</code>, <code>Write</code>, <code>Close</code>, <code>Flush</code>, <code>String</code> and so on have canonical signatures and meanings.</p>
</li>
<li>
<p>To avoid confusion, don&#8217;t give your method one of those names unless it has the same signature and meaning.</p>
</li>
<li>
<p>Conversely, if your type implements a method with the same meaning as a method on a well-known type, give it the same name and signature; call your string-converter method <code>String</code> not <code>ToString</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="mixedcaps">MixedCaps</h3>
<div class="paragraph">
<p>Finally, the convention in Go is to use <code>MixedCaps</code> or <code>mixedCaps</code> rather than underscores to write multiword names.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="semicolons">Semicolons</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Like C, Go&#8217;s formal grammar uses semicolons to terminate statements, but unlike in C, those semicolons do not appear in the source.</p>
<div class="paragraph">
<p><strong>If the newline comes after a token that could end a statement, insert a semicolon.</strong></p>
</div>
</li>
<li>
<p>Idiomatic Go programs have semicolons only in places such as for loop clauses, to separate the initializer, condition, and continuation elements.</p>
</li>
<li>
<p>They are also necessary to separate multiple statements on a line, should you write code that way.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="control-structures">Control structures</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>There is no do or while loop, only a slightly generalized <code>for</code>; <code>switch</code> is more flexible;</p>
</li>
<li>
<p><code>if</code> and <code>switch</code> accept an optional initialization statement like that of <code>for</code>;</p>
</li>
<li>
<p><code>break</code> and <code>continue</code> statements take an optional label to identify what to break or continue;</p>
</li>
<li>
<p>and there are new control structures including a type switch and a multiway communications multiplexer, <code>select</code>.</p>
</li>
<li>
<p>There are no parentheses and the bodies must always be brace-delimited.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="if">If</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">y</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">if</span> <span class="n">f</span><span class="p">,</span> <span class="n">err</span><span class="o">:</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">name</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">err</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="for">For</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Like a C for</span>
<span class="k">for</span> <span class="n">init</span><span class="p">;</span> <span class="n">condition</span><span class="p">;</span> <span class="n">post</span> <span class="p">{</span> <span class="p">}</span>

<span class="c">// Like a C while</span>
<span class="k">for</span> <span class="n">condition</span> <span class="p">{</span> <span class="p">}</span>

<span class="c">// Like a C for(;;)</span>
<span class="k">for</span> <span class="p">{</span> <span class="p">}</span>

<span class="c">// Like a C do-while</span>
<span class="k">for</span> <span class="p">{</span>
    <span class="c">// do something</span>
    <span class="k">if</span> <span class="n">condition</span><span class="p">;</span> <span class="p">{</span>
        <span class="k">break</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you&#8217;re looping over an array, slice, string, or map, or reading from a channel, a <code>range</code> clause can manage the loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="k">map</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c">// If you only need the second item in the range (the value),</span>
<span class="c">// use the blank identifier, an underscore, to discard the first:</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="k">map</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">array</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">channel</span> <span class="p">{</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For strings, the <code>range</code> does more work for you, breaking out individual Unicode code points by parsing the UTF-8. Erroneous encodings consume one byte and produce the replacement rune U+FFFD. (The name (with associated builtin type) <code>rune</code> is Go terminology for a single Unicode code point.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">char</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">"日本</span><span class="se">\x80</span><span class="s">語"</span> <span class="p">{</span> <span class="c">// \x80 is an illegal UTF-8 encoding</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"character %#U starts at byte position %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">char</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">}</span>
<span class="c">// Output:</span>
<span class="c">// character U+65E5 '日' starts at byte position 0</span>
<span class="c">// character U+672C '本' starts at byte position 3</span>
<span class="c">// character U+FFFD '�' starts at byte position 6</span>
<span class="c">// character U+8A9E '語' starts at byte position 7</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Go has no comma operator and <code>++</code> and <code>--</code> are statements not expressions. Thus if you want to run multiple variables in a for you should use parallel assignment (although that precludes &#43;&#43; and --).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Reverse a</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="m">1</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="switch">Switch</h3>
<div class="paragraph">
<p>Go&#8217;s switch is more general than C&#8217;s.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The expressions need not be constants or even integers,</p>
</li>
<li>
<p>the cases are evaluated top to bottom until a match is found,</p>
</li>
<li>
<p>and if the <code>switch</code> has no expression it switches on <code>true</code>.</p>
</li>
<li>
<p>It&#8217;s therefore possible&#8212;&#8203;and idiomatic&#8212;&#8203;to write an <code>if-else-if-else</code> chain as a <code>switch</code>.</p>
</li>
<li>
<p>There is no automatic fall through, but cases can be presented in comma-separated lists.</p>
</li>
<li>
<p>Although they are not nearly as common in Go as some other C-like languages, <code>break</code> statements can be used to terminate a <code>switch</code> early.</p>
</li>
<li>
<p>Sometimes, though, it&#8217;s necessary to break out of a surrounding loop, not the switch, and in Go that can be accomplished by putting a label on the loop and "breaking" to that label.</p>
</li>
<li>
<p>Of course, the <code>continue</code> statement also accepts an optional label but it applies only to loops.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">switch</span> <span class="n">os</span> <span class="o">:=</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GOOS</span><span class="p">;</span> <span class="n">os</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">"darwin"</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"OS X."</span><span class="p">)</span>
<span class="k">case</span> <span class="s">"linux"</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Linux."</span><span class="p">)</span>
<span class="k">default</span><span class="o">:</span>
	<span class="c">// freebsd, openbsd,</span>
	<span class="c">// plan9, windows...</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">os</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">Loop</span><span class="o">:</span>
    <span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">);</span> <span class="n">n</span> <span class="o">+=</span> <span class="n">size</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sizeOne</span><span class="o">:</span>
            <span class="k">if</span> <span class="n">validateOnly</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="n">size</span> <span class="o">=</span> <span class="m">1</span>
            <span class="n">update</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="k">case</span> <span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sizeTwo</span><span class="o">:</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">+</span><span class="m">1</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">errShortInput</span>
                <span class="k">break</span> <span class="n">Loop</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">validateOnly</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="n">size</span> <span class="o">=</span> <span class="m">2</span>
            <span class="n">update</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="m">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">shift</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="type-switch">Type switch</h4>
<div class="paragraph">
<p>A switch can also be used to discover the dynamic type of an interface variable.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Such a <em>type switch</em> uses the syntax of a type assertion with the keyword <code>type</code> inside the parentheses.</p>
</li>
<li>
<p>If the switch declares a variable in the expression, the variable will have the corresponding type in each clause.</p>
</li>
<li>
<p>It&#8217;s also idiomatic to reuse the name in such cases, in effect declaring a new variable with the same name but a different type in each case.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">t</span> <span class="k">interface</span><span class="p">{}</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">functionOfSomeType</span><span class="p">()</span>
<span class="k">switch</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">default</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"unexpected type %T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="c">// %T prints whatever type t has</span>
<span class="k">case</span> <span class="kt">bool</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"boolean %t</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="c">// t has type bool</span>
<span class="k">case</span> <span class="kt">int</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"integer %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="c">// t has type int</span>
<span class="k">case</span> <span class="o">*</span><span class="kt">bool</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"pointer to boolean %t</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c">// t has type *bool</span>
<span class="k">case</span> <span class="o">*</span><span class="kt">int</span><span class="o">:</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"pointer to integer %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c">// t has type *int</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="select">Select</h3>
<div class="paragraph">
<p>The <code>select</code> statement lets a goroutine wait on multiple communication operations.</p>
</div>
<div class="paragraph">
<p>A <code>select</code> blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.</p>
</div>
<div class="paragraph">
<p>The <code>default</code> case in a <code>select</code> is run if no other case is ready.</p>
</div>
<div class="paragraph">
<p>Use a <code>default</code> case to try a send or receive without blocking:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">tick</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Tick</span><span class="p">(</span><span class="m">100</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
	<span class="n">boom</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="m">500</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">tick</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"tick."</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">boom</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"BOOM!"</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"    ."</span><span class="p">)</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">50</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="break-continue-and-goto">Break, Continue and Goto</h3>
<div class="paragraph">
<p>A <code>break</code> statement terminates execution of the <em>innermost</em> <code>for</code>, <code>switch</code>, or <code>select</code> statement within the same function.</p>
</div>
<div class="paragraph">
<p>A <code>continue</code> statement begins the next iteration of the <em>innermost</em> <code>for</code> loop at its post statement within the same function.</p>
</div>
<div class="paragraph">
<p>A <code>goto</code> statement transfers control to the statement with the corresponding <em>label</em> within the same function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">tick</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Tick</span><span class="p">(</span><span class="m">100</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
	<span class="n">boom</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="m">500</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>

<span class="n">RawLoop</span><span class="o">:</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">tick</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"tick."</span><span class="p">)</span>
			<span class="k">continue</span> <span class="n">RawLoop</span> <span class="c">// just for demo, needless</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">boom</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"BOOM!"</span><span class="p">)</span>
			<span class="k">break</span> <span class="n">RawLoop</span>
		<span class="k">default</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">".   ."</span><span class="p">)</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">50</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">RawLoop</span> <span class="c">// just for demo, needless</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fallthrough">Fallthrough</h3>
<div class="paragraph">
<p>A <code>fallthrough</code> statement transfers control to the first statement of the next case clause in an expression <code>switch</code> statement. It may be used only as the final non-empty statement in such a clause.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="m">10</span> <span class="o">&gt;</span> <span class="m">11</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"10 &gt; 11"</span><span class="p">)</span>
	<span class="k">case</span> <span class="m">1</span> <span class="o">&lt;</span> <span class="m">5</span><span class="o">:</span>
		<span class="k">fallthrough</span>
	<span class="k">case</span> <span class="m">1</span> <span class="o">&gt;</span> <span class="m">10</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"1 &gt; 10"</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// 1 &gt; 10</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="defer">Defer</h3>
<div class="paragraph">
<p>A <code>defer</code> statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="functions">Functions</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="multiple-return-values">Multiple return values</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">file</span> <span class="o">*</span><span class="n">File</span><span class="p">)</span> <span class="n">Write</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="named-result-parameters">Named result parameters</h3>
<div class="ulist">
<ul>
<li>
<p>The return or result "parameters" of a Go function can be given names and used as regular variables, just like the incoming parameters.</p>
</li>
<li>
<p>When named, they are initialized to the zero values for their types when the function begins;</p>
</li>
<li>
<p>if the function executes a return statement with no arguments, the current values of the result parameters are used as the returned values.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="defer-2">Defer</h3>
<div class="ulist">
<ul>
<li>
<p>Go&#8217;s <code>defer</code> statement schedules a function call (the <em>deferred</em> function) to be run immediately before the function executing the <code>defer</code> returns.</p>
</li>
<li>
<p>It&#8217;s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="k">func</span> <span class="n">ReadFile</span><span class="p">(</span><span class="n">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
          <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
      <span class="p">}</span>
      <span class="k">defer</span> <span class="n">f</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
      <span class="k">return</span> <span class="n">ReadAll</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
  <span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>The arguments to the deferred function (which include the receiver if the function is a method) are evaluated when the <em>defer</em> executes, not when the <em>call</em> executes.</p>
</li>
<li>
<p>Deferred functions are executed in LIFO order (stacking style).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
  	<span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// Output:</span>
  <span class="c">// 4 3 2 1 0</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="c">// All function values created by this loop "capture"</span>
  <span class="c">// and share the same variable—an addressable storage location,</span>
  <span class="c">// not its value at that particular moment.</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">" "</span><span class="p">)</span>
      <span class="p">}()</span>
  <span class="p">}</span>

  <span class="c">// Output:</span>
  <span class="c">// 5 5 5 5 5</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="c">// declares inner i, intialized to outer i</span>
      <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span>
      <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">" "</span><span class="p">)</span>
      <span class="p">}()</span>
  <span class="p">}</span>

  <span class="c">// Output:</span>
  <span class="c">// 4 3 2 1 0</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="data-types">Data types</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// any is an alias for interface{} and is equivalent to interface{} in all ways.</span>
<span class="n">any</span>

<span class="c">// comparable is an interface that is implemented by all comparable types</span>
<span class="c">// (booleans, numbers, strings, pointers, channels, arrays of comparable types,</span>
<span class="c">// structs whose fields are all comparable types). The comparable interface may</span>
<span class="c">// only be used as a type parameter constraint, not as the type of a variable.</span>
<span class="n">comparable</span>

<span class="kt">bool</span> <span class="c">// true false</span>

<span class="kt">string</span>

<span class="kt">int8</span>  <span class="kt">int16</span>  <span class="kt">int32</span>  <span class="kt">int64</span>
<span class="kt">uint8</span> <span class="kt">uint16</span> <span class="kt">uint32</span> <span class="kt">uint64</span> <span class="kt">uintptr</span>
<span class="kt">int</span> <span class="kt">uint</span> <span class="c">// either 32 or 64 bits</span>

<span class="kt">byte</span> <span class="c">// alias for uint8</span>

<span class="kt">rune</span> <span class="c">// alias for int32</span>
     <span class="c">// represents a Unicode code point</span>

<span class="kt">float32</span> <span class="kt">float64</span>

<span class="kt">complex64</span> <span class="kt">complex128</span>

<span class="c">// more types</span>
<span class="n">pointers</span> <span class="n">structs</span> <span class="n">array</span> <span class="n">slices</span> <span class="n">maps</span> <span class="n">functions</span> <span class="n">interfaces</span> <span class="n">channels</span></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="strings-bytes-runes-and-characters">Strings, bytes, runes and characters</h3>
<div class="ulist">
<ul>
<li>
<p>Go source code is always UTF-8.</p>
</li>
<li>
<p>A string holds arbitrary bytes.</p>
</li>
<li>
<p>A string literal, absent byte-level escapes, always holds valid UTF-8 sequences.</p>
</li>
<li>
<p>Those sequences represent Unicode code points, called runes.</p>
</li>
<li>
<p>No guarantee is made in Go that characters in strings are normalized.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">const</span> <span class="n">nihongo</span> <span class="o">=</span> <span class="s">"日本語"</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">runeValue</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nihongo</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%#U "</span><span class="p">,</span> <span class="n">runeValue</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">()</span>

	<span class="k">for</span> <span class="n">index</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nihongo</span><span class="p">);</span> <span class="n">index</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%x "</span><span class="p">,</span> <span class="n">nihongo</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">()</span>

	<span class="k">for</span> <span class="n">index</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nihongo</span><span class="p">);</span> <span class="n">index</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%q "</span><span class="p">,</span> <span class="n">nihongo</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">()</span>

	<span class="k">for</span> <span class="n">index</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nihongo</span><span class="p">);</span> <span class="n">index</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%+q "</span><span class="p">,</span> <span class="n">nihongo</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// Output:</span>
<span class="c">// U+65E5 '日' U+672C '本' U+8A9E '語'</span>
<span class="c">// e6 97 a5 e6 9c ac e8 aa 9e</span>
<span class="c">// 'æ' '\u0097' '¥' 'æ' '\u009c' '¬' 'è' 'ª' '\u009e'</span>
<span class="c">// '\u00e6' '\u0097' '\u00a5' '\u00e6' '\u009c' '\u00ac' '\u00e8' '\u00aa' '\u009e'</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pointers">Pointers</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// A pointer holds the memory address of a value.</span>
<span class="c">// Unlike C, Go has no pointer arithmetic.</span>

<span class="c">// The type `*T` is a pointer to a `T` value. Its zero value is `nil`.</span>
<span class="k">var</span> <span class="n">p</span> <span class="o">*</span><span class="kt">int</span>

<span class="n">i</span> <span class="o">:=</span> <span class="m">42</span>
<span class="c">// The `&amp;` operator generates a pointer to its operand.</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span>

<span class="c">// The `*` operator ("dereferencing" or "indirecting") denotes the pointer's underlying value.</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="m">21</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="structs">Structs</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// A struct is a collection of fields.</span>
<span class="k">type</span> <span class="n">Vertex</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">var</span> <span class="p">(</span>
    <span class="c">// A struct literal denotes a newly allocated struct value by listing the values of its fields.</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span>  <span class="c">// has type Vertex</span>

    <span class="c">// You can list just a subset of fields by using the Name: syntax.</span>
    <span class="c">// (And the order of named fields is irrelevant.)</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">{</span><span class="n">X</span><span class="o">:</span> <span class="m">1</span><span class="p">}</span>  <span class="c">// Y:0 is implicit</span>
    <span class="n">v3</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">{}</span>      <span class="c">// X:0 and Y:0</span>

    <span class="c">// The special prefix &amp; returns a pointer to the struct value</span>
    <span class="n">p</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">Vertex</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span> <span class="c">// has type *Vertex</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// Struct fields are accessed using a dot.</span>
    <span class="n">p</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="m">1e9</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="arrays">Arrays</h3>
<div class="ulist">
<ul>
<li>
<p>The type <code>[n]T</code> is an array of <code>n</code> values of type <code>T</code>.</p>
</li>
<li>
<p>Arrays are values.</p>
<div class="paragraph">
<p>Assigning one array to another copies all the elements.</p>
</div>
</li>
<li>
<p>In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it.</p>
</li>
<li>
<p>The size of an array is part of its type.</p>
<div class="paragraph">
<p>The types <code>[10]int</code> and <code>[20]int</code> are distinct, so arrays cannot be resized.</p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">a</span> <span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="kt">string</span>
<span class="n">a</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hello"</span>
<span class="n">a</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"World"</span>

<span class="c">// an array literal</span>
<span class="n">primes</span> <span class="o">:=</span> <span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">11</span><span class="p">,</span> <span class="m">13</span><span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="slices">Slices</h3>
<div class="ulist">
<ul>
<li>
<p>A slice, on the other hand, is a dynamically-sized, flexible view into the elements of an array.</p>
</li>
<li>
<p>The type <code>[]T</code> is a slice with elements of type <code>T</code>.</p>
</li>
<li>
<p>A slice is formed by specifying two indices, a low and high bound, separated by a colon:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="c">// This selects a half-open range which includes the first element, but excludes the last one.</span>
  <span class="n">a</span><span class="p">[</span><span class="n">low</span> <span class="o">:</span> <span class="n">high</span><span class="p">]</span></code></pre>
</div>
</div>
</li>
<li>
<p>The following expression creates a slice which includes elements 1 through 3 of a:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="n">a</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="p">]</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Slices are like references to arrays</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A slice does not store any data, it just describes a section of an underlying array.</p>
</li>
<li>
<p>A slice hold references to an underlying array, and if you assign one slice to another, both refer to the same array.</p>
</li>
<li>
<p>Changing the elements of a slice modifies the corresponding elements of its underlying array.</p>
</li>
<li>
<p>Other slices that share the same underlying array will see those changes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Slice literals</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A slice literal is like an array literal without the length.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="p">[]</span><span class="kt">bool</span><span class="p">{</span><span class="no">true</span><span class="p">,</span> <span class="no">true</span><span class="p">,</span> <span class="no">false</span><span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Slice defaults</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>When slicing, you may omit the high or low bounds to use their defaults instead.</p>
</li>
<li>
<p>The default is zero for the low bound and the length of the slice for the high bound.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// For the array</span>
<span class="k">var</span> <span class="n">a</span> <span class="p">[</span><span class="m">10</span><span class="p">]</span><span class="kt">int</span>
<span class="c">// these slice expressions are equivalent:</span>
<span class="n">a</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="m">10</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="o">:</span><span class="m">10</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="o">:</span><span class="p">]</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Slice length and capacity</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A slice has both a <em>length</em> and a <em>capacity</em>.</p>
</li>
<li>
<p>The length of a slice is the number of elements it contains.</p>
</li>
<li>
<p>The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice.</p>
</li>
<li>
<p>The length and capacity of <code>a</code> slice s can be obtained using the expressions <code>len(s)</code> and <code>cap(s)</code>.</p>
</li>
<li>
<p>You can extend a slice&#8217;s length by re-slicing it, provided it has sufficient capacity.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Nil slices</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The zero value of a slice is <code>nil</code>.</p>
</li>
<li>
<p>A <code>nil</code> slice has a length and capacity of 0 and has no underlying array.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Appending to a slice</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is common to append new elements to a slice, and so Go provides a built-in <code>append</code> function.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="k">func</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span> <span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">vs</span> <span class="o">...</span><span class="n">T</span><span class="p">)</span> <span class="p">[]</span><span class="n">T</span></code></pre>
</div>
</div>
</li>
<li>
<p>The resulting value of <code>append</code> is a slice containing all the elements of the original slice plus the provided values.</p>
</li>
<li>
<p>If the backing array of <code>s</code> is too small to fit all the given values a bigger array will be allocated. The returned slice will point to the newly allocated array.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="k">var</span> <span class="n">s</span> <span class="p">[]</span><span class="kt">int</span>

  <span class="c">// append works on nil slices.</span>
  <span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>

  <span class="c">// The slice grows as needed.</span>
  <span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>

  <span class="c">// We can add more than one element at a time.</span>
  <span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="maps">Maps</h3>
<div class="ulist">
<ul>
<li>
<p>Maps are a convenient and powerful built-in data structure that associate values of one type (the key) with values of another type (the element or value).</p>
</li>
<li>
<p>The key can be of any type for which the equality operator is defined, such as integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays.</p>
</li>
<li>
<p>Slices cannot be used as map keys, because equality is not defined on them.</p>
</li>
<li>
<p>Like slices, maps hold references to an underlying data structure.</p>
<div class="paragraph">
<p>If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller.</p>
</div>
</li>
<li>
<p>The zero value of a map is <code>nil</code>.</p>
<div class="paragraph">
<p>A <code>nil</code> map has no keys, nor can keys be added.</p>
</div>
</li>
<li>
<p>Map literals are like struct literals, but the keys are required.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">m</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="c">// &lt;nil&gt;</span>
<span class="n">m</span> <span class="o">=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
    <span class="s">"hello"</span><span class="o">:</span> <span class="m">100</span><span class="p">,</span>
    <span class="s">"world"</span><span class="o">:</span> <span class="m">200</span><span class="p">,</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <code>make</code> function returns a map of the given type with an optional capacity hint as arguments, initialized and ready for use.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// m := make(map[string]int, 100)</span>
<span class="n">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>

<span class="c">// insert or update an element</span>
<span class="n">m</span><span class="p">[</span><span class="s">"Answer"</span><span class="p">]</span> <span class="o">=</span> <span class="m">42</span>

<span class="c">// delete an element:</span>
<span class="c">// The delete function doesn’t return anything, and will do nothing if the specified key doesn’t exist.</span>
<span class="nb">delete</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">"Answer"</span><span class="p">)</span>

<span class="c">// retrieve an element</span>
<span class="c">// If the requested key doesn’t exist, we get the value type’s zero value.</span>
<span class="n">v</span> <span class="o">:=</span> <span class="n">m</span><span class="p">[</span><span class="s">"Answer"</span><span class="p">]</span>

<span class="c">// test that a key is present with a two-value assignment</span>
<span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">m</span><span class="p">[</span><span class="s">"Answer"</span><span class="p">]</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="functions-2">Functions</h3>
<div class="ulist">
<ul>
<li>
<p>Functions are values too.</p>
<div class="paragraph">
<p>They can be passed around just like other values.</p>
</div>
</li>
<li>
<p>Function values may be used as function arguments and return values.</p>
</li>
<li>
<p>Go functions may be closures.</p>
<div class="ulist">
<ul>
<li>
<p>A closure is a function value that references variables from outside its body.</p>
</li>
<li>
<p>The function may access and assign to the referenced variables; in this sense the function is "bound" to the variables.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">adder</span><span class="p">()</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">sum</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span>
		<span class="k">return</span> <span class="n">sum</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">pos</span><span class="p">,</span> <span class="n">neg</span> <span class="o">:=</span> <span class="n">adder</span><span class="p">(),</span> <span class="n">adder</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span>
			<span class="n">pos</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
			<span class="n">neg</span><span class="p">(</span><span class="o">-</span><span class="m">2</span><span class="o">*</span><span class="n">i</span><span class="p">),</span>
		<span class="p">)</span>
	<span class="p">}</span>

	<span class="c">// Output:</span>
	<span class="c">// 0 0</span>
	<span class="c">// 1 -2</span>
	<span class="c">// 3 -6</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="methods">Methods</h3>
<div class="ulist">
<ul>
<li>
<p>Go does not have classes.</p>
<div class="paragraph">
<p>However, you can define methods on any <em>named type</em> (except a pointer or an interface).</p>
</div>
</li>
<li>
<p>A method is a function with a special receiver argument.</p>
<div class="paragraph">
<p>The receiver appears in its own argument list between the <code>func</code> keyword and the method name.</p>
</div>
<div class="paragraph">
<p>You can only declare a method with a receiver whose type is defined in the same package as the method.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Choosing a value or pointer receiver</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>There are two reasons to use a pointer receiver.</p>
<div class="ulist">
<ul>
<li>
<p>The first is so that the method can modify the value that its receiver points to.</p>
</li>
<li>
<p>The second is to avoid copying the value on each method call.</p>
<div class="paragraph">
<p>This can be more efficient if the receiver is a large struct, for example.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both.</p>
</li>
<li>
<p>The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.</p>
<div class="paragraph">
<p>This rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake.</p>
</div>
<div class="paragraph">
<p>There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="k">package</span> <span class="n">bufio</span> <span class="c">// import "bufio"</span>

  <span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">Reader</span><span class="p">)</span> <span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

  <span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">Writer</span><span class="p">)</span> <span class="n">Write</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">nn</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Nil is a valid receiver value</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Just as some functions allow nil pointers as arguments, so do some methods for their receiver, especially if nil is a meaningful zero value of the type, as with maps and slices.</p>
</li>
<li>
<p>When you define a type whose methods allow nil as a receiver value, it&#8217;s worth pointing this out explicitly in its documentation comment.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="interfaces">Interfaces</h3>
<div class="paragraph">
<p>An interface type defines a <em>type set</em>. A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to <em>implement the interface</em>. The value of an uninitialized variable of interface type is <code>nil</code>.</p>
</div>
<div class="paragraph">
<p>An interface type is specified by a list of <em>interface elements</em>. An interface element is either a <em>method</em> or a <em>type element</em>, where a type element is a union of one or more type terms. A <em>type term</em> is either a single type or a single <em>underlying type</em>.</p>
</div>
<div class="paragraph">
<p>Interfaces in Go provide a way to specify the behavior of an object: if something can do <em>this</em>, then it can be used <em>here</em>.</p>
</div>
<div class="paragraph">
<p><strong>Interfaces are implemented implicitly</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A type implements an interface by implementing its methods.</p>
<div class="paragraph">
<p>There is no explicit declaration of intent, no "implements" keyword.</p>
</div>
</li>
<li>
<p>Implicit interfaces decouple the definition of an interface from its implementation, which could then appear in any package without prearrangement.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Interface values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Under the hood, interface values can be thought of as a tuple of a value and a concrete type:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="k">type</span><span class="p">)</span></code></pre>
</div>
</div>
</li>
<li>
<p>An interface value holds a value of a specific underlying concrete type.</p>
</li>
<li>
<p>Calling a method on an interface value executes the method of the same name on its underlying type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Interface values with nil underlying values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the concrete value inside the interface itself is nil, the method will be called with a nil receiver.</p>
</li>
<li>
<p>In some languages this would trigger a null pointer exception, but in Go it is common to write methods that gracefully handle being called with a nil receiver.</p>
</li>
<li>
<p>Note that an interface value that holds a nil concrete value is itself non-nil.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">I</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">M</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">T</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="n">M</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"&lt;nil&gt;"</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">i</span> <span class="n">I</span>
	<span class="k">var</span> <span class="n">t</span> <span class="o">*</span><span class="n">T</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">t</span>
	<span class="n">i</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"(%v, %T)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

	<span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">{}</span>
	<span class="n">i</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"(%v, %T)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

	<span class="c">// Output:</span>
	<span class="c">// &lt;nil&gt;</span>
	<span class="c">// (&lt;nil&gt;, *main.T)</span>
	<span class="c">// (&amp;{}, *main.T)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Nil interface values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A nil interface value holds neither value nor concrete type.</p>
</li>
<li>
<p>Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which concrete method to call.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">i</span> <span class="n">I</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"(%v, %T)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="n">i</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="c">// (&lt;nil&gt;, &lt;nil&gt;)</span>
<span class="c">// panic: runtime error: invalid memory address or nil pointer dereference</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>The empty interface</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The interface type that specifies zero methods is known as the empty interface:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">interface</span><span class="p">{}</span></code></pre>
</div>
</div>
</li>
<li>
<p>An empty interface may hold values of any type. (Every type implements at least zero methods.)</p>
</li>
<li>
<p>Empty interfaces are used by code that handles values of unknown type.</p>
</li>
<li>
<p>For convenience, the predeclared type <code>any</code> is an alias for the empty interface.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>go doc builtin.any
<span class="go">package builtin // import "builtin"

type any = interface{}
    any is an alias for interface{} and is equivalent to interface{} in all
    ways.

func recover() any</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>General interfaces</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>In their most general form, an interface element may also be an arbitrary type term <code>T</code>, or a term of the form <code>~T</code> specifying the underlying type <code>T</code>, or a union of terms <code>t1|t2|…|tn</code>.</p>
</li>
<li>
<p>By construction, an interface&#8217;s type set never contains an interface type.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// An interface representing only the type int.</span>
<span class="k">type</span> <span class="n">I0</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="kt">int</span>
<span class="p">}</span>

<span class="c">// An interface representing all types with underlying type int.</span>
<span class="k">type</span> <span class="n">I1</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">int</span>
<span class="p">}</span>

<span class="c">// An interface representing all types with underlying type int that implement the String method.</span>
<span class="k">type</span> <span class="n">I2</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">int</span>
	<span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c">// An interface representing an empty type set: there is no type that is both an int and a string.</span>
<span class="k">type</span> <span class="n">I3</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="kt">int</span>
	<span class="kt">string</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>In a term of the form <code>~T</code>, the underlying type of <code>T</code> must be itself, and <code>T</code> cannot be an interface.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">MyInt</span> <span class="kt">int</span>

<span class="k">type</span> <span class="n">MyI</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="p">[]</span><span class="kt">byte</span>  <span class="c">// the underlying type of []byte is itself</span>
	<span class="err">~</span><span class="n">MyInt</span>   <span class="c">// illegal: the underlying type of MyInt is not MyInt</span>
	<span class="err">~</span><span class="kt">error</span>   <span class="c">// illegal: error is an interface</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Union elements denote unions of type sets:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// The Float interface represents all floating-point types</span>
<span class="c">// (including any named types whose underlying types are</span>
<span class="c">// either float32 or float64).</span>
<span class="k">type</span> <span class="n">Float</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">float32</span> <span class="o">|</span> <span class="err">~</span><span class="kt">float64</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Generality</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a type exists only to implement an interface and will never have exported methods beyond that interface, there is no need to export the type itself.</p>
</li>
<li>
<p>Exporting just the interface makes it clear the value has no interesting behavior beyond what is described in the interface.</p>
</li>
<li>
<p>It also avoids the need to repeat the documentation on every instance of a common method.</p>
</li>
<li>
<p>In such cases, the constructor should return an interface value rather than the implementing type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Interface conversions and type assertions</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A type assertion provides access to an interface value&#8217;s underlying concrete value.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">t</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This statement asserts that the interface value <code>i</code> holds the concrete type <code>T</code> and assigns the underlying <code>T</code> value to the variable <code>t</code>.</p>
</div>
<div class="paragraph">
<p>If <code>i</code> does not hold a <code>T</code>, the statement will trigger a panic.</p>
</div>
</li>
<li>
<p>To <em>test</em> whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">t</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>i</code> holds a <code>T</code>, then <code>t</code> will be the underlying value and <code>ok</code> will be <code>true</code>.</p>
</div>
<div class="paragraph">
<p>If not, <code>ok</code> will be <code>false</code> and <code>t</code> will be the zero value of type <code>T</code>, and no panic occurs.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Type switches</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The declaration in a type switch has the same syntax as a type assertion <code>i.(T)</code>, but the specific type <code>T</code> is replaced with the keyword <code>type</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">switch</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">T</span><span class="o">:</span>
    <span class="c">// here v has type T</span>
<span class="k">case</span> <span class="n">S</span><span class="o">:</span>
    <span class="c">// here v has type S</span>
<span class="k">default</span><span class="o">:</span>
    <span class="c">// no match; here v has the same type as i</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="embedding-interfaces-and-structs">Embedding: interfaces and structs</h3>
<div class="ulist">
<ul>
<li>
<p>Go does not provide the typical, type-driven notion of subclassing, but it does have the ability to &#8220;borrow&#8221; pieces of an implementation by embedding types within a struct or interface.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="k">package</span> <span class="n">io</span> <span class="c">// import "io"</span>

  <span class="k">type</span> <span class="n">Reader</span> <span class="k">interface</span> <span class="p">{</span>
      <span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">type</span> <span class="n">Writer</span> <span class="k">interface</span> <span class="p">{</span>
      <span class="n">Write</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// ReadWriter is the interface that combines the Reader and Writer interfaces.</span>
  <span class="k">type</span> <span class="n">ReadWriter</span> <span class="k">interface</span> <span class="p">{</span>
      <span class="n">Reader</span>
      <span class="n">Writer</span>
  <span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="k">package</span> <span class="n">bufio</span> <span class="c">// import "bufio"</span>

  <span class="k">type</span> <span class="n">Reader</span> <span class="k">struct</span> <span class="p">{</span>
      <span class="c">// Has unexported fields.</span>
  <span class="p">}</span>

  <span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">Reader</span><span class="p">)</span> <span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

  <span class="k">type</span> <span class="n">Writer</span> <span class="k">struct</span> <span class="p">{</span>
      <span class="c">// Has unexported fields.</span>
  <span class="p">}</span>

  <span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">Writer</span><span class="p">)</span> <span class="n">Write</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">nn</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

  <span class="c">// ReadWriter stores pointers to a Reader and a Writer.</span>
  <span class="c">// It implements io.ReadWriter.</span>
  <span class="k">type</span> <span class="n">ReadWriter</span> <span class="k">struct</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">Reader</span>
      <span class="o">*</span><span class="n">Writer</span>
  <span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>There&#8217;s an important way in which embedding differs from subclassing.</p>
<div class="ulist">
<ul>
<li>
<p>When we embed a type, the methods of that type become methods of the outer type, but when they are invoked the receiver of the method is the inner type, not the outer one.</p>
<div class="paragraph">
<p>For example, when the <code>Read</code> method of a <code>bufio.ReadWriter</code> is invoked, the receiver is the <code>reader</code> field of the <code>ReadWriter</code>, not the <code>ReadWriter</code> itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">Reader</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">Reader</span><span class="p">)</span> <span class="n">Read</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Read"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Writer</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">Writer</span><span class="p">)</span> <span class="n">Write</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Write"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ReadWriter</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="o">*</span><span class="n">Reader</span>
	<span class="o">*</span><span class="n">Writer</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">rw</span> <span class="o">:=</span> <span class="n">ReadWriter</span><span class="p">{}</span>
	<span class="n">rw</span><span class="o">.</span><span class="n">Read</span><span class="p">()</span> <span class="c">// same as rw.Reader.Read()</span>
	<span class="n">rw</span><span class="o">.</span><span class="n">Reader</span><span class="o">.</span><span class="n">Read</span><span class="p">()</span>
	<span class="c">// Output:</span>
	<span class="c">// Read</span>
	<span class="c">// Read</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Embedding types introduces the problem of name conflicts but the rules to resolve them are simple.</p>
<div class="ulist">
<ul>
<li>
<p>First, a field or method <code>X</code> hides any other item <code>X</code> in a more deeply nested part of the type.</p>
</li>
<li>
<p>Second, if the same name appears at the same nesting level, it is usually an error.</p>
<div class="paragraph">
<p>However, if the duplicate name is never mentioned in the program outside the type definition, it is OK.</p>
</div>
<div class="paragraph">
<p>This qualification provides some protection against changes made to types embedded from outside; there is no problem if a field is added that conflicts with another field in another subtype if neither field is ever used.</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="channels">Channels</h3>
<div class="ulist">
<ul>
<li>
<p>Channels are a typed conduit through which you can send and receive values with the channel operator, <code>&lt;-</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">v</span>    <span class="c">// Send v to channel ch.</span>
<span class="n">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span>  <span class="c">// Receive from ch, and assign value to v.</span>

<span class="c">// (The data flows in the direction of the arrow.)</span></code></pre>
</div>
</div>
</li>
<li>
<p>Like maps and slices, channels must be created before use:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// By default, sends and receives block until the other side is ready.</span>
<span class="c">// This allows goroutines to synchronize without explicit locks or condition variables.</span>
<span class="n">blockChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>

<span class="c">// Sends to a buffered channel block only when the buffer is full.</span>
<span class="c">// Receives block when the buffer is empty.</span>
<span class="n">bufChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span></code></pre>
</div>
</div>
</li>
<li>
<p>A sender can <code>close</code> a channel to indicate that no more values will be sent.</p>
<div class="ulist">
<ul>
<li>
<p>After calling close, and after any previously sent values have been received, receive operations will return the zero value for the channel&#8217;s type without blocking.</p>
</li>
<li>
<p>Note that it is only necessary to close a channel if the receiver is looking for a close. Closing the channel is a control signal on the channel indicating that no more data follows.</p>
</li>
<li>
<p>The multi-valued assignment form of the receive operator reports whether a received value was sent before the channel was closed.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// ok is false if there are no more values to receive and the channel is closed.</span>
<span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span></code></pre>
</div>
</div>
</li>
<li>
<p>The loop for <code>v := range c</code> receives values from the channel repeatedly until it is closed.</p>
</li>
<li>
<p>Attempting to close an already-closed channel causes a panic, as does closing a nil channel.</p>
</li>
<li>
<p>Sending to a closed channel causes a run-time panic.</p>
</li>
<li>
<p><strong>Note</strong>: Only the sender should close a channel, never the receiver.</p>
<div class="paragraph">
<p>Sending on a closed channel will cause a panic.</p>
</div>
</li>
<li>
<p><strong>Another note</strong>: Channels aren&#8217;t like files; you don&#8217;t usually need to close them.</p>
<div class="paragraph">
<p>Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a <code>range</code> loop.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>A channel may be constrained only to send or only to receive by assignment or explicit conversion.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="p">(</span>
		<span class="n">_</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>   <span class="c">// bidirectional</span>
		<span class="n">_</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c">// receive-only</span>
		<span class="n">_</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="c">// send-only</span>
	<span class="p">)</span>

	<span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>

	<span class="c">// send-only</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">i</span>
		<span class="p">}</span>
		<span class="nb">close</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
	<span class="p">}(</span><span class="n">ch</span><span class="p">)</span>

	<span class="c">// receive-only</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">ch</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}(</span><span class="n">ch</span><span class="p">)</span>

	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
	<span class="c">// Output:</span>
	<span class="c">// 0</span>
	<span class="c">// 1</span>
	<span class="c">// 2</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="n">ch2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="c">// buffering channel</span>
	<span class="n">quit</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>

	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">ch1</span> <span class="o">&lt;-</span> <span class="m">2</span> <span class="o">*</span> <span class="n">i</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="m">1e3</span><span class="p">))</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">ch</span> <span class="o">&lt;-</span> <span class="m">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="m">1</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="m">1e3</span><span class="p">))</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}(</span><span class="n">ch2</span><span class="p">)</span>

	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="o">&lt;-</span><span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="m">5e3</span><span class="p">)</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
		<span class="n">quit</span> <span class="o">&lt;-</span> <span class="m">0</span>
	<span class="p">}()</span>

	<span class="c">//  The select statement lets a goroutine wait on multiple communication operations.</span>
	<span class="c">//  A select blocks until one of its cases can run, then it executes that case.</span>
	<span class="c">//  It chooses one at random if multiple are ready.</span>
	<span class="n">ch3</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="n">timeout</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="m">500</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>

	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="n">ch3</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="c">// multiplexing: ch1 + ch2 =&gt; ch3</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">ch3</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="n">ch1</span><span class="o">:</span>
			<span class="k">case</span> <span class="n">ch3</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="n">ch2</span><span class="o">:</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="n">timeout</span><span class="o">:</span>
				<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"You're too slow."</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="n">quit</span><span class="o">:</span>
				<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Quit."</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch3</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="type-conversions">Type conversions</h3>
<div class="paragraph">
<p>The expression <code>T(v)</code> converts the value <code>v</code> to the type <code>T</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Some numeric conversions:</span>

<span class="k">var</span> <span class="n">i</span> <span class="kt">int</span> <span class="o">=</span> <span class="m">42</span>
<span class="k">var</span> <span class="n">f</span> <span class="kt">float64</span> <span class="o">=</span> <span class="kt">float64</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="k">var</span> <span class="n">u</span> <span class="kt">uint</span> <span class="o">=</span> <span class="kt">uint</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="c">// Or, put more simply:</span>

<span class="n">i</span> <span class="o">:=</span> <span class="m">42</span>
<span class="n">f</span> <span class="o">:=</span> <span class="kt">float64</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="n">u</span> <span class="o">:=</span> <span class="kt">uint</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="type-parameters-and-generics">Type parameters and Generics</h3>
<div class="paragraph">
<p>Go functions can be written to work on multiple types using type parameters. The type parameters of a function appear between brackets, before the function&#8217;s arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">Index</span><span class="p">[</span><span class="n">T</span> <span class="n">comparable</span><span class="p">](</span><span class="n">s</span> <span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">x</span> <span class="n">T</span><span class="p">)</span> <span class="kt">int</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This declaration means that <code>s</code> is a slice of any type <code>T</code> that fulfills the built-in constraint <code>comparable</code>. <code>x</code> is also a value of the same type.</p>
</div>
<div class="paragraph">
<p><code>comparable</code> is a useful constraint that makes it possible to use the <code>==</code> and <code>!=</code> operators on values of the type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">si</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">15</span><span class="p">,</span> <span class="o">-</span><span class="m">10</span><span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">Index</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="m">15</span><span class="p">))</span>

	<span class="n">ss</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="s">"baz"</span><span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">Index</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="s">"buz"</span><span class="p">))</span>
<span class="p">}</span>
<span class="c">// Output:</span>
<span class="c">// 2</span>
<span class="c">// -1</span>

<span class="c">// Index returns the index of x in s, or -1 if not found.</span>
<span class="k">func</span> <span class="n">Index</span><span class="p">[</span><span class="n">T</span> <span class="n">comparable</span><span class="p">](</span><span class="n">s</span> <span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">x</span> <span class="n">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
		<span class="c">// v and x are type T, which has the comparable</span>
		<span class="c">// constraint, so we can use == here.</span>
		<span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">v</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to <em>generic functions</em>, Go also supports generic types. A type can be parameterized with a type parameter, which could be useful for implementing <em>generic data structures</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"strings"</span>

	<span class="s">"golang.org/x/exp/constraints"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">ComparableOrdered</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">comparable</span>
	<span class="n">constraints</span><span class="o">.</span><span class="n">Ordered</span>
<span class="p">}</span>

<span class="c">// List represents a singly-linked list that holds</span>
<span class="c">// values of `ComparableOrdered` type.</span>
<span class="k">type</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span> <span class="n">ComparableOrdered</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">next</span> <span class="o">*</span><span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
	<span class="n">val</span>  <span class="n">T</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="nb">append</span><span class="p">(</span><span class="n">vals</span> <span class="o">...</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">val</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tail</span> <span class="o">:=</span> <span class="n">head</span>
		<span class="k">for</span> <span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">next</span>
		<span class="p">}</span>
		<span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]{</span><span class="n">val</span><span class="o">:</span> <span class="n">val</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">vals</span> <span class="p">{</span>
		<span class="n">a</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">max</span><span class="p">()</span> <span class="n">T</span> <span class="p">{</span>
	<span class="n">max</span> <span class="o">:=</span> <span class="n">head</span><span class="o">.</span><span class="n">val</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
	<span class="k">for</span> <span class="n">node</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">max</span> <span class="p">{</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">max</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">b</span> <span class="n">strings</span><span class="o">.</span><span class="n">Builder</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">head</span>
	<span class="k">for</span> <span class="n">node</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="s">"%v"</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span>
		<span class="k">if</span> <span class="n">node</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Fprint</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="s">" -&gt; "</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">String</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">list</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">List</span><span class="p">[</span><span class="kt">int</span><span class="p">]{</span><span class="n">val</span><span class="o">:</span> <span class="m">20</span><span class="p">}</span>
	<span class="n">list</span><span class="o">.</span><span class="nb">append</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">30</span><span class="p">,</span> <span class="m">60</span><span class="p">)</span>
	<span class="n">list</span><span class="o">.</span><span class="nb">append</span><span class="p">(</span><span class="m">40</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"list: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"max: %v"</span><span class="p">,</span> <span class="n">list</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
	<span class="c">// Output:</span>
	<span class="c">// list: 20 -&gt; 60 -&gt; 30 -&gt; 10 -&gt; 40</span>
	<span class="c">// max: 60</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fmt-printf">fmt.Printf</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Package <code>fmt</code> implements formatted I/O with functions analogous to C&#8217;s printf and scanf. The format 'verbs' are derived from C&#8217;s but are simpler.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The Printing <strong>verbs</strong></p>
<div class="listingblock">
<div class="title"><em>General</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%v	the value in a default format
	when printing structs, the plus flag (%+v) adds field names
%#v	a Go-syntax representation of the value
%T	a Go-syntax representation of the type of the value
%%	a literal percent sign; consumes no value</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>Boolean</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%t	the word true or false</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>Integer</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%b	base 2
%c	the character represented by the corresponding Unicode code point
%d	base 10
%o	base 8
%O	base 8 with 0o prefix
%q	a single-quoted character literal safely escaped with Go syntax.
%x	base 16, with lower-case letters for a-f
%X	base 16, with upper-case letters for A-F
%U	Unicode format: U+1234; same as "U+%04X"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>Floating-point and complex constituents</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%b	decimalless scientific notation with exponent a power of two,
	in the manner of strconv.FormatFloat with the 'b' format,
	e.g. -123456p-78
%e	scientific notation, e.g. -1.234456e+78
%E	scientific notation, e.g. -1.234456E+78
%f	decimal point but no exponent, e.g. 123.456
%F	synonym for %f
%g	%e for large exponents, %f otherwise. Precision is discussed below.
%G	%E for large exponents, %F otherwise
%x	hexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20
%X	upper-case hexadecimal notation, e.g. -0X1.23ABCP+20</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>String and slice of bytes (treated equivalently with these verbs)</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%s	the uninterpreted bytes of the string or slice
%q	a double-quoted string safely escaped with Go syntax
%x	base 16, lower-case, two characters per byte
%X	base 16, upper-case, two characters per byte</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>Slice</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%p	address of 0th element in base 16 notation, with leading 0x</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>Pointer</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%p	base 16 notation, with leading 0x
The %b, %d, %o, %x and %X verbs also work with pointers,
formatting the value exactly as if it were an integer.</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>The default format for %v is</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">bool:                    %t
int, int8 etc.:          %d
uint, uint8 etc.:        %d, %#x if printed with %#v
float32, complex64, etc: %g
string:                  %s
chan:                    %p
pointer:                 %p</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>For compound objects, the elements are printed using these rules, recursively, laid out like this</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">struct:             {field0 field1 ...}
array, slice:       [elem0 elem1 ...]
maps:               map[key1:value1 key2:value2 ...]
pointer to above:   &amp;{}, &amp;[], &amp;map[]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><em>Other flags</em>:</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">'+'	always print a sign for numeric values;
	guarantee ASCII-only output for %q (%+q)
'-'	pad with spaces on the right rather than the left (left-justify the field)
'#'	alternate format: add leading 0b for binary (%#b), 0 for octal (%#o),
	0x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p);
	for %q, print a raw (backquoted) string if strconv.CanBackquote
	returns true;
	always print a decimal point for %e, %E, %f, %F, %g and %G;
	do not remove trailing zeros for %g and %G;
	write e.g. U+0078 'x' if the character is printable for %U (%#U).
' '	(space) leave a space for elided sign in numbers (% d);
	put spaces between bytes printing strings or slices in hex (% x, % X)
'0'	pad with leading zeros rather than spaces;
	for numbers, this moves the padding after the sign;
	ignored for strings, byte slices and byte arrays</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Width</strong> and <strong>Precision</strong></p>
<div class="ulist">
<ul>
<li>
<p><strong><em>Width</em></strong> is specified by an optional decimal number immediately preceding the verb.</p>
<div class="paragraph">
<p>If absent, the width is whatever is necessary to represent the value.</p>
</div>
</li>
<li>
<p><strong><em>Precision</em></strong> is specified after the (optional) width by a period followed by a decimal number.</p>
<div class="paragraph">
<p>If no period is present, a default precision is used. A period with no following number specifies a precision of zero.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">%f     default width, default precision
%9f    width 9, default precision
%.2f   default width, precision 2
%9.2f  width 9, precision 2
%9.f   width 9, precision 0</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>type <strong>Stringer</strong></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">Stringer</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Stringer</code> is implemented by any value that has a <code>String</code> method, which defines the "native" format for that value.</p>
</div>
<div class="paragraph">
<p>The <code>String</code> method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as <code>Print</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Animal has a Name and an Age to represent an animal.</span>
<span class="k">type</span> <span class="n">Animal</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span> <span class="kt">string</span>
	<span class="n">Age</span>  <span class="kt">uint</span>
<span class="p">}</span>

<span class="c">// String makes Animal satisfy the Stringer interface.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="n">Animal</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%v (%d)"</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">Age</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">a</span> <span class="o">:=</span> <span class="n">Animal</span><span class="p">{</span>
		<span class="n">Name</span><span class="o">:</span> <span class="s">"Gopher"</span><span class="p">,</span>
		<span class="n">Age</span><span class="o">:</span>  <span class="m">2</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
	<span class="c">// Output:</span>
	<span class="c">// Gopher (2)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="initialization">Initialization</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="constants">Constants</h3>
<div class="ulist">
<ul>
<li>
<p>Constants are declared like variables, but with the <code>const</code> keyword.</p>
</li>
<li>
<p>Constants cannot be declared using the <code>:=</code> syntax.</p>
</li>
<li>
<p>Constants are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans.</p>
</li>
<li>
<p>Because of the compile-time restriction, the expressions that define them must be constant expressions, evaluatable by the compiler.</p>
</li>
<li>
<p>In Go, enumerated constants are created using the <code>iota</code> enumerator.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="n">Weekday</span> <span class="kt">int</span>

<span class="k">const</span> <span class="p">(</span>
    <span class="n">Sunday</span> <span class="n">Weekday</span> <span class="o">=</span> <span class="no">iota</span> <span class="o">+</span> <span class="m">1</span> <span class="c">// iota: 0 ~ Sunday    : 1</span>
    <span class="n">_</span>                         <span class="c">// iota: 1 ~ iota increased</span>
    <span class="c">// comments               // iota: 1 ~ skip: comment</span>
                              <span class="c">// iota: 1 ~ skip: empty line</span>
    <span class="n">Monday</span>                    <span class="c">// iota: 2 ~ Monday    : 3</span>
    <span class="n">Tuesday</span>                   <span class="c">// iota: 3 ~ Monday    : 4</span>
    <span class="n">Wednesday</span>                 <span class="c">// iota: 4 ~ Monday    : 5</span>
    <span class="n">Thursday</span>                  <span class="c">// iota: 5 ~ Monday    : 6</span>
    <span class="n">Friday</span>                    <span class="c">// iota: 6 ~ Monday    : 7</span>
    <span class="n">Saturday</span>                  <span class="c">// iota: 7 ~ Monday    : 8</span>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="txt">iota (noun)
/aɪˈəʊtə/
/aɪˈəʊtə/

1. [singular] (usually used in negative sentences) an extremely small amount
    There is not one iota of truth (= no truth at all) in the story.
    I don't think that would help one iota.
2. the 9th letter of the Greek alphabet (I, ι)

ref: https://www.oxfordlearnersdictionaries.com/us/definition/english/iota</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="allocation-with-new-and-make">Allocation with <strong>new</strong> and <strong>make</strong></h3>
<div class="ulist">
<ul>
<li>
<p>Go has two allocation primitives, the built-in functions <code>new</code> and <code>make</code>.</p>
<div class="paragraph">
<p>They do different things and apply to different types, which can be confusing, but the rules are simple.</p>
</div>
</li>
<li>
<p><code>new</code> is a built-in function that allocates memory, but unlike its namesakes in some other languages it does not initialize the memory, it only zeros it.</p>
<div class="paragraph">
<p>That is, <code>new(T)</code> allocates zeroed storage for a new item of type <code>T</code> and returns its address, a value of type <code>*T</code>.</p>
</div>
<div class="paragraph">
<p>In Go terminology, it returns a pointer to a newly allocated zero value of type <code>T</code>.</p>
</div>
<div class="paragraph">
<p>Since the memory returned by <code>new</code> is zeroed, it&#8217;s helpful to arrange when designing your data structures that the zero value of each type can be used without further initialization.</p>
</div>
<div class="paragraph">
<p>This means a user of the data structure can create one with <code>new</code> and get right to work.</p>
</div>
<div class="paragraph">
<p>For example, the documentation for <code>bytes.Buffer</code> states that "the zero value for Buffer is an empty buffer ready to use."</p>
</div>
</li>
<li>
<p>The built-in function <code>make(T, args)</code> serves a purpose different from <code>new(T)</code>.</p>
<div class="paragraph">
<p>It creates slices, maps, and channels only, and it returns an initialized (not zeroed) value of type <code>T</code> (not <code>*T</code>).</p>
</div>
<div class="paragraph">
<p>The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">var</span> <span class="n">p</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span> <span class="o">=</span> <span class="nb">new</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>       <span class="c">// allocates slice structure; *p == nil; rarely useful</span>
<span class="k">var</span> <span class="n">v</span>  <span class="p">[]</span><span class="kt">int</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span> <span class="c">// the slice v now refers to a new array of 100 ints</span>

<span class="c">// Unnecessarily complex:</span>
<span class="k">var</span> <span class="n">p</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span> <span class="o">=</span> <span class="nb">new</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span>

<span class="c">// Idiomatic:</span>
<span class="n">v</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="the-init-function">The <strong>init</strong> function</h3>
<div class="ulist">
<ul>
<li>
<p>Each source file can define its own niladic <code>init</code> function to set up whatever state is required.</p>
</li>
<li>
<p>Actually each file can have multiple init functions.</p>
</li>
<li>
<p><code>init</code> is called after all the variable declarations in the package have evaluated their initializers, and those are evaluated only after all the imported packages have been initialized.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">package</span> <span class="n">hello</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s">"hello "</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">package</span> <span class="n">world</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="n">_</span> <span class="s">"hello"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="s">"world"</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="n">_</span> <span class="s">"world"</span>
<span class="p">)</span>

<span class="k">const</span> <span class="n">mark</span> <span class="o">=</span> <span class="s">"!"</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">mark</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// Output:</span>
    <span class="c">// hello world!</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zero-values">Zero values</h3>
<div class="paragraph">
<p>Variables declared without an explicit initial value are given their zero value.</p>
</div>
<div class="paragraph">
<p>The zero value is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>0</code> for numeric types,</p>
</li>
<li>
<p><code>false</code> for the boolean type,</p>
</li>
<li>
<p><code>""</code> (the empty string) for strings,</p>
</li>
<li>
<p><code>nil</code> for the pointers, slices, maps, functions, interfaces, channels,</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concurrency">Concurrency</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="race-conditions">Race Conditions</h3>
<div class="ulist">
<ul>
<li>
<p>A <strong>race condition</strong> is a situation in which the program does not give the correct result for some interleaving of the operations of multiple goroutines.</p>
</li>
<li>
<p>A <strong>data race</strong>, that is, a particular kind of race condition, occurs whenever two goroutines access the same variable concurrently and at least one of the accesses is a write.</p>
<div class="paragraph">
<p>It follows from this definition that there are three ways to avoid a data race.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The first way is not to write the variable.</p>
</li>
<li>
<p>The second way (<em>channels: share memory by communication</em>) to avoid a data race is to avoid accessing the variable from multiple goroutines.</p>
</li>
<li>
<p>The third way (<em>mutual exclusion</em>: <code>sync.Mutex</code>, <code>sync.RWMutex</code>) to avoid a data race is to allow many goroutines to access the variable, but only one at a time.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Synchronization is about more than just the order of execution of multiple goroutines; synchronization also affets memory.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="race-detector">Race Detector</h3>
<div class="ulist">
<ul>
<li>
<p>The race detector (just add the <code>-race</code> flag to your <code>go build</code>, <code>go run</code>, or <code>go test</code> command) studies this steam of events, looking for cases in which one goroutine reads or writes a shared variables that was most recently written by a different goroutine without an intervening synchronization operation.</p>
</li>
<li>
<p>The race detector reports all data races that wre actually executed. However, it can only detect race conditions that occur during a run; it cannot prove that none will ever occur.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>

	<span class="k">var</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kt">int</span>

	<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
		<span class="n">x</span> <span class="o">=</span> <span class="m">1</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"y = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
		<span class="n">y</span> <span class="o">=</span> <span class="m">1</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"x = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="nv">$ </span>go run <span class="nt">-race</span> race.go</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">x = 0</span>
<span class="go">==================</span>
<span class="go">WARNING: DATA RACE</span>
<span class="hll"><span class="go">Write at 0x00c0000a6020 by goroutine 7:</span>
</span><span class="go">  main.main.func1()</span>
<span class="go">      /tmp/race.go:16 +0x8a</span>

<span class="hll"><span class="go">Previous read at 0x00c0000a6020 by goroutine 8:</span>
</span><span class="go">  main.main.func2()</span>
<span class="go">      /tmp/race.go:24 +0xaa</span>

<span class="go">Goroutine 7 (running) created at:</span>
<span class="go">  main.main()</span>
<span class="go">      /tmp/race.go:14 +0x119</span>

<span class="go">Goroutine 8 (finished) created at:</span>
<span class="go">  main.main()</span>
<span class="go">      /tmp/race.go:21 +0x166</span>
<span class="go">==================</span>
<span class="go">==================</span>
<span class="go">WARNING: DATA RACE</span>
<span class="hll"><span class="go">Read at 0x00c0000a6028 by goroutine 7:</span>
</span><span class="go">  main.main.func1()</span>
<span class="go">      /tmp/race.go:17 +0xaa</span>

<span class="hll"><span class="go">Previous write at 0x00c0000a6028 by goroutine 8:</span>
</span><span class="go">  main.main.func2()</span>
<span class="go">      /tmp/race.go:23 +0x8a</span>

<span class="go">Goroutine 7 (running) created at:</span>
<span class="go">  main.main()</span>
<span class="go">      /tmp/race.go:14 +0x119</span>

<span class="go">Goroutine 8 (finished) created at:</span>
<span class="go">  main.main()</span>
<span class="go">      /tmp/race.go:21 +0x166</span>
<span class="go">==================</span>
<span class="go">y = 1</span>
<span class="go">Found 2 data race(s)</span>
<span class="go">exit status 66</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="happen-before">Happen before</h3>
<div class="ulist">
<ul>
<li>
<p>Within a single goroutine, reads and writes must behave as if they executed in the order specified by the program.</p>
</li>
<li>
<p>That is, compilers and processors may reorder the reads and writes executed within a single goroutine only when the reordering does not change the behavior within that goroutine as defined by the language specification.</p>
</li>
<li>
<p>Because of this reordering, the execution order observed by one goroutine may differ from the order perceived by another.</p>
<div class="paragraph">
<p>For example, if one goroutine executes <code>a = 1; b = 2</code>;, another might observe the updated value of <code>b</code> before the updated value of <code>a</code>.</p>
</div>
</li>
<li>
<p>To specify the requirements of reads and writes, we define <strong><em>happens before</em></strong>, a partial order on the execution of memory operations in a Go program.</p>
<div class="paragraph">
<p>If event <em>e1</em> happens before event <em>e2</em>, then we say that <em>e2</em> happens after <em>e1</em>.</p>
</div>
<div class="paragraph">
<p>Also, if <em>e1</em> does not happen before <em>e2</em> and does not happen after <em>e2</em>, then we say that <em>e1</em> and <em>e2</em> <strong><em>happen concurrently</em></strong>.</p>
</div>
</li>
<li>
<p>Within a single goroutine, the happens-before order is the order expressed by the program.</p>
</li>
<li>
<p>Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.</p>
<div class="paragraph">
<p>To serialize access, protect the data with <strong><em>channel operations</em></strong> or other <strong><em>synchronization primitives</em></strong> such as those in the <code>sync</code> and <code>sync/atomic</code> packages.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="share-by-communicating">Share by communicating</h3>
<div class="ulist">
<ul>
<li>
<p><em>Do not communicate by sharing memory; instead, share memory by communicating.</em></p>
<div class="ulist">
<ul>
<li>
<p>Go encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared by separate threads of execution.</p>
</li>
<li>
<p>Only one goroutine has access to the value at any given time. Data races cannot occur, by design.</p>
</li>
</ul>
</div>
</li>
<li>
<p>One way to think about this model is to consider a typical single-threaded program running on one CPU.</p>
<div class="ulist">
<ul>
<li>
<p>It has no need for synchronization primitives.</p>
</li>
<li>
<p>Now run another such instance; it too needs no synchronization.</p>
</li>
<li>
<p>Now let those two communicate; if the communication is the synchronizer, there&#8217;s still no need for other synchronization.</p>
</li>
<li>
<p>Unix pipelines, for example, fit this model perfectly.</p>
</li>
<li>
<p>Although Go&#8217;s approach to concurrency originates in Hoare&#8217;s <em>Communicating Sequential Processes</em> (CSP), it can also be seen as a type-safe generalization of Unix pipes.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="goroutines">Goroutines</h3>
<div class="paragraph">
<p>ref: <a href="https://talks.golang.org/2012/concurrency.slide" class="bare">https://talks.golang.org/2012/concurrency.slide</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space.</p>
<div class="ulist">
<ul>
<li>
<p>It is lightweight, costing little more than the allocation of stack space.</p>
</li>
<li>
<p>And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Goroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I/O, others continue to run.</p>
<div class="ulist">
<ul>
<li>
<p>Their design hides many of the complexities of thread creation and management.</p>
</li>
<li>
<p>Prefix a function or method call with the <code>go</code> keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently.</p>
</li>
<li>
<p>The evaluation of <code>f</code>, <code>x</code>, <code>y</code>, and <code>z</code> of <code>go f(x, y, z)</code> happens in the current goroutine and the execution of <code>f</code> happens in the new goroutine.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// All function values created by this loop “capture”</span>
	<span class="c">// and share the same variable—an addressable storage location,</span>
	<span class="c">// not its value at that particular moment.</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">" "</span><span class="p">)</span>
		<span class="p">}()</span>
	<span class="p">}</span>

	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">()</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">:=</span> <span class="n">i</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">" "</span><span class="p">)</span>
		<span class="p">}()</span>
	<span class="p">}</span>

	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>

	<span class="c">// Output:</span>
	<span class="c">// 5 5 5 5 5</span>
	<span class="c">// 4 0 1 2 3	// ignore the order</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="channels-2">Channels</h3>
<div class="ulist">
<ul>
<li>
<p>Like maps, channels are allocated with <code>make</code>, and the resulting value acts as a reference to an underlying data structure.</p>
<div class="ulist">
<ul>
<li>
<p>If an optional integer parameter is provided, it sets the buffer size for the channel.</p>
</li>
<li>
<p>The default is zero, for an unbuffered or synchronous channel.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="n">ci</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>            <span class="c">// unbuffered channel of integers</span>
<span class="n">cj</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>         <span class="c">// unbuffered channel of integers</span>
<span class="n">cs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span>  <span class="c">// buffered channel of pointers to Files</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Receivers always block until there is data to receive.</p>
</li>
<li>
<p>The sender blocks only until the value has been copied to the buffer;</p>
</li>
<li>
<p>A buffered channel can be used like a semaphore, for instance to limit throughput.</p>
</li>
<li>
<p>The assembly line metaphor (pipeline) is useful one for channels and goroutines.</p>
<div class="listingblock">
<div class="title"><em>ref <a href="http://golang.org/s/prime-sieve" class="bare">http://golang.org/s/prime-sieve</a></em></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// A concurrent prime sieve</span>

<span class="k">package</span> <span class="n">main</span>

<span class="c">// Send the sequence 2, 3, 4, ... to channel 'ch'.</span>
<span class="k">func</span> <span class="n">Generate</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">2</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">i</span> <span class="c">// Send 'i' to channel 'ch'.</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// Copy the values from channel 'in' to channel 'out',</span>
<span class="c">// removing those divisible by 'prime'.</span>
<span class="k">func</span> <span class="n">Filter</span><span class="p">(</span><span class="n">in</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">out</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">,</span> <span class="n">prime</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">in</span> <span class="c">// Receive value from 'in'.</span>
		<span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="n">prime</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">out</span> <span class="o">&lt;-</span> <span class="n">i</span> <span class="c">// Send 'i' to 'out'.</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// The prime sieve: Daisy-chain Filter processes.</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c">// Create a new channel.</span>
	<span class="k">go</span> <span class="n">Generate</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>      <span class="c">// Launch Generate goroutine.</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">prime</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span>
		<span class="nb">print</span><span class="p">(</span><span class="n">prime</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
		<span class="n">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
		<span class="k">go</span> <span class="n">Filter</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ch1</span><span class="p">,</span> <span class="n">prime</span><span class="p">)</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="n">ch1</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="parallelization">Parallelization</h3>
<div class="ulist">
<ul>
<li>
<p>Be sure not to confuse the ideas of concurrency&#8212;&#8203;structuring a program as independently executing components&#8212;&#8203;and parallelism&#8212;&#8203;executing calculations in parallel for efficiency on multiple CPUs.</p>
</li>
<li>
<p>Although the concurrency features of Go can make some problems easy to structure as parallel computations, Go is a concurrent language, not a parallel one, and not all parallelization problems fit Go&#8217;s model.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">package runtime // import "runtime"

func NumCPU() int
    NumCPU returns the number of logical CPUs usable by the current process.

    The set of available CPUs is checked by querying the operating system at
    process startup. Changes to operating system CPU allocation after process
    startup are not reflected.

func GOMAXPROCS(n int) int
    GOMAXPROCS sets the maximum number of CPUs that can be executing
    simultaneously and returns the previous setting. If n &lt; 1, it does not
    change the current setting. The number of logical CPUs on the local machine
    can be queried with NumCPU. This call will go away when the scheduler
    improves.</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="errors">Errors</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Library routines must often return some sort of error indication to the caller.</p>
</li>
<li>
<p>Go&#8217;s multivalue return makes it easy to return a detailed error description alongside the normal return value.</p>
</li>
<li>
<p>It is good style to use this feature to provide detailed error information.</p>
</li>
<li>
<p>By convention, errors have type <code>error</code>, a simple built-in interface.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">type</span> <span class="kt">error</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>The simplest way to create an <code>error</code> is by calling <code>errors.New</code>, which return a new <code>error</code> for a given error message.</p>
</li>
<li>
<p>Calls to <code>errors.New</code> are relatively infrequent because there&#8217;s a conveninent wrapper function, <code>fmt.Errorf</code>, that does string formatting too.</p>
</li>
<li>
<p>When feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error.</p>
<div class="paragraph">
<p>For example, in <code>package image</code>, the string representation for a decoding error due to an unknown format is "image: unknown format".</p>
</div>
</li>
<li>
<p>Callers that care about the precise error details can use a <em>type switch</em> or a <em>type assertion</em> to look for specific errors and extract details.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="panic">Panic</h3>
<div class="ulist">
<ul>
<li>
<p>There is a built-in function <code>panic</code> that in effect creates a runtime unrecoverable error that will stop the program.</p>
</li>
<li>
<p>The function takes a single argument of arbitrary type&#8212;&#8203;often a string&#8212;&#8203;to be printed as the program dies.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">package builtin // import "builtin"

func panic(v interface{})
    The panic built-in function stops normal execution of the current goroutine.
    When a function F calls panic, normal execution of F stops immediately. Any
    functions whose execution was deferred by F are run in the usual way, and
    then F returns to its caller. To the caller G, the invocation of F then
    behaves like a call to panic, terminating G's execution and running any
    deferred functions. This continues until all functions in the executing
    goroutine have stopped, in reverse order. At that point, the program is
    terminated with a non-zero exit code. This termination sequence is called
    panicking and can be controlled by the built-in function recover.</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="recover">Recover</h3>
<div class="ulist">
<ul>
<li>
<p>When <code>panic</code> is called, including implicitly for runtime errors such as indexing a slice out of bounds or failing a type assertion,</p>
<div class="ulist">
<ul>
<li>
<p>it immediately stops execution of the current function</p>
</li>
<li>
<p>and begins unwinding the stack of the goroutine,</p>
</li>
<li>
<p>running any deferred functions along the way.</p>
</li>
<li>
<p>If that unwinding reaches the top of the goroutine&#8217;s stack, the program dies.</p>
</li>
</ul>
</div>
</li>
<li>
<p>However, it is possible to use the built-in function <code>recover</code> to regain control of the goroutine and resume normal execution.</p>
</li>
<li>
<p>A call to <code>recover</code> stops the unwinding and returns the argument passed to panic.</p>
<div class="ulist">
<ul>
<li>
<p>Because the only code that runs while unwinding is inside deferred functions, recover is only useful inside deferred functions.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go">  <span class="k">func</span> <span class="n">F</span><span class="p">()</span> <span class="p">{</span>
  	<span class="nb">panic</span><span class="p">(</span><span class="s">"F: panic."</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">func</span> <span class="n">G</span><span class="p">()</span> <span class="p">{</span>
  	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
  		<span class="n">e</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">()</span>
  		<span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
  			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"G: recover:"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
  		<span class="p">}</span>
  	<span class="p">}()</span>

  	<span class="n">F</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  	<span class="n">G</span><span class="p">()</span>
  	<span class="c">// Output:</span>
  	<span class="c">// G: recover: F: panic.</span>
  <span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing">Testing</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>The <code>go test</code> subcommand is a test driver for Go packages that are organized according to certain conventions.</p>
</li>
<li>
<p>In a package directory, files whose names end with <code>_test.go</code> are not part of the package ordinarily built by <code>go build</code> but are a part of it when built by <code>go test</code>.</p>
</li>
<li>
<p>Within <em>*_test.go</em> files, four kinds of functions are treated specially: <em>tests</em>, <em>fuzzs</em>, <em>benchmarks</em>, and <em>examples</em>.</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>A <strong>test function</strong>, which is a function whose name begins with <strong><em>Test</em></strong>, exercises some program logic for correct behavior; <code>go test</code> calls the test function and report the result, which is either <strong><em>PASS</em></strong> or <strong><em>FAIL</em></strong>.</p>
</li>
<li>
<p>With <strong>fuzzing</strong>, random data is run against your test in an attempt to find vulnerabilities or crash-causing inputs.</p>
</li>
<li>
<p>A <strong>benchmark function</strong> has a name beginning with <strong><em>Benchmark</em></strong> and measures the performance of some operation; <code>go test</code> reports the mean execution time of the operation.</p>
</li>
<li>
<p>And an <strong>example function</strong>, whose name starts with <strong><em>Example</em></strong>, provides machine-checked documentation.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="k">func</span> <span class="n">Foo</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">s</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">TestFoo</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">tests</span> <span class="o">=</span> <span class="p">[]</span><span class="k">struct</span> <span class="p">{</span>
		<span class="n">s</span>    <span class="kt">string</span>
		<span class="n">want</span> <span class="kt">string</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">"Hello"</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">},</span>
		<span class="p">{</span><span class="s">"世界!"</span><span class="p">,</span> <span class="s">"世界!"</span><span class="p">},</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">tests</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">got</span> <span class="o">:=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">s</span><span class="p">);</span> <span class="n">got</span> <span class="o">!=</span> <span class="n">test</span><span class="o">.</span><span class="n">want</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"foo(%q) == %q, want %q"</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">got</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">want</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// Fuzz test</span>
<span class="k">func</span> <span class="n">FuzzFoo</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">F</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// Seed corpus addition</span>
	<span class="n">f</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)</span>
	<span class="c">// Fuzz target</span>
	<span class="n">f</span><span class="o">.</span><span class="n">Fuzz</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="c">// s string // Fuzzing arguments</span>

		<span class="k">if</span> <span class="n">got</span> <span class="o">:=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">got</span> <span class="o">!=</span> <span class="n">s</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"foo(%q) == %q, want %q"</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">got</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">BenchmarkFoo</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span> <span class="p">{</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">ExampleFoo</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"BAR"</span><span class="p">)</span>
	<span class="c">// Output:</span>
	<span class="c">// BAR</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nv">GO111MODULE</span><span class="o">=</span>off go <span class="nb">test</span>
<span class="go">PASS
ok  	_/tmp/learn-notes	0.003s

</span><span class="gp">$</span><span class="w"> </span><span class="nv">GO111MODULE</span><span class="o">=</span>off go <span class="nb">test</span> <span class="nt">-fuzz</span><span class="o">=</span>Fuzz <span class="nt">-fuzztime</span><span class="o">=</span>3s
<span class="go">fuzz: elapsed: 0s, gathering baseline coverage: 0/1 completed
fuzz: elapsed: 0s, gathering baseline coverage: 1/1 completed, now fuzzing with 4 workers
fuzz: elapsed: 3s, execs: 226192 (75387/sec), new interesting: 0 (total: 1)
fuzz: elapsed: 3s, execs: 226192 (0/sec), new interesting: 0 (total: 1)
PASS
ok  	_/tmp/learn-notes	3.127s

</span><span class="gp">$</span><span class="w"> </span><span class="nv">GO111MODULE</span><span class="o">=</span>off go <span class="nb">test</span> <span class="nt">-bench</span><span class="o">=</span>.<span class="k">*</span>
<span class="go">goos: linux
goarch: amd64
cpu: Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz
BenchmarkFoo-4   	1000000000	         0.5349 ns/op
PASS
ok  	_/tmp/learn-notes	0.605s</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="modules">Modules</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// In Go, if an old package and a new package have the same import path,</span>
<span class="c">// the new package must be backwards compatible with the old package.</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// There is certainly a cost to needing to introduce a new name for each backwards-incompatible API change,</span>
<span class="c">// but as the semver FAQ says, that cost should encourage authors to more clearly consider</span>
<span class="c">// the impact of such changes and whether they are truly necessary.</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>A <em>module</em> is a collection of related Go packages that are versioned together as a single unit.</p>
</li>
<li>
<p>Modules record precise dependency requirements and create reproducible builds.</p>
</li>
<li>
<p>Most often, a version control repository contains exactly one module defined in the repository root.</p>
</li>
<li>
<p>Summarizing the relationship between repositories, modules, and packages:</p>
<div class="ulist">
<ul>
<li>
<p>A repository contains one or more Go modules.</p>
</li>
<li>
<p>Each module contains one or more Go packages.</p>
</li>
<li>
<p>Each package consists of one or more Go source files in a single directory.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Modules must be semantically versioned according to <a href="https://semver.org/">semver</a>, usually in the form <code>v(major).(minor).(patch)</code>, such as <code>v0.1.0</code>, <code>v1.2.3</code>, or <code>v1.5.0-rc.1</code>.</p>
<div class="ulist">
<ul>
<li>
<p>The leading <code>v</code> is required.</p>
</li>
<li>
<p>If using Git, tag released commits with their versions.</p>
</li>
</ul>
</div>
</li>
<li>
<p>A module is defined by a tree of Go source files with a <code>go.mod</code> file in the tree&#8217;s root directory.</p>
</li>
<li>
<p>A module declares its identity in its <code>go.mod</code> via the <code>module</code> directive, which provides the <em>module path</em>.</p>
<div class="ulist">
<ul>
<li>
<p>The import paths for all packages in a module share the module path as a common prefix.</p>
</li>
<li>
<p>The module path and the relative path from the <code>go.mod</code> to a package&#8217;s directory together determine a package&#8217;s import path.</p>
</li>
</ul>
</div>
</li>
<li>
<p>In Go source code, packages are imported using the full path including the module path.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="nv">$ </span>go <span class="nb">help </span>modules</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>go <span class="nb">help </span>go.mod</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>go <span class="nb">help </span>module-private</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="nv">$ </span>go <span class="nb">help </span>goproxy</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="nv">$ </span>go <span class="nb">env </span>GOPROXY <span class="c"># https://proxy.golang.org,direct</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="nv">$ </span>go <span class="nb">env</span> <span class="nt">-w</span> <span class="nv">GOPROXY</span><span class="o">=</span>https://goproxy.cn,direct</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="nv">$ </span>go <span class="nb">env </span>GOPROXY <span class="c"># https://goproxy.cn,direct</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="nv">$ </span>go <span class="nb">help </span>gopath</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://github.com/golang/go/wiki/Iota" class="bare">https://github.com/golang/go/wiki/Iota</a></p>
</li>
<li>
<p><a href="https://go.dev/ref/spec#Iota" class="bare">https://go.dev/ref/spec#Iota</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/24790175/when-is-the-init-function-run" class="bare">https://stackoverflow.com/questions/24790175/when-is-the-init-function-run</a></p>
</li>
<li>
<p><a href="https://go.dev/doc/effective_go.html" class="bare">https://go.dev/doc/effective_go.html</a></p>
</li>
<li>
<p><a href="https://go.dev/blog/strings" class="bare">https://go.dev/blog/strings</a></p>
</li>
<li>
<p><a href="https://go.dev/blog/maps" class="bare">https://go.dev/blog/maps</a></p>
</li>
<li>
<p><a href="https://go.dev/tour/generics/1" class="bare">https://go.dev/tour/generics/1</a></p>
</li>
<li>
<p><a href="https://pkg.go.dev/fmt" class="bare">https://pkg.go.dev/fmt</a></p>
</li>
<li>
<p><a href="https://go.dev/ref/mem" class="bare">https://go.dev/ref/mem</a></p>
</li>
<li>
<p><a href="https://talks.golang.org/2012/concurrency.slide" class="bare">https://talks.golang.org/2012/concurrency.slide</a></p>
</li>
<li>
<p><a href="https://groups.google.com/g/golang-nuts/c/pZwdYRGxCIk/m/qpbHxRRPJdUJ" class="bare">https://groups.google.com/g/golang-nuts/c/pZwdYRGxCIk/m/qpbHxRRPJdUJ</a></p>
</li>
<li>
<p><a href="/2017/05/15/capturing-iteration-variables-in-go-language/">Capturing Iteration Variables in Go Language</a></p>
</li>
<li>
<p><a href="/2017/05/15/errors-in-go-language/">Errors in Go language</a></p>
</li>
<li>
<p><a href="/2017/05/21/object-oriented-programming-in-go-language/">Object-oriented Programming in Go Language</a></p>
</li>
<li>
<p><a href="/2017/06/11/goroutines-and-channels-in-go-lanugage/">Goroutines and Channels in Go Lanugage</a></p>
</li>
<li>
<p><a href="/2017/06/17/concurrency-with-shared-variables-in-go-language/">Concurrency with Shared Variables in Go Language</a></p>
</li>
<li>
<p><a href="/2017/07/01/testing-in-go-language/">Testing in Go Language</a></p>
</li>
<li>
<p><a href="https://research.swtch.com/vgo-import" class="bare">https://research.swtch.com/vgo-import</a></p>
</li>
<li>
<p><a href="https://semver.org/" class="bare">https://semver.org/</a></p>
</li>
<li>
<p><a href="https://research.swtch.com/vgo-import" class="bare">https://research.swtch.com/vgo-import</a></p>
</li>
<li>
<p><a href="https://research.swtch.com/vgo-module" class="bare">https://research.swtch.com/vgo-module</a></p>
</li>
<li>
<p><a href="https://research.swtch.com/vgo-mvs" class="bare">https://research.swtch.com/vgo-mvs</a></p>
</li>
<li>
<p><a href="https://github.com/golang/go/wiki/Modules" class="bare">https://github.com/golang/go/wiki/Modules</a></p>
</li>
<li>
<p><a href="https://medium.com/@adiach3nko/package-management-with-go-modules-the-pragmatic-guide-c831b4eaaf31" class="bare">https://medium.com/@adiach3nko/package-management-with-go-modules-the-pragmatic-guide-c831b4eaaf31</a></p>
</li>
<li>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html">Practical Go: Real world advice for writing maintainable Go programs</a></p>
</li>
</ol>
</div>
</div>
</div>
  </div>

  <ul class="post-navigation">
    <li>
      
      <a href="/2020/02/10/kubernetes-crash-course-6/">&laquo; 6 - Kubernetes Monitoring</a>
      
    </li>
    <li>
      
      <a href="/2020/05/07/alex-petrov-database-internals/">Alex Petrov - Database Internals &raquo;</a>
      
    </li>
  </ul>
</article>

      </div>
    </div>

    <footer class="site-footer">
  <div class="license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details open>
    <summary>Extral Links</summary>
    <div>
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>


<!-- https://github.com/bryanbraun/anchorjs -->
<script src="/js/anchor.min.js"></script>
<script>
  anchors.add();
  anchors.remove(".site-title");
</script>




  </body>

</html>
