---
layout: post
title: "代码大全"
date: 2016-11-30 11-49-35 +0800
categories: ['Code Complete',]
tags: ['Code Complete']
disqus_identifier: 16239088205529221542351578235678060431
---
## 第一章 欢迎进入软件创建世界

开发计算机软件是一项非常复杂的工作，在过去的十五年中，研究者们指出了这项工作所包括的主要方面，包括：

- 问题定义
- 需求分析
- 实现规划
- 总体设计
- 详细设计
- 创建即实现
- 系统集成
- 单元测试
- 系统测试
- 校正性的维护
- 功能强化

创建活动主要指编码和调试过程，但也包括详细设计和测试中的某些工作。

创建活动又是被称作“实现”，它有时被叫作“编码和调试”，有时也称之为“编程”。“编码”实在不是一个很好的叫法，因为它隐含着把已经设计好的程序机械地翻译成机器语言的过程；创建则无此含义，它指的是在上述过程中的创造性和决策性活动。

创建活动中所包含的一些特定任务（CODING AND DEBUGGING）：

- 验证基础工作已经完成，可以进行创建工作
- 设计和编写子程序与模块
- 创立数据类型并命名变量
- 选择控制结构并组织语句块
- 找出并修正错误
- 评审其他小组的细节设计和代码，同时接受其它小组评审
- 通过仔细地格式化和征集意见改进编码
- 对分别完成的软件单元进行综合
- 调整编码使其更小、更快

## 第二章 利用隐喻对编程进行更深刻的理解

计算机科学的语言可能是所有科学领域中最丰富的。在这里，你竟会找到病毒、蠕虫、臭虫、炸弹、崩溃、火焰、扭曲的变性者、特洛伊木马和致命错误，在其他领域中，你会遇到这种情况吗？

这些形象的隐喻描述了特定的软件现象。同样形象的隐喻描述了更为广泛的现象，你可以利用它们来加深你对软件开发的理解。

光的波动理论是在与声音类比的基础上产生的。光与声都具有振幅（亮度和音量），频率（颜色和声调）和其他类似性质。这种类比是如此有效，以致于科学家们花费了大量的时间来寻找像空气传播声音一样传播光的物质——“以太”，但他们从来也没有找到。有时如此有效的类比这次却导出了错误结果。

通常，模型的力量在于它能够提供生动形象的概念而易被人整个接受。并提供特性、联系和附加的疑问，有时模型会提出令人困惑的问题，这是往往是由于模型被误解了，那些建筑“以太”的科学家们，就是因为误解了模型。

科学史并不是由一系列从“错误”模型到“正确”模型开关组成的，而是逐渐由“坏的”模型变成为“较好”的模型，从包含面较窄到包含面较宽，从覆盖领域较少到覆盖领域较多。

事实上，许多被较好模型替代的旧模型仍然在发挥作用。例如，工程师仍然在用牛顿力学进行工程计算，虽然它已经被相对论力学所取代。

- **软件书写：写代码（Writing Code）**
   - 《变成风格要素》（《The Elements of Programming Style》）
   - 可读性
   - 《人月神话》（《The Mythical Man Month》）
- **软件播种：生成系统（Growing a System）**
    - 增量技术
- **软件珍珠培植法：系统累积（System Accretion）**
    - 增量开发
- **软件创建：建造软件（building software）**

    “建造”一词的想象比“写”或者“种植’软件的想象更为贴切，它与“增量”软件的想法是基本一致的。建造隐喻暗示了许多诸如计划、准备、执行等工作阶段。如果你仔细研究这个隐喻，你还会发现它还暗示着其它许多东西。
    
    **建造一个四英尺高的塔需要一双稳健的手、 一个平台和十个完好的啤酒罐。 而建造一个四百英尺高的塔却决不仅仅是需要一千个啤酒罐就够了， 它还需要一种完全不同的计划和创建方法。**
    
    如果你想建一个简单的建筑物，比如说一个狗舍，你买来了木板和钉子，到下午的时候，你已经给你的爱犬造好了一幢新房子，假设你忘了修一个门，不过这没关系，你可以补救一下或推倒一节重新开始。你所浪费的不过是一个下午的时间罢了。这与小型软件的发展失败非常类似。如果你有 25 行代码设计错了。那你重新再来一遍好了，你不会因此浪费许多的。
    
    然而如果你是在造一幢房子，那修建的过程就要复杂些了，而拙劣设计的后果也严重得多。首先，你必须决定造一幢什么样的房子，这就像软件开发中的问题定义。然后，你与建筑师必须搞出一个你们都同意的总体方案，这和软件的总体设计是一样的。接着，你又画出细节蓝图并找来一位承包商，这相当于软件中的详细设计。下面的工作是选好房址、打地基、建造起房屋的框架、建好墙壁并加上屋顶、用千斤锤检查墙壁是否垂直，这同软件创建基本差不多。当房屋的绝大部分工作已经完成时，你请来园艺师和装修师，以便使你的房间和空地得到最好的利用，这可以与软件优化相类似。在整个过程中，会有各种监督人员来检查房址、地基、框架、供电系统和其它东西，这也可以与软件开发中的评审和鉴定相类似。
    
    较大的规模和复杂性往往意味着可以产生较大的成果。在修房子的时候，材料可能比较贵，但更大的花费是劳动力。拆掉一面墙并把它移到六英尺之外是很昂贵的，但并不是因为你浪费了许多钉子，而是因为你需要付出劳动。你应该尽可能精心设计，以避免那些本可避免的错误，以降低成本。**在开发软件过程中，材料更便宜，然而劳动力成本却更高。**改变一个报告的格式，可能与移走一幢房子里的墙壁一样昂贵，因为二者成本的主要部分都是劳动力。
    
    这两个活动之间还有什么类似之处呢？在建房子中，你不会去建造那些你可以现成买来的东西，比如洗衣机、烘干机，电冰箱、吸尘器等，除非你是个机械迷。同时，你也会去购买已经做好的地毯、门、窗和浴室用品，而不是自己动手建。如果你正在建造一个软件，你也会这样做。你会推广使用高级语言的特点，而不是去编写操作系统一级的代码。你也会利用已经存在的显示控制和数据库处理系统，利用已经通过的子程序。如果样样都自己动手是很不明智的。
    
    如果你想修建一幢陈设一流的别墅，情况就不同了，你可能定做全套家具，因为希望洗碗机、冰箱等与你的家具协调一致，同时你还会定做别具风格的门和窗户。这种定制化的方式与一流软件开发也是非常类似的。为了这一目的，你可能创建精度更高、速度更快的科学公式。你也会设计自己的显示控制、数据库处理系统和自己的子程序，以使整个软件给人以一气呵成，天衣无缝的感觉。
    
    当然这两种建造方法也要付出代价，工作的每一步都要依据事先制定好的计划进行。如果软件开发工作的顺序有误，那么这个软件将是难以编码、难以测试和难以调试的。这可能会使整个计划延误甚至失败，因为每个人从事的工作都非常复杂，把它们综合到一起后会使人无所适从。
    
    **如果你在盖办公楼时工作做得不好，那么在楼内办公的人便可能面临危险。**同样，如果你在创建医药、航空电子、空中交通管制、加工控制等软件时工作做得不好，后果也可能是灾难性的。**危及别人生命是劣质软件的最可怕后果，但并不是它的唯一危害。**如果公司的股东们因为你编写了错误软件而赔钱，那也是令人遗憾的。无论如何，无辜的人们没有义务为你的工作失误而付出代价。
    
    **对于软件作修改与建造建筑物也有类似之处。如果你要移走的那面墙壁还要支撑其它东西而不仅仅是隔开两个房间，那么你要付出的成本将会更高。**同样，对软件做结构性的修改也将比增加或减少外设特征付出更高昂的代价。
    
    最后，建筑类比对于超大型软件也是同样适用的。一幢超大型建筑物存在错误的后果将是灾难性的，整个工程可能不得不返工。建筑师们在制定和审查计划时是非常仔细的，他们往往留出安全裕度，多用 10％的材料来加强结构总比一幢大楼坍塌要好得多，同时还必须仔细注意工时计划，在修建帝国大厦时，每辆卡车的每次卸货时间都留出了十五分钟的裕度。因为如果有一辆卡车不能在指定时间到达指定的位置，整个计划就有可能被延误。
    
    同样，对于超大型软件来说，计划工作需要比一般的大型软件在更高的层次上进行。1977年，Capers Jones 估计说，对于一个拥有 750，000 行代码的系统来说，可能需要多达 600 页的功能定义文件。对于一个人来说，不要说理解这种规模全部的设计，就是读完它也是非常困难的。安全系数对于这种项目是必须的，制定该系统的工时计划尤为重要。当我们在建造与帝国大厦同等经济规模的软件时，我们也需要同等严密的计划。而我们现在才刚刚开始考虑这种规模项目的计划技术。
    
    这两者之间的相似还可以推广到其它方面，这就是为什么建筑物创建隐喻是如此强有力的原因。许多常用的软件词汇来源于建筑学，如：软件体系结构、搭结构架、构造、分割代码、插入子程序等等。 

- **实用软件技术：智能工具箱（The Intellectual Toolbox）**

    - 如果你拥有的唯一工具就是一把锤子，那么你会把整个世界都当作一个钉子。
    - 一个优秀的工匠知道用什么样的工作干哪一样工作，而且知道该如何使用它们。

隐喻仅仅是启发，而不是公式，因此，它们更倾向于比较随便，无拘无束。

## 第三章 软件创建的先决条件

如果你想做一件精美的首饰，那么就得用钻石作原料。如果你用的是砖头，那你所能得到的最好结果不过是块漂亮的砖头而已。

如果你只在一个计划即将结束时强调质量，那你注重的只是测试。当某些人一谈起软件质量时，他们首先想到的便是测试。然而，事实上测试只是全部质量控制策略的一部分。而且并不是最重要的部分。**测试既不能消除在正确方向上的错误工作，也不能消除在错误方向上的正确工作的错误，这种错误必须在测试开始之前就清除掉，甚至在创建工作开始之前就要努力清除掉它们。**

**一些程序员并不作准备工作，因为他们抵制不了立即进行编码工作的渴望。**

**程序员不重视准备工作的另一个原因是管理人员往往不理解那些在创建先决条件上花费时间的程序员。**

**作为一个工程技术人员，教育你周围的人，让他们懂得技术项目的开发过程，也是你工作的一部分。**

- 求助于逻辑推理

    建造一个系统之前，弄清楚怎么开始和如何建造它也是非常重要的，你当然不希望在完全没有必要的情况下，浪费时间与钱财去钻死胡同而白白增加成本。

- 求助于类比

    程序员处于软件开发食物链的最后一环。结构设计吃掉需求分析；详细设计者以结构设计者为食，而他自己又成为编码者的食物。

比较软件食物链和真正的食物链，我们会发现如下事实，在一个正常的生态系统中，海鸥以沙丁鱼为食，沙丁鱼吃鲜鱼，鲜鱼吃水虱，其结果会形成一个正常的食物链。在编程工作中，如果软件食物链的每一级都可以吃到健康的食物，其结果是由一群快乐的程序员写出的正确代码。

在一个被污染了的环境中，水虱在受到核沾染的水中游泳，鲫鱼体内积聚了滴滴涕，而沙丁鱼生活的水域又遭受了石油污染，那么，不幸的海鸥由于处在食物链的最后一环，因此，它吃的不仅仅是沙丁鱼体内的石油，还有鲜鱼体内的滴滴涕和水虱体内的核废料。在程序设计中,

如果需求定义遭受了污染，那么这又会影响结构设计，而这将最终影响创建活动。这将导致程序员们脾气暴躁而营养不良，同时生产出遭受严重污染而充满缺陷的软件。

### 问题定义

在进行创建工作之前你要满足的第一个先决条件，便是必须弄清楚你想要解决的问题是什么。

**问题定义**只需描述要解决的问题是什么，根本不涉及解决方法。问题定义的工作是在需求分析之前进行，后者是对问题的更为详尽的分析。

### 需求分析

**需求分析** (或需求定义)：需求详细描述了一个软件系统需要解决的问题，这是找到问题答案的第一步。

#### 在创建阶段如何对付需求变化

- 让每个人都知道由于变化需求所付出的代价

    雇员们往往由于自己有了新的设计想法而激动不已。在这种兴奋驱使之下，他们往往会热血沸腾，得意忘形。什么讨论需求的会议，什么签约仪式、什么需求文件，统统都会被他们扔在一边。对付这种人最简单办法就是对他说：“喂，先生，你的想法不错，但是由于它不在需求文件之中，我想先做一个变动后的进度和成本估计，然后我们再决定是立刻就采用这个想法还是以后再说”。“时间进度”和“成本”这两个词往往比咖啡和泼冷水更管用，这样说，往往会把许多“立刻采用”变成“最好采用”。

- 用开发方法来容纳变动

    - **原型化开发**的方法可以帮助你在全力以赴投入工作以前，首先了解系统的需求。
    - **渐进开发**的方法是指按阶段公布系统。每次你只做一点儿，从用户那里得到一些反馈后，你再做一些调整的改动，然后再增加一些内容。这种方法的关键是使用**短周期开发方法**，以便你对顾客的需求变更迅速作出反应。

- 放弃项目

    如果需求特别稀奇古怪或者反复无常，上面那些办法全都不起作用，那就放弃这个项目。

### 结构定义

软件**结构设计**是较高级意义上的软件设计，它是支持详细设计的框架。

#### 典型的结构要素

- 程序的组织形式

    - 模块化
    - 高聚性
    - 松耦合
    - 信息隐蔽

- 变动策略

    - 系统的灵活性

- 错误处理

    错误处理已成为当代计算机科学中最棘手的问题，没有谁能担负起频繁应付它的负担。有人估计，程序中有 90％的代码是为了应付例外的错误处理或者内务处理而编写的，就是说仅有10％的代码才是处理正常情况的。

- 坚固性（Robustness）

    坚固性是指在发现错误后，一个系统继续运行的能力。

    - 裕度设计（over-engineering）
    - 断言（assertions）
    - 容错性（fault tolerance）
    - 性能
- 通用的结构设计质量准则

    一个好的结构设计特征包括：对于系统中的模块的讨论，每个模块的隐含的信息，选用和不选用某个方案的原因。

   关于软件工程的最权威的著作《The Mythical Man-Month》，其中心思想便是认为**概念完整性**是最重要的。一个好的结构设计应满足这一条，当你看到这个结构设计时，应该为其解决方案的自然和简单而折服。而不会有把问题和答案生拼硬凑到一起的感觉。 

    **结构的目标应该清楚地说明。**一个以可变性为首要目标的结构设计可能与一个以性能为首要目标的结构设计差之千里，虽然二者的功能可能是完全一样的。

    **结构中作出每一个决定的动机都要阐明清楚。**要当心“我们过去一直是这么干的”的理由。有这样一个故事，会给我们启迪。Beth 想按照她丈夫的家传方法做一道红烧牛肉。她的丈夫 Abdul 告诉她，要先把牛肉放在盐和调料中腌一下，再剁掉肉的两边，把中间部分放进锅里，盖上盖儿焖一下就可以了。Beth 问：“为什么要剁掉肉的两边？”Abdul 说：“我不知道，我总是这样做的，我们问一下妈妈吧”。便打电话问妈妈、Abdul 的妈妈则说是他的外祖母告诉她的。于是电话打到了 Abdul 的外祖母那儿，她的外祖母奇怪地说：“我也不知道你们为什么那样做，我那样做不过是因为肉块太大，放不进锅里”。

    **好的软件结构往往是机器和语言相互独立。**

    **结构设计应该恰好在过分定义和定义不足的分界线上。**结构中不应该有任何部分受到了它不应该的重视。设计者不能以牺牲某一部分为代价来重视另一部分。

    **结构中不应该有热河和部分让你感到不舒服。**它不应该含有任何仅仅为取悦老板而加上去的部分。

### 编程语言

- 当程序员使用自己所熟悉的语言时，其工作效率要比使用陌生的语言高的多。

- 使用高级语言编程，其效率和质量要比用低级语言高的多。同时高级语言的表达能力比低级语言要高，这样，它的每一行代码就可以表达更多的内容。

- 一些语言比其他语言更擅长解释编程思想。

- 程序员也可能同样受到他所懂得的语言限制。

- 程序语言影响程序员的思想方法。

| 程序类型 | 最好语言 | 最差语言 |
|:-----------------------|:-----------------------|:------------------------|
|结构化数据             |Ada、 C++、 Pascal     |   汇编、Basic
|快速而杂乱的项目       |Basic                  |   Pascal、Ada、汇编
|快速执行               |汇编、C                |   解释性语言如 Basic
|数学计算               |Fortran                |   Pascal
|易于维护的程序         |Pascal 、Ada           |   C 、Fortran
|动态内存使用           |Pascal、C              |   Basic
|在有限内存环境下运行   |Basic、汇编、C         |   Fortran
|实时程序               |Ada、汇编、C           |   Basic 、Fortran
|串操作                 |Basic 、Pascal         |   C

### 编程约定

在复杂的软件中，结构设计指导方针对程序进行结构性平衡，而实现指导方式则在较低层次上实现程序的和谐统一，使得每一个子程序都成为总体设计的一个可以信何一个大的软件系统都需要结构控制，以便把编程语言的细节统一到一起。大型系统的完美之处便是它的每一个细节都体现了它的结构设计风格。如果没有一个统一约束，那么你的软件只能是一个由各个风格不同的子程序拼凑到一起的拼盘而已。

即使你有一个关于一幅画的美妙总体构思，但如果其中一部分是用**古典手法**的，另一部分是**印象派**的，其余则是**超现实主义**风格的，那么，再美妙的构思又有什么用呢？

### 第四章 建立子程序的步骤

`程序设计语言（PDL）` `设计程序` `检查设计` `编写程序` `检查代码`

### 设计子程序

`检查` `定义要解决的问题` `命名程序` `决定如何测试程序` `研究最新算法` `编写详细的 PDL` `考虑效率` `考虑数据` `重新检查 PDL 的数据`

- 给子程序命名

    给子程序命名似乎是小事一桩，但好的子程序名字往往是一个高质量软件的标志之一，而且，命名并不是件容易的事情。

    如果在给程序找出一个好名字时感到困难，这往往意味着对程序的功能还不十分清楚。

    一个模棱两可的名字就像是一个在进行竞选辩论的政治家，似乎他在说着什么，可是当你仔细听时，又分辨不出他的话到底有什么意义。

- 考虑效率

    1. 程序的绝大部分，性能并不是主要的，在这种情况下，应该把子程序作成高度模块化而且具有很强的可读性，以便在今后需要时很容易对其作出改进。

    1. 在大部分程序中，性能都是很重要的，这时，结构设计应该对子程序的运行速度和允许使用的内存作出规定，只要按照速度和空间指标设计子程序就可以了。如果速度和空间只是一方面是主要的，则可以牺牲一方面来满足另一方面的要求。

    1. 优化的效益主要来自高层次设计，而不是个别子程序、只有在高层次设计某方面有缺陷时，才需要进行微观优化，而这点只有在程序全部完成时才会知道。除非必要，不要浪费时间进行增量改进。

- 研究算法和数据结构

    同时提高编码质量和效率的最有效办法是重新使用好的代码。

### 子程序编码

- 检查子程序接口

   确认所有的输入和输出数据都已作出解释，并且使用了所有参数。

- 检查通用设计质量

    确认子程序只完成一项任务而且完成得很好，与其它子程序交叉是控制不严的表现。并且，应该采用了预防错误的设计。

- 检查子程序的数据

    查找出不精确的变量名、没有使用的数据、没有说明的数据等等。

- 检查子程序的控制结构

    查找无限循环、不适当的嵌套等错误。

- 检查子程序设计

    确认已经说明了子程序的表达式、参数表和逻辑结构。

- 检查子程序的文档

    检查算法描述，查找接口假设和非显式依赖的文档资料，查找不清楚的编码等待。

### 检查子程序

业余爱好者与职业程序员之间的最大区别就是迷信还是理解。在这里，“迷信”这个词指并不是指在月圆之夜产生各种错误或使你毛骨悚然的一段程序。它指的是你对代码的感觉代替对代码的理解。如果你总是认为编译程序或者硬件系统有故障，那说明你还处在迷信阶段。只有 5%的错误是由编译程序、硬件或者是操作系统引起的（Brown and sampson, 1973, Ostrand and Weyuher, 1984）。进入理解境界的程序员总是怀疑自己的工作，因为他们知道 95％ 的错误出自这里。**要理解每一行编码的意义，并且要明白为什么需要它。**没有仅仅因为有效便是正确的东西。如果你不知道为什么它是有效的，那么往往它是无效的，只不过你没有发现罢了。

## 第五章 高质量子程序特点

`子程序名称恰当` `强内聚性` `松散耦合性` `子程序长度` `防错性编程` `子程序参数`

**子程序是具有单一功能的可调用的函数或过程。** 比如 C 中的函数，Pascal 或 Ada 中的函数或过程，Basic 中的子程序或 Fortran 中的子程序。有时，C 中的宏指令或 Basic 中用 GOSUB 调用的代码块也可以认为是子程序。

### 生成子程序的原因

- **降低复杂性**
- **避免重复的代码段**
- **限制改动带来的影响**
- **隐含顺序**
- **改进性能**
- **进行集中控制**
- **隐含数据结构**
- **隐含指针操作**
- **隐含全局变量**
- **重新使用代码段**
- **计划开发一个软件族**
- **改善部分代码的可读性**
- **改善可移植性**
- **分隔复杂操作**
- **独立非标准语言函数的使用**
- **简化复杂的布尔测试**
    
