= Distributed Builds on Jenkins
:page-layout: post
:page-categories: [jenkins]
:page-tags: [jenkins]
:page-date: 2024-01-26 15:01:54 +0800
:page-revdate: 2024-01-26 15:01:54 +0800
:toc: 
:toclevels: 4
:sectnums:
:sectnumlevels: 4

[TIP]
====
The _controller_ is a central, coordinating process which stores configuration, loads plugins, and renders the various user interfaces for Jenkins.

An _agent_ is typically a machine, or container, which connects to a Jenkins controller and executes tasks when directed by the controller.

A node is a machine which is part of the Jenkins environment and capable of executing Pipelines or jobs. Both the Controller and Agents are considered to be Nodes.

An _executor_ is a slot for execution of work defined by a Pipeline or job on a Node. A Node may have zero or more Executors configured which corresponds to how many concurrent Jobs or Pipelines are able to execute on that Node.

A _workspace_ is disposable directory on the file system of a Node where work can be done by a Pipeline or job. Workspaces are typically left in place after a Build or Pipeline run completes unless specific Workspace cleanup policies have been put in place on the Jenkins Controller. <<glossary>>
====

== Distributed Builds Architecture

A Jenkins controller can operate by itself both managing the build environment and executing the builds with its own executors and resources. If you stick with this "standalone" configuration you will most likely run out of resources when the number or the load of your projects increase.

An agent, where the workload of building projects are delegated to, is a machine set up to offload projects from the controller. The method with which builds are scheduled depends on the configuration given to each project. For example, some projects may be configured to "restrict where this project is run" which ties the project to a specific agent or set of labeled agents. Other projects which omit this configuration will select an agent from the available pool in Jenkins.

In a distributed builds environment, the Jenkins controller will use its resources to only handle HTTP requests and manage the build environment. Actual execution of builds will be delegated to the agents. With this configuration it is possible to horizontally scale an architecture, which allows a single Jenkins installation to host a large number of projects and build environments. <<architecting-for-scale>>

In order for a machine to be recognized as an agent, it needs to run a specific agent program to establish bi-directional communication with the controller.

There are different ways to establish a connection between controller and agent:

* The *SSH connector*: Configuring an agent to use the SSH connector is the preferred and the most stable way to establish controller-agent communication.

* The *Inbound connector*: In this case the communication is established starting the agent through a connection initiated by an agent program.

* The *Inbound-HTTP connector*: This approach is quite similar to the Inbound-TCP Java Web Start approach, with the difference in this case being that the agent is executed as headless and the connection can be tunneled via HTTP(s).

* *Custom-script*: It is also possible to create a custom script to initialize the communication between controller and agent if the other solutions do not provide enough flexibility for a specific use-case.

== Nodes and Components

Builds in a distributed builds architecture use _nodes_, _agents_, and _executors_, which are distinct from the Jenkins controller itself. Understanding what each of these components are is useful when managing nodes: <<managing-nodes>>

=== Controllers

The Jenkins _controller_ is the Jenkins service itself and where Jenkins is installed. It is also a web server that also acts as a "brain" for deciding how, when, and where to run tasks. Management tasks such as configuration, authorization, and authentication are executed on the controller, which serves HTTP requests. Files written when a Pipeline executes are written to the filesystem on the controller, unless they are off-loaded to an artifact repository such as Nexus or Artifactory.

=== Agents

_Agents_ manage the task execution on behalf of the Jenkins controller by using executors. An agent is a small (170KB single jar) Java client process that connects to a Jenkins controller and is assumed to be unreliable. An agent can use any operating system that supports Java. Any tools required for building and testing get installed on the node where the agent runs. Because these tools are a part of the node, they can be installed directly or in a container, such as Docker or Kubernetes. Each agent is effectively a process with its own Process Identifier (PID) on the host machine. In practice, nodes and agents are essentially the same but it is good to remember that they are conceptually distinct.

=== Nodes

_Nodes_ are the "machines" on which build agents run. Jenkins monitors each attached node for disk space, free temp space, free swap, clock time/sync, and response time. A node is taken offline if any of these values go outside the configured threshold. Jenkins supports two types of nodes:

* *agents* (described above)

* *built-in node*
+
The built-in node is a node that exists within the controller process. It is possible to use agents and the build-in node to run tasks. However, running tasks on the built-in node is discouraged for security, performance, and scalability reasons. The number of executors configured for the node determines the node’s ability to run tasks. _Set the number of executors to 0 to disable running tasks on the built-in node._

=== Executors

An _executor_ is a slot for the execution of tasks. Effectively, it is a thread in the agent. The number of executors on a node defines the number of concurrent tasks that can run. In other words, this determines the number of concurrent Pipeline _stages_ that can execute at the same time. Determine the correct number of executors per build node must be determined based on the resources available on the node and the resources required for the workload. When determining how many executors to run on a node, consider CPU and memory requirements, as well as the amount of I/O and network activity:

* One executor per node is the safest configuration.

 * One executor per CPU core can work well, if the tasks running are small.

* Monitor I/O performance, CPU load, memory usage, and I/O throughput carefully when running multiple executors on a node.

== Installing Jenkins with Docker

Due to Docker’s fundamental platform and container design, a Docker image for a given application, such as Jenkins, can be run on any supported operating system or cloud service also running Docker. <<installing-docker>>

=== Configuring Controller

. Open up a terminal window, and create a directory named _controller_.
+
```sh
mkdir controller
cd controller
```

. Create an environment file named _.env_ and set the project name with _jenkins_.
+
```sh
echo -n COMPOSE_PROJECT_NAME=jenkins > .env
```

. Create a groovy file named `executors.groovy` with the following content.
+
```groovy
import jenkins.model.*
Jenkins.instance.setNumExecutors(0) // Recommended to not run builds on the built-in node
```

. Create a bridge network for the controller.
+
```sh
docker network create -d bridge jenkins-controller
```

. Create a compose file named `compose.yml` with the following content.
+
```yml
version: "2.4"
services:
  controller:
    container_name: jenkins-controller
    build:
      context: .
      dockerfile_inline: |
        ARG JENKINS_TAG=2.426.3-jdk21
        FROM jenkins/jenkins:$${JENKINS_TAG} <1>
        COPY --chown=jenkins:jenkins executors.groovy /usr/share/jenkins/ref/init.groovy.d/executors.groovy <2>
    restart: on-failure
    ports:
      - "8080:8080"
      - "50000:50000" <3>
    volumes:
      - jenkins-home:/var/jenkins_home:rw <4>
    networks:
      jenkins-controller:
volumes:
  jenkins-home:
    name: jenkins-home
networks:
  controller:
    external: true <5>
    name: jenkins-controller
```
+
--
<1> Use the recommended official https://hub.docker.com/r/jenkins/jenkins/[jenkins/jenkins] image from the Docker Hub repository. <<installing-docker>>

<2> Extend the image and change it to your desired number of executors (recommended 0 executors on the built-in node). <<docker-readme-md>>

<3> In order to connect agents through an inbound TCP connection, map the port: `-p 50000:50000`. That port will be used when you connect agents to the controller.
+
If you are only using https://plugins.jenkins.io/ssh-slaves[SSH (outbound) build agents], this port is not required, as connections are established from the controller. If you connect agents using web sockets (since Jenkins 2.217), the TCP agent port is not used either. <<docker-readme-md>>

<4> NOTE: Avoid using a https://docs.docker.com/storage/bind-mounts/[bind mount] from a folder on the host machine into _/var/jenkins_home_, as this might result in file permission issues (the user used inside the container might not have rights to the folder on the host machine). If you _really_ need to bind mount jenkins_home, ensure that the directory on the host is accessible by the jenkins user inside the container (jenkins user - uid 1000) or use `-u some_other_user` parameter with `docker run`. <<docker-readme-md>>

<5> `external` specifies that this network’s lifecycle is maintained outside of that of the application.
--

. (Optional) Create a compose file named `compose.override.yml` with the following content.
+
[TIP]
====
Docker Compose lets you merge and override a set of Compose files together to create a composite Compose file.

By default, Compose reads two files, a _compose.yml_ and an optional _compose.override.yml_ file. By convention, the _compose.yml_ contains your base configuration. The override file can contain configuration overrides for existing services or entirely new services. <<multiple-compose-files>>
====
+
```yml
version: "2.4"
services:
  controller:
    build:
      args:
        - JENKINS_TAG=2.426.3-jdk21
    environment:
      - TZ=Asia/Shanghai
```

. Starting the controller container:
+
```sh
docker compose up -d
```

. Post-installation setup wizard.
+
Following this https://www.jenkins.io/doc/book/installing/docker/#setup-wizard[Post-installation setup] to finish the last steps.
+
[TIP]
====
Print the password at console.

```console
$ sudo docker inspect jenkins-home
...
        "Mountpoint": "/var/lib/docker/volumes/jenkins-home/_data",
        "Name": "jenkins-home",
...
$ sudo cat /var/lib/docker/volumes/jenkins-home/_data/secrets/initialAdminPassword
80df7355be5c4b15933742f7024dd739
```
====

=== Configuring Jenkins SSH credential

. Generating an SSH key pair.
+
TIP: To generate the SSH key pair, execute a command line tool named `ssh-keygen` on a machine you have access to. <<using-agents>>
+
```sh
ssh-keygen -t ed25519 -f ~/.ssh/jenkins_agent_key
```

. Create a Jenkins SSH credential.
+
--
. Go to your Jenkins dashboard.

. Go to *Manage Jenkins* option in left main menu and click on the *Credentials* button under the *Security*.

. Select the drop option *Add Credentials* from the `(global)` item under the *Stores scoped to Jenkins*.

. Fill in the form.
+
** Kind: _SSH Username with private key_
** ID: _jenkins_
** Description: _Jenkins SSH private key_
** Username: _jenkins_
** Private Key: Select *Enter directly* and press the *Add* button to insert the content of your private key file at _~/.ssh/jenkins_agent_key_.
** Passphrase: Fill your passphrase used to generate the SSH key pair (leave empty if you didn’t use one at the previous step) and then press the *Create* button.
--

=== Configuring Agents using SSH Connector in Docker

. Open up a terminal window, and create a directory named _agents_.
+
```sh
mkdir agents
cd agents
```

. Create an environment file named _.env_ and set the project name with _jenkins-agents_.
+
```sh
echo -n COMPOSE_PROJECT_NAME=jenkins-agents > .env
```

. Create a bridge network for the agent.
+
```sh
docker network create -d bridge jenkins-agents
```

. Create a compose file named `compose.yml` with the following content.
+
```yml
version: "2.4"
services:
  agent:
    container_name: jenkins-agent
    image: jenkins/ssh-agent:alpine-jdk21
    restart: on-failure
    ports:
      - "2200:22"
    environment:
      - "JENKINS_AGENT_SSH_PUBKEY=[your-public-key]" <1>
      # e.g. - "JENKINS_AGENT_SSH_PUBKEY=ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKBBHLJ+8RuLPO8dO1tm3RAt5kc3HqYwJUYMmRPjhtI3" <1>
    volumes:
      - agent-home:/home/jenkins/agent:rw <2>
    networks:
      jenkins-agent:
volumes:
  agent-home:
    name: jenkins-agent-home
networks:
  agents:
    external: true
    name: jenkins-agents
```
+
--
<1> The value of `JENKINS_AGENT_SSH_PUBKEY` MUST include the full contents of your .pub file created above (i.e. _~/.ssh/jenkins_agent_key.pub_), including the `ssh-XXXX` prefix. <<using-agents>>

<2> When using the Linux image, you have to set the value of the *Remote root directory* to `/home/jenkins/agent` in the agent configuration UI.
+
When using the Windows image, you have to set the value of the *Remote root directory* to `C:/Users/jenkins/Work` in the agent configuration UI. <<docker-ssh-agent>>
--

. Starting the agent container.
+
```sh
docker compose up -d
```

. Setup up the _jenkins-agent_ on jenkins.
+
--
. Go to your Jenkins dashboard.

. Go to *Manage Jenkins* option in left main menu.

. Go to *Nodes* item under the *System Configuration*.

. Go to *New Node* option in top right menu.

. Fill the *Node name* and select the type; (e.g. Name: _agent1_, Type: _Permanent Agent_), and then press the *Create* button.

. Now fill the fields.

** Remote root directory; (e.g. _/home/jenkins/agent_)

** Labels; (e.g. _agent1_ )

** Usage; (e.g. _Use this node as much as possible_)

** Launch method; (e.g. _Launch agents by SSH_)

** Host; (e.g. localhost or your IP address)

** Credentials; (e.g. _jenkins_)

** Host Key verification Strategy (e.g.: _Non verifying Verification Strategy_. _test only, NOT recommended_)

** Expand the *Advanced* tab, and set the *Port* to be `2200`

. Press the *Save* button and the agent1 will be registered, and be launched by the Controller.
--

. Delegating the first job to _agent1_.
+
--
. Go to your Jenkins dashboard

. Select *New Item* on side menu

. Enter an item name. (e.g.: _First Job to Agent1_)

. Select the *Freestyle project* and press *OK*.

. Now select the option *Execute shell* at *Build Steps* section.

. Add the command: `echo $NODE_NAME` in the *Command* field of the *Execute shell* step and the name of the agent will be printed inside the log when this job is run.

. Press the *Save* button and then select the option *Build Now*.

. Wait some seconds and then go to *Console Output* page.
+
```txt
Started by user admin
Running as SYSTEM
Building remotely on agent1 in workspace /home/jenkins/agent/workspace/test
[test] $ /bin/sh -xe /tmp/jenkins5590136104445527177.sh
+ echo agent1
agent1
Finished: SUCCESS
```
--

=== Configuring Agents running Docker in Docker

. Open up a terminal window, and create a directory named _agents/dind_:
+
```sh
mkdir -p agents/dind
cd agents/dind
```

. Create an environment file named _.env_ and set the project name with _jenkins-agents-dind_:
+
```sh
echo -n COMPOSE_PROJECT_NAME=jenkins-agents-dind > .env
```

. Create a bridge network for the agent:
+
```sh
docker network create -d bridge jenkins-agents-dind
```

. Create a compose file named `compose.yml` with the following content:
+
```yml
version: "2.4"
services:
  agent:
    container_name: jenkins-agent
    build:
      context: .
      dockerfile_inline: |
        ARG SSH_AGENET_TAG=jdk21
        FROM jenkins/ssh-agent:$${SSH_AGENET_TAG}
        ARG DOCKER_CE_CLI_VERSION=5:25.0.1-1~debian.12~bookworm
        RUN apt-get update \
            && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
                ca-certificates \
                curl \
                lsb-release \
            && rm -rf /var/lib/apt/lists/*
        RUN curl -fsSLo /usr/share/keyrings/docker-archive-keyring.asc https://download.docker.com/linux/debian/gpg
        RUN echo "deb [arch=$(dpkg --print-architecture) \
                  signed-by=/usr/share/keyrings/docker-archive-keyring.asc] \
                  https://download.docker.com/linux/debian \
                  $(lsb_release -cs) stable" > /etc/apt/sources.list.d/docker.list
        RUN apt-get update \
            && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
                docker-ce-cli=$${DOCKER_CE_CLI_VERSION} \ <1>
            && rm -rf /var/lib/apt/lists/*
    restart: on-failure
    ports:
      - "2200:22" <2>
    environment:
      - "JENKINS_AGENT_SSH_PUBKEY=[your-public-key]" <3>
      # e.g. - "JENKINS_AGENT_SSH_PUBKEY=ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKBBHLJ+8RuLPO8dO1tm3RAt5kc3HqYwJUYMmRPjhtI3" 
      - DOCKER_HOST=tcp://docker:2376
      - DOCKER_CERT_PATH=/certs/client
      - DOCKER_TLS_VERIFY=1
    volumes:
      - agent-home:/home/jenkins/agent:rw
      - docker-certs:/certs/client:ro
    networks:
      agents:
    depends_on:
      - docker
  docker:
    container_name: jenkins-docker
    image: docker:25
    restart: on-failure
    ports:
      - "2376"
    privileged: true
    environment:
       - DOCKER_TLS_CERTDIR=/certs
    volumes:
      - agent-home:/home/jenkins/agent:rw <4>
      - docker-certs:/certs/client:rw
      - docker-root:/var/lib/docker:rw
    networks:
      agents:
        aliases:
          - docker
volumes:
  agent-home:
    name: jenkins-agent-home-dind
  docker-certs:
    name: jenkins-agent-docker-certs
  docker-root:
    name: jenkins-agent-docker-root
networks:
  agents:
    external: true
    name: jenkins-agents-dind
```
+
--
<1> Extend the `jenkins/ssh-agent` image to install Docker CLI.
<2> If your machine already has a ssh server running on the `22` port, use another port to publish the agent container port 22 (SSH), such as `2200:22`.
<3> The value of `JENKINS_AGENT_SSH_PUBKEY` MUST include the full contents of your .pub file created above (i.e. _~/.ssh/jenkins_agent_key.pub_), including the `ssh-XXXX` prefix. <<using-agents>>
<4> Share the agent home volume (i.e. `agent-home`) to the Docker container, otherwise the pipeline will be stuck.
+
```console
. . .
process apparently never started in /home/jenkins/agent/workspace/jenkins-getting-started_main@tmp/durable-7a43d858
(running Jenkins temporarily with -Dorg.jenkinsci.plugins.durabletask.BourneShellScript.LAUNCH_DIAGNOSTICS=true might make the problem clearer)
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
$ docker stop --time=1 383e1c4132052f8e461d87bf75108d3e627623cafe3de5f7f5ca80f843c324ae
$ docker rm -f --volumes 383e1c4132052f8e461d87bf75108d3e627623cafe3de5f7f5ca80f843c324ae
[Pipeline] // withDockerContainer
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
ERROR: script returned exit code -2
Finished: FAILURE
```
--

. (Optional) Create a compose file named _compose.override.yml_ with the following content:
+
```yml
version: "2.4"
services:
  agent:
    build:
      args:
        - SSH_AGENET_TAG=jdk21
        - DOCKER_CE_CLI_VERSION=5:25.0.1-1~debian.12~bookworm
  docker:
    image: docker:25
```

. Starting the agent and docker container:
+
```sh
docker compose up -d
```

. Refer to link:#configuring-agents-running-docker-in-docker[Configuring agents using the SSH connector in Docker] to setup up the agent on jenkins, and create a *Freestyle project* using *Execute shell* with `docker version` command, and select the option *Build Now* then go to *Console Output* page.
+
```txt
Started by user admin
Running as SYSTEM
Building remotely on agent1 in workspace /home/jenkins/agent/workspace/test
[test] $ /bin/sh -xe /tmp/jenkins2069680891022148280.sh
+ docker version
Client: Docker Engine - Community
 Version:           25.0.1
 API version:       1.44
 Go version:        go1.21.6
 Git commit:        29cf629
 Built:             Tue Jan 23 23:09:46 2024
 OS/Arch:           linux/amd64
 Context:           default

Server: Docker Engine - Community
 Engine:
  Version:          25.0.1
  API version:      1.44 (minimum version 1.24)
  Go version:       go1.21.6
  Git commit:       71fa3ab
  Built:            Tue Jan 23 23:09:59 2024
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          v1.7.12
  GitCommit:        71909c1814c544ac47ab91d2e8b84718e517bb99
 runc:
  Version:          1.1.11
  GitCommit:        v1.1.11-0-g4bccb38
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
Finished: SUCCESS
```

== Blue Ocean

Blue Ocean as it stands provides easy-to-use Pipeline visualization. It was intended to be a rethink of the Jenkins user experience, designed from the ground up for Jenkins Pipeline. Blue Ocean was intended to reduce clutter and increases clarity for all users. <<book-blueocean>>

* *Sophisticated visualization* of continuous delivery (CD) Pipelines, allowing for fast and intuitive comprehension of your Pipeline’s status.

* *Pipeline editor* makes the creation of Pipelines more approachable, by guiding the user through a visual process to create a Pipeline.

* *Personalization* to suit the role-based needs of each member of the team.

* *Pinpoint precision* when intervention is needed or issues arise. Blue Ocean shows where attention is needed, facilitating exception handling and increasing productivity.

* *Native integration for branches and pull requests*, which enables maximum developer productivity when collaborating on code in GitHub and Bitbucket.

When Jenkins is installed on most platforms, the Blue Ocean plugin and all necessary dependent plugins, which compile the Blue Ocean suite of plugins, are not installed by default.

To install the Blue Ocean suite of plugins on an existing Jenkins instance: <<book-blueocean-gs>>

. Ensure you are logged in to Jenkins as a user with the *Administer* permission.

. From the Jenkins home page, select *Manage Jenkins* on the left and then *Plugins* under the *System Configuration*.

. Select the *Available plugins* tab and enter `blue ocean` in the *Filter* text box. This filters the list of plugins based on the name and description.

. Select the box to the left of *Blue Ocean*, and then select either the *Install after restart* option (recommended) or the *Install* without restart option at the top right of the page.
+    	
[NOTE]
====
It is not necessary to select other plugins in this list. The main *Blue Ocean* plugin automatically selects and installs all dependent plugins, composing the Blue Ocean suite of plugins.

If you select the *Install without restart* option, you must restart Jenkins to gain full Blue Ocean functionality.
====

Once a Jenkins environment has Blue Ocean installed and log in to the Jenkins classic UI, the Blue Ocean UI can be accessed by selecting *Open Blue Ocean* on the left side of the screen.

Alternatively, access Blue Ocean directly by appending `/blue` to the end of the Jenkins server’s URL. For example `https://jenkins-server-url/blue`.

If you need to access these features, select the *Go to classic* icon at the top of a common section of Blue Ocean’s navigation bar.

== Pipeline

Jenkins Pipeline (or simply "Pipeline" with a capital "P") is a suite of plugins which supports implementing and integrating continuous delivery pipelines into Jenkins.

The definition of a Jenkins Pipeline is written into a text file (called a `Jenkinsfile`) which in turn can be committed to a project’s source control repository, which is the foundation of "Pipeline-as-code"; treating the CD pipeline as a part of the application to be versioned and reviewed like any other code. <<book-pipeline>>

=== Pipeline Concepts

The following concepts are key aspects of Jenkins Pipeline, which tie in closely to Pipeline syntax.

* *Pipeline*
+
A Pipeline is a user-defined model of a CD pipeline. A Pipeline’s code defines your entire build process, which typically includes stages for building an application, testing it and then delivering it.
+
Also, a `pipeline` block is a key part of _Declarative Pipeline syntax_.

* *Node*
+
A node is a machine which is part of the Jenkins environment and is capable of executing a Pipeline.
=
Also, a `node` block is a key part of _Scripted Pipeline syntax_.

* *Stage*
+
A `stage` block defines a conceptually distinct subset of tasks performed through the entire Pipeline (e.g. "Build", "Test" and "Deploy" stages), which is used by many plugins to visualize or present Jenkins Pipeline status/progress.

* *Step*
+
A single task. Fundamentally, a `step` tells Jenkins what to do at a particular point in time (or "step" in the process). For example, to execute the shell command `make`, use the `sh` step: `sh 'make'`. When a plugin extends the Pipeline DSL, that typically means the plugin has implemented a new step.
+
For an overview of available steps, please refer to the https://www.jenkins.io/doc/pipeline/steps/[Pipeline Steps reference] which contains a comprehensive list of steps built into Pipeline as well as steps provided by plugins. <<pipeline-syntax>>

=== Pipelines Creating

A Pipeline can be created in one of the following ways:

* https://www.jenkins.io/doc/book/blueocean/creating-pipelines/[*Through Blue Ocean*] - after setting up a Pipeline project in Blue Ocean, the Blue Ocean UI helps you write your Pipeline’s `Jenkinsfile` and commit it to source control.
+
[NOTE]
====
Blue Ocean automatically generates an SSH public/private key pair or provides you with an existing pair for the current Jenkins user. This credential is automatically registered in Jenkins with the following details for this Jenkins user:

* Domain: _blueocean-private-key-domain_

* ID: _jenkins-generated-ssh-key_

* Name: _<jenkins-username> (jenkins-generated-ssh-key)_
====

* *Through the classic UI* - you can enter a basic Pipeline directly in Jenkins through the classic UI.

* https://www.jenkins.io/doc/book/pipeline/getting-started/#defining-a-pipeline-in-scm[*In SCM*] - you can write a `Jenkinsfile` manually, which you can commit to your project’s source control repository.

[TIP]
====
The https://www.jenkins.io/doc/book/pipeline/multibranch/[Multibranch Pipeline project] type enables you to implement different Jenkinsfiles for different branches of the same project. In a Multibranch Pipeline project, Jenkins automatically discovers, manages and executes Pipelines for branches which contain a `Jenkinsfile` in source control.
====

=== Jenkinsfile

Using a text editor, ideally one which supports http://groovy-lang.org/[Groovy] syntax highlighting, create a new Jenkinsfile in the root directory of the project. <<pipeline-jenkinsfile>>

```groovy
pipeline {
    agent any

    stages {
        stage('Build') {
            steps {
                echo 'Building..'
            }
        }
        stage('Test') {
            steps {
                echo 'Testing..'
            }
        }
        stage('Deploy') {
            steps {
                echo 'Deploying....'
            }
        }
    }
}
```

:j-pipeline-syntax: https://www.jenkins.io/doc/book/pipeline/syntax

The Declarative Pipeline example above contains the minimum necessary structure to implement a continuous delivery pipeline. The {j-pipeline-syntax}/#agent[agent directive], which is required, instructs Jenkins to allocate an executor and workspace for the Pipeline. Without an `agent` directive, not only is the Declarative Pipeline not valid, it would not be capable of doing any work! By default the `agent` directive ensures that the source repository is checked out and made available for steps in the subsequent stages.

The {j-pipeline-syntax}/#stages[stages directive], and {j-pipeline-syntax}/#steps[steps directives] are also required for a valid Declarative Pipeline as they instruct Jenkins what to execute and in which stage it should be executed.

=== Using Docker

Many organizations use Docker to unify their build and test environments across machines, and to provide an efficient mechanism for deploying applications.

[NOTE]
====
_To use the Docker with Pipeline, install the Docker Pipeline plugin:_

* Using the GUI: From your Jenkins dashboard navigate to *Manage Jenkins* > *Plugins* and select the *Available plugins* tab. Locate this plugin by searching for `docker-workflow`.

* Using the CLI tool:
+
```sh
jenkins-plugin-cli --plugins docker-workflow:572.v950f58993843
```

* Using direct upload. Download one of the https://plugins.jenkins.io/docker-workflow/#releases[releases] and upload it to your Jenkins instance.
====

Pipeline is designed to easily use Docker images as the execution environment for a single Stage or the entire Pipeline. Meaning that a user can define the tools required for their Pipeline, without having to manually configure agents. Any tool that can be packaged in a Docker container can be used with ease, by making only minor edits to a Jenkinsfile. <<pipeline-docker>>

```groovy
pipeline {
    agent {
        docker { image 'node:20.11.0-alpine3.19' }
    }
    stages {
        stage('Test') {
            steps {
                sh 'id'
                sh 'node --version'
            }
        }
    }
}
```

When the Pipeline executes, Jenkins will automatically start the specified container and execute the defined steps within:

```console
. . .
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Test)
[Pipeline] sh
+ id
uid=1000(node) gid=1000(node) groups=1000(node)
[Pipeline] sh
+ node --version
v20.11.0
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
. . .
```

[bibliography]
== References

* [[[glossary,1]]] https://www.jenkins.io/doc/book/glossary/
* [[[architecting-for-scale,2]]] https://www.jenkins.io/doc/book/scaling/architecting-for-scale/
* [[[managing-nodes,3]]] https://www.jenkins.io/doc/book/managing/nodes/
* [[[installing-docker,4]]] https://www.jenkins.io/doc/book/installing/docker/
* [[[docker-readme-md,5]]] https://github.com/jenkinsci/docker/blob/master/README.md
* [[[using-agents,6]]]] https://www.jenkins.io/doc/book/using/using-agents/
* [[[docker-ssh-agent,7]]] https://github.com/jenkinsci/docker-ssh-agent
* [[[multiple-compose-files,8]]] https://docs.docker.com/compose/multiple-compose-files/merge/.
* [[[book-blueocean,9]]] https://www.jenkins.io/doc/book/blueocean/
* [[[book-pipeline,9]]] https://www.jenkins.io/doc/book/pipeline/
* [[[book-blueocean-gs,10]]] https://www.jenkins.io/doc/book/blueocean/getting-started/
* [[[pipeline-jenkinsfile,11]]] https://www.jenkins.io/doc/book/pipeline/jenkinsfile/
* [[[pipeline-syntax,12]]] https://www.jenkins.io/doc/book/pipeline/syntax/
* [[[pipeline-docker,13]]] https://www.jenkins.io/doc/book/pipeline/docker/
