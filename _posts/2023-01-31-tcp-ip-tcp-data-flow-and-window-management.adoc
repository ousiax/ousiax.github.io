= TCP/IP: TCP Data Flow and Window Management
:page-layout: post
:page-categories: ['networking']
:page-tags: ['networking', 'tcp']
:page-date: 2023-01-31 16:22:46 +0800
:page-revdate: 2023-01-31 16:22:46 +0800
:toc: preamble
:toclevels: 4
:sectnums:
:sectnumlevels: 4

We now examine the dynamics of TCP data transfers, focusing initially on _interactive_ connections and then introducing flow control and associated window management procedures that are used in conjunction with congestion control for bulk data transfers (i.e., _noninteractive_ communications).

An _interactive_ TCP connection is one in which user input such as keystrokes, short messages, or joystick/mouse movements need to be delivered between a client and a server.

* If small segments are used to carry such user input, the protocol imposes more overhead because there are fewer useful payload bytes per packet exchanged.
* On the other hand, filling packets with more data usually requires them to be delayed, which can have a negative impact on delay-sensitive applications such as online games and collaboration tools.

== Interactive Communication

Studies of TCP traffic usually find that 90% or more of all TCP segments contain _bulk data_ (e.g., Web, file sharing, electronic mail, backups) and the remaining portion contains _interactive data_ (e.g., remote login, network games).

* Bulk data segments tend to be relatively large (1500 bytes or larger), while interactive data segments tend to be much smaller (tens of bytes of user data).

* TCP handles both types of data using the same protocol and packet format, but different algorithms come into play for each.

Let us look at the flow of data when we type an interactive command on an ssh connection.

TIP: Secure shell (`ssh`) is a remote login protocol that provides strong security (privacy and authentication based on cryptography). It has mostly replaced the earlier UNIX `rlogin` and Telnet programs that provide remote login service but without strong security.

.One possible way to remotely echo an interactive keystroke is a separate ACK and echo packet (a). A typical TCP coalesces the ACK for the data byte and the echo of the byte into a single packet (using _delayed acknowledgments_ with _piggybacking_) (b).
image::/assets/tcp-ip/tcp-data-flow-and-window-management/ssh-echo.png[,75%,75%]

== Delayed Acknowledgments

In many cases, TCP does not provide an ACK for every incoming packet because of TCP's cumulative ACK field.

Using a cumulative ACK allows TCP to intentionally _delay_ sending an ACK for some amount of time, in the hope that it can combine the ACK it needs to send with some data the local application wishes to send in the other direction. This is a form of *piggybacking* that is used most often in conjunction with bulk data transfers.

[NOTE]
====
The Host Requirements RFC [RFC1122] states that TCP should implement a delayed ACK but the delay must be less than 500ms. Many implementations use a maximum of 200ms.
====

Delaying ACKs causes less traffic to be carried over the network than when ACKs are not delayed because fewer ACKs are used. A ratio of 2 to 1 is fairly common for bulk transfers. The use of delayed ACKs and the maximum amount of time TCP is allowed to wait before sending an ACK can be configured, depending on the host operating system.

Linux uses a dynamic adjustment algorithm whereby it can change between ACKing every segment (called _quickack_ mode) and conventional delayed ACK mode.

[TIP]
====
On Red Hat Enterprise Linux, there are two modes used by TCP to acknowledge data reception: <<RHELDELACK>>

* Quick ACK
+
This mode is used at the start of a TCP connection so that the congestion window can grow quickly.
+
The acknowledgment (ACK) timeout interval (ATO) is set to `tcp_ato_min`, the minimum timeout value.
+
To change the default TCP ACK timeout value, write the required value in milliseconds to the `/proc/sys/net/ipv4/tcp_ato_min` file:
+
[source,console]
~]# echo 4 > /proc/sys/net/ipv4/tcp_ato_min

* Delayed ACK
+
After the connection is established, TCP assumes this mode, in which ACKs for multiple received packets can be sent in a single packet.
+
ATO is set to `tcp_delack_min` to restart or reset the timer.
+
To change the default TCP Delayed ACK value, write the required value in milliseconds to the `/proc/sys/net/ipv4/tcp_delack_min` file:
+
[source,console]
~]# echo 4 > /proc/sys/net/ipv4/tcp_delack_min

TCP switches between the two modes depending on the current congestion. 
====

== Nagle Algorithm

When using IPv4, sending one single key press across an ssh connection generates TCP/IPv4 packets of about 88 bytes in size (using the encryption and authentication from the example): 20 bytes for the IP header, 20 bytes for the TCP header (assuming no options), and 48 bytes of data.

These small packets (called _tinygrams_) have a relatively high overhead for the network beacuse they contain relatively little useful application data compared to the rest of the packet contents.

* Such high-overhead packets are normally not a problem on LANs, because most LANs are not congested and such packets would not need to be carried very far.

* However, these tinygrams can add to congestion and lead to inefficient use of capacity on wide area networks.

* A simple and elegant solution was proposed by John Nagle in [RFC0896], now called the _Nagle algorithm_.

The *Nagle algorithm* says that when a TCP connection has outstanding data that has not yet been acknowledged, small segments (those smaller than the SMSS) cannot be sent until all outstanding data is acknowledged.

* Instead, small amounts of data are collected by TCP and sent in a single segment when an acknowledgment arrives.
+
This procedure effectively forces TCP into _stop-and-wait_ behavior—it stops sending until an ACK is received for any outstanding data.

* The beauty of this algorithm is that it is _self-clocking_: the faster the ACKs come back, the faster the data is sent.
+
On a comparatively high-delay WAN, where reducing the number of tinygrams is desirable, fewer segments are sent per unit time. Said another way, the RTT controls the packet sending rate.

To illustrate the effect of the Nagle algorithm, we can compare the behaviors of an application using TCP with the Nagle algorithm enabled and disabled.

Using a connection with a relatively large RTT of about 190ms, we can see the differences.

[TIP]
====
Using the `tc` to emulate the network delay on the destination server:

[source,console]
----
$ sudo tc qdisc add dev ens32 root netem delay 190ms
$ sudo tc qdisc show dev ens32
qdisc netem 8001: root refcnt 2 limit 1000 delay 190.0ms
----
====

First, we examine the case with typing a `date` command when Nagle is disabled (the default for ssh):

[source,console]
----
00:00:00.000000 IP 192.168.91.1.17203 > 192.168.91.141.22: Flags [P.], seq 3968491625:3968491661, ack 2989677446, win 513, length 36
00:00:00.172405 IP 192.168.91.1.17203 > 192.168.91.141.22: Flags [P.], seq 36:72, ack 1, win 513, length 36
00:00:00.191476 IP 192.168.91.141.22 > 192.168.91.1.17203: Flags [P.], seq 1:37, ack 36, win 501, length 36
00:00:00.234297 IP 192.168.91.1.17203 > 192.168.91.141.22: Flags [.], ack 37, win 513, length 0
00:00:00.364007 IP 192.168.91.141.22 > 192.168.91.1.17203: Flags [P.], seq 37:73, ack 72, win 501, length 36
00:00:00.371952 IP 192.168.91.1.17203 > 192.168.91.141.22: Flags [P.], seq 72:108, ack 73, win 513, length 36
00:00:00.523976 IP 192.168.91.1.17203 > 192.168.91.141.22: Flags [P.], seq 108:144, ack 73, win 513, length 36
00:00:00.562856 IP 192.168.91.141.22 > 192.168.91.1.17203: Flags [P.], seq 73:109, ack 108, win 501, length 36
00:00:00.609221 IP 192.168.91.1.17203 > 192.168.91.141.22: Flags [.], ack 109, win 512, length 0
00:00:00.714586 IP 192.168.91.141.22 > 192.168.91.1.17203: Flags [P.], seq 109:145, ack 144, win 501, length 36
00:00:00.764111 IP 192.168.91.1.17203 > 192.168.91.141.22: Flags [.], ack 145, win 512, length 0
00:00:01.382426 IP 192.168.91.1.17203 > 192.168.91.141.22: Flags [P.], seq 144:180, ack 145, win 512, length 36
00:00:01.576594 IP 192.168.91.141.22 > 192.168.91.1.17203: Flags [P.], seq 145:181, ack 180, win 501, length 36
00:00:01.584727 IP 192.168.91.141.22 > 192.168.91.1.17203: Flags [P.], seq 181:249, ack 180, win 501, length 68
00:00:01.584731 IP 192.168.91.141.22 > 192.168.91.1.17203: Flags [P.], seq 249:285, ack 180, win 501, length 36
00:00:01.584731 IP 192.168.91.141.22 > 192.168.91.1.17203: Flags [P.], seq 285:353, ack 180, win 501, length 68
00:00:01.584995 IP 192.168.91.1.17203 > 192.168.91.141.22: Flags [.], ack 353, win 511, length 0
----

* An ssh trace showing a TCP connection with approximately a 190ms RTT.
* The Nagle algorithm is disabled.
* Transmissions and ACKs are intermingled, and the exchange takes 1.58s.
* Pure ACKs (segments with no data) indicate that command output at the server has been processed by the client.

If we repeat this measurement soon after (i.e., in similar network conditions) when Nagle is enabled:

[source,console]
----
00:00:00.000000 IP 192.168.91.1.17263 > 192.168.91.141.22: Flags [P.], seq 3369922274:3369922310, ack 3162733327, win 513, length 36
00:00:00.191032 IP 192.168.91.141.22 > 192.168.91.1.17263: Flags [P.], seq 1:37, ack 36, win 501, length 36
00:00:00.191425 IP 192.168.91.1.17263 > 192.168.91.141.22: Flags [P.], seq 36:72, ack 37, win 513, length 36
00:00:00.381981 IP 192.168.91.141.22 > 192.168.91.1.17263: Flags [P.], seq 37:73, ack 72, win 501, length 36
00:00:00.382316 IP 192.168.91.1.17263 > 192.168.91.141.22: Flags [P.], seq 72:108, ack 73, win 513, length 36
00:00:00.573124 IP 192.168.91.141.22 > 192.168.91.1.17263: Flags [P.], seq 73:109, ack 108, win 501, length 36
00:00:00.573501 IP 192.168.91.1.17263 > 192.168.91.141.22: Flags [P.], seq 108:144, ack 109, win 512, length 36
00:00:00.763985 IP 192.168.91.141.22 > 192.168.91.1.17263: Flags [P.], seq 109:145, ack 144, win 501, length 36
00:00:00.816253 IP 192.168.91.1.17263 > 192.168.91.141.22: Flags [.], ack 145, win 512, length 0
00:00:01.191218 IP 192.168.91.1.17263 > 192.168.91.141.22: Flags [P.], seq 144:180, ack 145, win 512, length 36
00:00:01.382047 IP 192.168.91.141.22 > 192.168.91.1.17263: Flags [P.], seq 145:181, ack 180, win 501, length 36
00:00:01.383712 IP 192.168.91.141.22 > 192.168.91.1.17263: Flags [P.], seq 181:249, ack 180, win 501, length 68
00:00:01.383716 IP 192.168.91.141.22 > 192.168.91.1.17263: Flags [P.], seq 249:285, ack 180, win 501, length 36
00:00:01.383717 IP 192.168.91.141.22 > 192.168.91.1.17263: Flags [P.], seq 285:353, ack 180, win 501, length 68
00:00:01.384295 IP 192.168.91.1.17263 > 192.168.91.141.22: Flags [.], ack 353, win 511, length 0
----

An ssh trace showing a TCP connection with a 190ms RTT and the Nagle algorithm in
operation. Requests are followed in lockstep with responses, and the exchange takes
0.80s using 11 packets.

* Nagle algorithm forces TCP to operate in a stop-and-wait fashion, so that the TCP sender cannot proceed until ACKs are received.

* If we look at the times for each request/response pair—0.0, 0.19, 0.19, and 0.38—we see that they follow a pattern; each is separated by almost exactly 190ms, which is very close to the RTT of the connection.
+
This is the trade-off the Nagle algorithm makes: fewer and larger packets are used, but the required delay is higher.

.Comparing the use of the Nagle algorithm for TCP connections with a similar operating environment. With Nagle enabled, at most one packet is allowed to be outstanding at any given time. This reduces the number of small packets but increases delay.
image::/assets/tcp-ip/tcp-data-flow-and-window-management/nagle-alg-comapring.png[,35%,35%]

=== Delayed ACK and Nagle Algorithm Interaction

.The interaction between the Nagle algorithm and delayed ACKs. A temporary form of deadlock can occur until the delayed ACK timer fires.
image::/assets/tcp-ip/tcp-data-flow-and-window-management/delayack-nagle-inter.png[,35%,35%]

Here we see that the client, after receiving two packets from the server, withholds an ACK, hoping that additional data headed toward the server can be piggybacked.

TIP: Generally, TCP is required to provide an ACK for two received packets only if they are full-size, and they are not here.

At the server side, because the Nagle algorithm is operating, no additional packets are permitted to be sent to the client until an ACK is returned because at most one _small_ packet is allowed to be outstanding.

The combination of delayed ACKs and the Nagle algorithm leads to a form of _deadlock_ (each side waiting for the other).

Fortunately, this deadlock is not permanent and is broken when the delayed ACK timer fires, which forces the client to provide an ACK even if the client has no additional data to send.

=== Disabling the Nagle Algorithm

The Nagle algorithm can be disabled in a number of ways. The ability to disable it is required by the Host Requirements RFC [RFC1122].

An application can specify the TCP_NODELAY option when using the Berkeley sockets API.

[source,man]
----
TCP(7)                     Linux Programmer's Manual                    TCP(7)

NAME
       tcp - TCP protocol
.....
       TCP_NODELAY
              If set, disable the Nagle algorithm.  This means  that  segments
              are  always  sent  as  soon as possible, even if there is only a
              small amount of data.  When not  set,  data  is  buffered  until
              there  is  a sufficient amount to send out, thereby avoiding the
              frequent sending of small packets, which results  in  poor  uti‐
              lization of the network.  This option is overridden by TCP_CORK;
              however, setting this option forces an explicit flush of pending
              output, even if TCP_CORK is currently set.
----

In addition, it is possible to disable the Nagle algorithm on a system-wide basis.

== Flow Control and Window Management

Every TCP segment (except those exchanged during connection establishment) includes a valid _Sequence Number_ field, an _ACK Number_ or _Acknowledgment_ field, and a _Window Size_ field (containing the window advertisement).

.Each TCP connection is bidirectional. Data going in one direction causes the peer to respond with ACKs and window advertisements. The same is true for the reverse direction.
image::/assets/tcp-ip/tcp-data-flow-and-window-management/flow-control-window-advertisment.png[Flow Control and Window Management,45%,45%]

When TCP-based applications are not busy doing other things, they are typically able to consume any and all data TCP has received and queued for them, leading to no change of the _Window Size_ field as the connection progresses.

On slow systems, or when the application has other things to accomplish, data may have arrived for the application, been acknowledged by TCP, and be sitting in a queue waiting for the application to read or _consume_ it.

* When TCP starts to queue data in this way, the amount of space available to hold new incoming data decreases, and this change is reflected by a decreasing value of the _Window Size_ field.

* Eventually, if the application does not read or otherwise consume the data at all, TCP must take some action to cause the sender to cease sending new data entirely, because there would be no place to put it on arrival.
+
This is accomplished by sending a window advertisement of zero (no space).

The _Window Size_ field in each TCP header indicates the amount of empty space, in bytes, remaining in the receive buffer.

* The field is 16 bits in TCP, but with the _Window Scale_ option, values larger than 65,535 can be used.

* The largest sequence number the sender of a segment is willing to accept in the reverse direction is equal to the sum of the _Acknowledgment Number_ and _Window Size_ fields in the TCP header (scaled appropriately).

[source,c]
----
/* slow_client.c */
#include <unistd.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define RCVBUFSIZE 4096

int main(void) {
    /* Create a TCP socket */
    /* Create a reliable, stream socket using TCP */
    int client_sock;
    if ((client_sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
        perror("socket() failed");
        exit(EXIT_FAILURE);
    }

    /* Establish connection */
    char *serv_ip = "127.0.0.1";
    int serv_port = 6666;
    struct sockaddr_in serv_addr;
    serv_addr.sin_family = AF_INET;                     /* Internet address family */
    serv_addr.sin_addr.s_addr = inet_addr(serv_ip);     /* Server IP address*/
    serv_addr.sin_port = htons(serv_port);              /* Server port */
    if (connect(client_sock, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
        perror("connect() failed");
        exit(EXIT_FAILURE);
    }

    /* Communicate */
    char *read_buf = (char*)malloc(RCVBUFSIZE * sizeof(char));
    int recv_msg_size;
    for(;;) {
        /* Sleep 1s */
        sleep(1);

        /* Receive mesage from server */
        if ((recv_msg_size = recv(client_sock, read_buf, RCVBUFSIZE, 0)) < 0) {
            perror("recv() failed");
            break;
        }

        /*  EOF */
        if (recv_msg_size == 0) {
            break;
        }

        fputs(read_buf, stdout);
        memset(read_buf, '\0', RCVBUFSIZE);
    }

    /* Close the connection */
    close(client_sock);
}
----

[source,console]
----
$ zcat /usr/share/doc/linux-doc/Documentation/networking/ip-sysctl.rst.gz | nc -l --send-only 6666
----

[source,console]
----
$ cc slow_client.c -o slow_client
$ ./slow_client
----

[source,console]
----
 00:00:00.000000 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [S], seq 732284889, win 65495, options [mss 65495,sackOK,TS val 3010613877 ecr 0,nop,wscale 7], length 0
 00:00:00.000022 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [S.], seq 163752444, ack 732284890, win 65483, options [mss 65495,sackOK,TS val 3010613877 ecr 3010613877,nop,wscale 7], length 0
 00:00:00.000043 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 1, win 512, options [nop,nop,TS val 3010613877 ecr 3010613877], length 0
 00:00:00.000440 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [P.], seq 1:8193, ack 1, win 512, options [nop,nop,TS val 3010613878 ecr 3010613877], length 8192
 00:00:00.000445 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 8193, win 475, options [nop,nop,TS val 3010613878 ecr 3010613878], length 0
 00:00:00.000456 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [P.], seq 8193:16385, ack 1, win 512, options [nop,nop,TS val 3010613878 ecr 3010613878], length 8192
 00:00:00.000457 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 16385, win 443, options [nop,nop,TS val 3010613878 ecr 3010613878], length 0
 00:00:00.000465 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [P.], seq 16385:24577, ack 1, win 512, options [nop,nop,TS val 3010613878 ecr 3010613878], length 8192
 00:00:00.000466 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 24577, win 411, options [nop,nop,TS val 3010613878 ecr 3010613878], length 0
 00:00:00.000473 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [P.], seq 24577:32769, ack 1, win 512, options [nop,nop,TS val 3010613878 ecr 3010613878], length 8192
 00:00:00.000474 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 32769, win 379, options [nop,nop,TS val 3010613878 ecr 3010613878], length 0
 00:00:00.000485 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [P.], seq 32769:40961, ack 1, win 512, options [nop,nop,TS val 3010613878 ecr 3010613878], length 8192
 00:00:00.000773 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [P.], seq 40961:73729, ack 1, win 512, options [nop,nop,TS val 3010613878 ecr 3010613878], length 32768
 00:00:00.015147 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [P.], seq 40961:73729, ack 1, win 512, options [nop,nop,TS val 3010613892 ecr 3010613878], length 32768
 00:00:00.047085 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 73729, win 59, options [nop,nop,TS val 3010613924 ecr 3010613878,nop,nop,sack 1 {40961:73729}], length 0
 00:00:00.259155 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [P.], seq 73729:81281, ack 1, win 512, options [nop,nop,TS val 3010614136 ecr 3010613924], length 7552
 00:00:00.259206 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 81281, win 0, options [nop,nop,TS val 3010614137 ecr 3010614136], length 0
 00:00:00.471128 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [.], ack 1, win 512, options [nop,nop,TS val 3010614348 ecr 3010614137], length 0
 00:00:00.471140 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 81281, win 0, options [nop,nop,TS val 3010614349 ecr 3010614136], length 0
 00:00:00.918546 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [.], ack 1, win 512, options [nop,nop,TS val 3010614796 ecr 3010614349], length 0
 00:00:01.782255 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [.], ack 1, win 512, options [nop,nop,TS val 3010615660 ecr 3010614349], length 0
 00:00:01.782263 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 81281, win 0, options [nop,nop,TS val 3010615660 ecr 3010614136], length 0
 00:00:03.478634 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [.], ack 1, win 512, options [nop,nop,TS val 3010617356 ecr 3010615660], length 0
 00:00:03.478642 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 81281, win 0, options [nop,nop,TS val 3010617356 ecr 3010614136], length 0
 00:00:06.934944 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [.], ack 1, win 512, options [nop,nop,TS val 3010620812 ecr 3010617356], length 0
 00:00:06.934972 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 81281, win 0, options [nop,nop,TS val 3010620812 ecr 3010614136], length 0
 00:00:13.846498 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [.], ack 1, win 512, options [nop,nop,TS val 3010627724 ecr 3010620812], length 0
 00:00:13.846506 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 81281, win 0, options [nop,nop,TS val 3010627724 ecr 3010614136], length 0
 00:00:20.017448 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 81281, win 512, options [nop,nop,TS val 3010633895 ecr 3010614136], length 0
 00:00:20.017464 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [FP.], seq 81281:91177, ack 1, win 512, options [nop,nop,TS val 3010633895 ecr 3010633895], length 9896
 00:00:20.058855 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [.], ack 91178, win 469, options [nop,nop,TS val 3010633936 ecr 3010633895], length 0
 00:00:24.020472 IP 127.0.0.1.44640 > 127.0.0.1.6666: Flags [F.], seq 1, ack 91178, win 512, options [nop,nop,TS val 3010637898 ecr 3010633895], length 0
 00:00:24.020483 IP 127.0.0.1.6666 > 127.0.0.1.44640: Flags [.], ack 2, win 512, options [nop,nop,TS val 3010637898 ecr 3010637898], length 0
----

[bibliography]
== References

* [[[TCPIPVOL1]]] Kevin Fall, W. Stevens _TCP/IP Illustrated: The Protocols, Volume 1_. 2nd edition, Addison-Wesley Professional, 2011
* [[[RHELDELACK]]] _Reducing the TCP Delayed ACK Timeout_ [online]. https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_for_real_time/7/html/tuning_guide/reducing_the_tcp_delayed_ack_timeout
* [[[WTCP]]] https://en.wikipedia.org/wiki/Transmission_Control_Protocol
* [[[WSCALE]]] https://en.wikipedia.org/wiki/TCP_window_scale_option
