= TCP/IP: User Datagram Protocol (UDP) and IP Fragmentation
:page-layout: post
:page-categories: ['networking']
:page-tags: ['networking', 'udp']
:page-date: 2022-12-06 08:37:47 +0800
:page-revdate: 2022-12-06 08:37:47 +0800
:toc: preamble
:sectnums:

UDP is a simple, datagram-oriented, transport-layer protocol that preserves message boundaries.

It does not provide error correction, sequencing, duplicate elimination, flow control, or congestion control.

It can provide error detection, and it includes the first true _end-to-end_ checksum at the transport layer that we have encountered.

This protocol provides minimal functionality itself, so applications using it have a great deal of control over how packets are sent and processed.

.Encapsulation of a UDP datagram in a single IPv4 datagram (the typical case with no IPv4 options). The IPv6 encapsulation is similar; the UDP header follows the header chain.
image::/assets/tcp-ip/udp-and-ip-fragmentation/ipv4-udp-datagram-message-format.png[IPv4 UDP Datagram,45%,45%]

== UDP Header

.The UDP header and payload (data) area. The Checksum field is end-to-end and is computed over the UDP pseudo-header, which includes the Source and Destination IP Address fields from the IP header. Thus, any modification made to those fields (e.g., by NAT) requires a modification to the UDP checksum.
image::/assets/tcp-ip/udp-and-ip-fragmentation/udp-header-and-payload.png[UDP Header and Payload,35%,35%]

Port numbers act as _mailboxes_ and help a protocol implementation identify the sending and receiving processes. They are purely _abstract_â€”they do not correspond to any physical entity on a host.

* In UDP, port numbers are positive 16-bit numbers, and the source port number is optional; it may be set to 0 if the sender of the datagram never requires a reply.

* Transport protocols such as TCP, UDP, and SCTP [RFC4960] use the destination port number to help demultiplex incoming data from IP.

* Because IP demultiplexes the incoming IP datagram to a particular transport protocol based on the value of the _Protocol_ field in the IPv4 header or _Next Header_ field in the IPv6 header, this means that the port numbers can be made independent among the transport protocols.
+
[NOTE]
====
Despite this independence, if a well-known service is provided (or can conceivably be provided) by both TCP and UDP, the port number is normally allocated to be the same for both transport protocols. This is purely for convenience and is not required by the protocols.
====

The UDP _Length_ field is the length of the UDP header and the UDP data in bytes. The minimum value for this field is 8 except when UDP is used with IPv6 jumbograms.

[NOTE]
====
Note that the UDP _Length_ field is redundant; the IPv4 header contains the datagram's total length, and the IPv6 header contains the payload length.

* The length of a UDP/IPv4 datagram is then the _Total Length_ of the IPv4 datagram minus the length of the IPv4 header.

* A UDP/IPv6 datagram's length is the value of the _Payload Length_ field contained in the IPv6 header minus the lengths of any extension headers (unless jumbograms are being used).

In either case, the UDP _Length_ field should match the length computed from the IP-layer information.
====

== UDP Checksum

The UDP checksum is the first end-to-end transport-layer checksum we have encountered (ICMP has an end-to-end checksum but is not a true transport protocol). It covers the UDP header, the UDP data, and a pseudo-header.

It is computed at the initial sender and checked at the final destination. It is not modified in transit (except when it passes through a NAT).

Recall that the checksum in the IPv4 header covers only the header (i.e.,

* it does not cover any data in the IP packet)
* and is recomputed at each IP hop (required because the IPv4 _TTL_ field is decremented by routers when the datagram is forwarded).

Transport protocols (e.g., TCP, UDP) use checksums to cover their headers and data.

* With UDP, the checksum is optional (although strongly suggested), while with the others it is mandatory.

* When UDP is used with IPv6, computation and use of the checksum are mandatory because there is no header checksum at the IP layer.

To provide error-free data to applications, a transport-layer protocol such as UDP must always compute a checksum or use some other error detection mechanism before delivering the data to a receiving application.

The pseudo-header is virtual and is used only for purposes of the checksum computation (at both the sender and the receiver).

* It is never actually transmitted.
* This pseudo-header includes the source and destination addresses and _Protocol_ or _Next Header_ field (which should contain the value 17) from the IP header.
* Its purpose is to let the UDP layer verify that the data has arrived at the correct destination (i.e., that IP has not accepted a misaddressed datagram, and that IP has not given UDP a datagram that is for another transport protocol).

.Fields used in computing the checksum for UDP/IPv4 datagrams, including the pseudo-header, the UDP header, and data. If the data is not an even number of bytes, it is padded with one 0 byte for purposes of computing the checksum. The pseudo-header and any pad bytes are not transmitted with the datagram.
image::/assets/tcp-ip/udp-and-ip-fragmentation/ipv4-udp-pesudo-header-checksum.png[UDP pseduo-header checksum,40%,40%]

[source,console]
----
x@node-0:~$ echo -n "hello" | nc -4u -w0 192.168.91.137 330
----

[source,console]
----
root@node-0:~# tcpdump -tnv -X host 192.168.91.137 and \( udp or icmp \)
IP (tos 0x0, ttl 64, id 38490, offset 0, flags [DF], proto UDP (17), length 33)
    192.168.91.128.58585 > 192.168.91.137.330: UDP, length 5
	0x0000:  4500 0021 965a 4000 4011 6c17 c0a8 5b80  E..!.Z@.@.l...[.
	0x0010:  c0a8 5b89 e4d9 014a 000d 9d83 6865 6c6c  ..[....J....hell
	0x0020:  6f                                       o
IP (tos 0xc0, ttl 64, id 62130, offset 0, flags [none], proto ICMP (1), length 61)
    192.168.91.137 > 192.168.91.128: ICMP 192.168.91.137 udp port 330 unreachable, length 41
	IP (tos 0x0, ttl 64, id 38490, offset 0, flags [DF], proto UDP (17), length 33)
    192.168.91.128.58585 > 192.168.91.137.330: UDP, length 5
	0x0000:  45c0 003d f2b2 0000 4001 4ef3 c0a8 5b89  E..=....@.N...[.
	0x0010:  c0a8 5b80 0303 3576 0000 0000 4500 0021  ..[...5v....E..!
	0x0020:  965a 4000 4011 6c17 c0a8 5b80 c0a8 5b89  .Z@.@.l...[...[.
	0x0030:  e4d9 014a 000d 9d83 6865 6c6c 6f         ...J....hello
----

== UDP and IPv6

.The UDP (and TCP) pseudo-header used with IPv6 ([RFC2460]). The pseudo-header includes the source and destination IPv6 addresses and a larger 32-bit _Length_ field value. The pseudo-header checksum is required when UDP is used with IPv6 because the IPv6 header lacks a checksum. The _Next Header_ field is copied from the last IPv6 header of the chain.
image::/assets/tcp-ip/udp-and-ip-fragmentation/ipv6-udp-tcp-pesudo-header-checksum.png[UDP/TCP IPv6 pseduo-header,45%,45%]

A related but more subtle distinction is that in IPv6, no IP-layer header checksum is present.

* If UDP were to operate with checksums disabled, there would be no _end-to-end check whatsoever_ on the correctness of the IP-layer addressing information.

* When UDP is used with IPv6, a pseudo-header checksum, common to both UDP and TCP, is required.

* In IPv6, the minimum MTU size is 1280 bytes (as opposed to the 576 bytes required by IPv4 as the minimum size required to be supported by all hosts).

* IPv6 supports jumbograms (packets larger than 65,535 bytes).
+
When encapsulated in IPv6, a UDP/IPv6 datagram exceeding 65,535 bytes has its UDP _Length_ field value set to 0.

[source,console]
----
x@node-0:~$ echo -n ' ' |  nc -6u -w0 fe80::20c:29ff:fe85:2610%ens32 330
----

[source,console]
----
root@node-0:~# tcpdump -tnv host fe80::20c:29ff:fe85:2610 and \( udp or icmp6 \) -X
tcpdump: listening on ens32, link-type EN10MB (Ethernet), snapshot length 262144 bytes
IP6 (flowlabel 0x6b6e1, hlim 64, next-header UDP (17) payload length: 9) fe80::20c:29ff:fe8c:df3f.33297 > fe80::20c:29ff:fe85:2610.330: [udp sum ok] UDP, length 1
	0x0000:  6006 b6e1 0009 1140 fe80 0000 0000 0000  `......@........
	0x0010:  020c 29ff fe8c df3f fe80 0000 0000 0000  ..)....?........
	0x0020:  020c 29ff fe85 2610 8211 014a 0009 0506  ..)...&....J....
	0x0030:  20 
IP6 (flowlabel 0xa4c7d, hlim 64, next-header ICMPv6 (58) payload length: 57) fe80::20c:29ff:fe85:2610 > fe80::20c:29ff:fe8c:df3f: [icmp6 sum ok] ICMP6, destination unreachable, unreachable port, fe80::20c:29ff:fe85:2610 udp port 330
	0x0000:  600a 4c7d 0039 3a40 fe80 0000 0000 0000  `.L}.9:@........
	0x0010:  020c 29ff fe85 2610 fe80 0000 0000 0000  ..)...&.........
	0x0020:  020c 29ff fe8c df3f 0104 7ef6 0000 0000  ..)....?..~.....
	0x0030:  6006 b6e1 0009 1140 fe80 0000 0000 0000  `......@........
	0x0040:  020c 29ff fe8c df3f fe80 0000 0000 0000  ..)....?........
	0x0050:  020c 29ff fe85 2610 8211 014a 0009 0506  ..)...&....J....
	0x0060:  20                                     
----

== UDP-Lite

Some applications are tolerant of bit errors that may be introduced in the data they send and receive. Often, these types of applications wish to use UDP in order to avoid connection setup overhead or to use broadcast or multicast addressing, but UDP uses a checksum that covers either the entire payload or none of it (i.e., when no checksum is computed by the sender).

A protocol called *UDP-Lite* or *UDPLite* [RFC3828] addresses this issue by modifying the conventional UDP protocol to provide partial checksums. Such checksums cover only a portion of the payload in each UDP datagram.

UDP-Lite has its own IPv4 Protocol and IPv6 Next Header field value (136), so it effectively counts as a separate transport protocol.

.UDP-Lite includes a Checksum Coverage field that gives the number of bytes (starting with the first byte of the UDP-Lite header) covered by the checksum. The minimum value is 0, indicating that the whole datagram is covered. Values 1 through 7 are invalid, as the header is always covered. UDP-Lite uses a different IPv4 protocol number (136) from UDP (17). IPv6 uses the same values in the _Next Header_ field.
image::/assets/tcp-ip/udp-and-ip-fragmentation/udp-lite-message-format.png[UDP-Lite Message, 45%,45%]

== IP Fragmentation

The link-layer framing normally imposes an upper limit on the maximum size of a frame that can be transmitted.

To keep the IP datagram abstraction consistent and isolated from link-layer details, IP employs _fragmentation_ and _reassembly_.

* Whenever the IP layer receives an IP datagram to send, it determines which local interface the datagram is to be sent over next (via a forwarding table lookup) and what MTU is required.
+
IP compares the outgoing interface's MTU with the datagram size and performs fragmentation if the datagram is too large.

* Fragmentation in IPv4 can take place at the original sending host and at any intermediate routers along the end-to-end path. Note that datagram fragments can themselves be fragmented.

* Fragmentation in IPv6 is somewhat different because only the source is permitted to perform fragmentation.

* When an IP datagram is fragmented, it is not reassembled until it reaches its final destination.

.A single UDP datagram with 2992 UDP payload bytes is fragmented into three UDP/IPv4 packets (no options). The UDP header that contains the source and destination port numbers appears only in the first fragment (a complicating factor for firewalls and NATs). Fragmentation is controlled by the _Identification_, _Fragment Offset_, and _More Fragments_ (MF) fields in the IPv4 header.
image::/assets/tcp-ip/udp-and-ip-fragmentation/udp-datagram-fragmentation-sample.png[UDP datagram fragmentation sample,50%,50%]

* The original UDP datagram included 2992 bytes of application (UDP payload) data and 8 bytes of UDP header, resulting in an IPv4 _Total Length_ field value of 3020 bytes (recall that this size includes a 20-byte IPv4 header as well).
+
When this datagram was fragmented into three packets, 40 extra bytes were created (20 bytes for each of the newly created IPv4 fragment headers). Thus, the total number of bytes sent is 3060, an increase in IP-layer overhead of about 1.3%.

* The _Identification_ field value (set by the original sender) is copied to each fragment and is used to group them together when they arrive.

* The _Fragment Offset_ field gives the offset of the first byte of the fragment payload byte in the original IPv4 datagram (_in 8-byte units_).

* Finally, the _MF_ bit field indicates whether more fragments in the datagram should be expected and is 0 only in the final fragment.
+
Because each _Offset_ field is relative to the original datagram, the reassembly process can handle fragments that arrive out of order.
+
When a datagram is fragmented, the _Total Length_ field in the IPv4 header of each fragment is changed to be the total size of that fragment.

[source,console]
----
x@node-0:$ ip addr show ens32 
2: ens32: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:8c:df:3f brd ff:ff:ff:ff:ff:ff
    altname enp2s0
    inet 192.168.91.128/24 brd 192.168.91.255 scope global ens32
       valid_lft forever preferred_lft forever

x@node-0:$ dd bs=2992 if=/dev/zero count=1 status=none | nc -w0 -u -s 192.168.91.128 192.168.91.137 330
----

[source,console]
----
root@node-0:~# tcpdump -tnvvv -i ens32 host 192.168.91.137 and udp
IP (tos 0x0, ttl 64, id 4494, offset 0, flags [+], proto UDP (17), length 1500)
    192.168.91.128.45401 > 192.168.91.137.330: UDP, length 2992
IP (tos 0x0, ttl 64, id 4494, offset 1480, flags [+], proto UDP (17), length 1500)
    192.168.91.128 > 192.168.91.137: ip-proto-17
IP (tos 0x0, ttl 64, id 4494, offset 2960, flags [none], proto UDP (17), length 60)
    192.168.91.128 > 192.168.91.137: ip-proto-17
----
