= TCP/IP: Security: EAP, IPsec, TLS, DNSSEC, and DKIM
:page-layout: post
:page-categories: ['networking']
:page-tags: ['networking', 'tcp']
:page-date: 2023-02-24 08:27:23 +0800
:page-revdate: 2023-07-24 08:27:23 +0800
:toc: preamble
:toclevels: 4
:sectnums:
:sectnumlevels: 4

There are three primary properties of information, whether in a computer network or not, that may be desirable from an information security point of view: confidentiality, integrity, and availability (the CIA triad) [L01], summarized here:

* *Confidentiality* means that information is made known only to its intended users (which could include processing systems).
* *Integrity* means that information has not been modified in an unauthorized way before it is delivered.
* *Availability* means that information is available when needed.

These are core properties of information, yet there are other properties we may also desire, including _authentication_, _nonrepudiation_, and _auditability_.

* *Authentication* means that a particular identified party or principal is not impersonating another principal.

* *Nonrepudiation* means that if some action is performed by a principal (e.g., agreeing to the terms of a contract), this fact can be proven later (i.e., cannot successfully be denied).

* *Auditability* means that some sort of trustworthy log or accounting describing how information has been used is available.
+
Such logs are often important for forensic (i.e., legal and prosecuritorial) purposes.

These principles are applicable to information in physical (e.g., printed) form, for which mechanisms such as safes, secured facilities, and guards have been used for thousands of years to enforce controlled sharing, storage, and dissemination. When information is to be moved through an unsecured environment, additional techniques are required.

== Threats to Network Communication

Attacks can generally be categorized as either passive or active.

* *Passive attacks* are mounted by monitoring or eavesdropping on the contents of network traffic, and if not handled they can lead to unauthorized release of information (loss of confidentiality).

* *Active attacks* can cause modification of information (with possible loss of integrity) or denial of service (loss of availability).
+
Logically, such attacks are carried out by an "intruder" or adversary.

.The principals, Alice and Bob, attempt to communicate securely, but Eve may eavesdrop and Mallory may modify messages in transit.
image::/assets/tcp-ip/security/passive-active-attacks.jpg[Passive and active attacks,50%,50%]

Eve is able to eavesdrop (listen in on, also called _capture_ or _sniff_) and perform *_traffic analysis_* on the traffic passing between Alice and Bob.

* Capturing the traffic could lead to compromise of confidentiality, as sensitive data may be available to Eve without Alice or Bob knowing.
+
In addition, traffic analysis can determine the features of the traffic, such as its size and when it is sent, and possibly identify the parties to a communication. This information, although it does not reveal the exact contents of the communication, could also lead to disclosure of sensitive information and could be used to mount more powerful active attacks in the future.

While the passive attacks are essentially impossible for Alice or Bob to detect, Mallory is capable of performing more easily noticed active attacks. These include
_message stream modification_ (MSM), _denial-of-service_ (DoS), and _spurious association_ attacks.

* MSM attacks (including so-called called *_man-in-the-middle_* or MITM_attacks) are a broad category and include any way traffic is modified in transit, including deletion, reordering, and content modification.

* DoS might include deletion of traffic, or generation of such large volumes of traffic so as to overwhelm Alice, Bob, or the communication channel connecting them.

* Spurious associations include *_masquerading_* (Mallory pretends to be Bob or Alice) and replay, whereby Alice or Bob’s earlier (authentic) communications are replayed later, from Mallory's memory.

.Attacks on communication are broadly classified as passive or active. Passive attacks are ordinarily more difficult to detect, and active attacks are ordinarily more difficult to prevent.
[%header,cols="1,1,1,1"]
|===
2+|Passive
2+|Active

h|Type
h|Threats
h|Type
h|Threats

|Eavesdropping
|Confidentiality
|Message stream modification
|Authenticity, integrity

|Traffic analysis
|Confidentiality
|Denial of service (DoS)
|Availability

|
|
|Spurious association
|Authenticity

|===

With effective and careful use of *cryptography*, passive attacks are rendered ineffective, and active attacks are made detectable (and to some degree preventable).

== Basic Cryptography and Security Mechanisms

Cryptography evolved from the desire to protect the confidentiality, integrity, and authenticity of information carried through unsecured communication channels.

The use of cryptography, at least in a primitive form, dates back to at least 3500 BCE. The earliest systems were usually *codes*.

Codes involve substitutions of groups of words, phrases, or sentences with groups of numbers or letters as given in a codebook. Codebooks needed to be kept secret in order to keep communications private, so distributing them required considerable care.

More advanced systems used *ciphers*, in which both substitution and rearrangement are used.

=== Cryptosystems

.The unencrypted (cleartext) message is passed through an encryption algorithm to produce an encrypted (ciphertext) message. In a symmetric cryptosystem, the same (secret) key is used for encryption and decryption. In an asymmetric or public key cryptosystem, confidentiality is achieved by using the recipient's public key for encryption and private (secret) key for decryption.
image::/assets/tcp-ip/security/symmetric-asymmetric-cryptosystem.png[Symmetric and asymmetric key cryptosystem,50%,50%]

* In each case, a *cleartext* message is processed by an encryption algorithm to produce *ciphertext* (scrambled text).

* The *key* is a particular sequence of bits used to drive the *encryption algorithm* or cipher.

* With different keys, the same input produces different outputs. Combining the algorithms with supporting protocols and operating methods forms a *cryptosystem*.

* In a *symmetric cryptosystem*, the encryption and decryption keys are typically identical, as are the encryption and decryption algorithms.

* In an *asymmetric cryptosystem*, each principal is generally provided with a *pair* of keys consisting of one public and one private key.
+
The public key is intended to be known to any party that might want to send a message to the key pair's owner.
+
The public and private keys are mathematically related and are themselves outputs of a *key generation* algorithm.

Without knowing the symmetric key (in a symmetric cryptosystem) or the private key (in a public key cryptosystem), it is (believed to be) effectively impossible
for any third party that intercepts the ciphertext to produce the corresponding cleartext. This provides the basis for confidentiality.

For the symmetric key cryptosystem, it also provides a degree of authentication, because only a party holding the key is able to produce a useful ciphertext that can be decrypted to something sensible.

* A receiver can decrypt the ciphertext, look for a portion of the resulting cleartext to contain a particular agreed-upon value, and conclude that the sender holds the appropriate key and is therefore authentic.

* Furthermore, most encryption algorithms work in such a way that if messages are modified in transit, they are unable to produce useful cleartext upon decryption.

Thus, symmetric cryptosystems provide a measure of both authentication and integrity protection for messages, but this approach alone is weak. Instead, special forms of checksums are usually coupled with symmetric cryptography to ensure integrity.

A symmetric encryption algorithm is usually classified as either a *block cipher* or a *stream cipher*.

* Block ciphers perform operations on a fixed number of bits (e.g., 64 or 128) at a time,

* and stream ciphers operate continuously on however many bits (or bytes) are provided as input.

For years, the most popular symmetric encryption algorithm was the *_Data Encryption Standard_* (DES), a block cipher that uses 64-bit blocks and 56-bit keys.

Eventually, the use of 56-bit keys was felt to be insecure, and many applications turned to *_triple_*-_DES_ (also denoted 3DES or TDES—applying DES three times with two or three different keys to each block of data).

Today, DES and 3DES have been largely phased out in favor of the *_Advanced Encryption Standard_* (AES), also known occasionally by its original name the _Rijndael_ algorithm (pronounced “rain-dahl”), in deference to its Belgian cryptographer inventors Vincent Rijmen and Joan Daemen.

Different variants of AES provide key lengths of 128, 192, and 256 bits and are usually written with the corresponding extension (i.e., AES-128, AES-192, and AES-256).

Asymmetric cryptosystems have some additional interesting properties beyond those of symmetric key cryptosystems.

. Assuming we have Alice as sender and Bob as intended recipient, any third party is assumed to know Bob's public key and can therefore send him a secret message—only Bob is able to decrypt it because only Bob knows the private key corresponding to his public key.

. However, Bob has no real assurance that the message is authentic, because any party can create a message and send it to Bob, encrypted in Bob's public key.

. Fortunately, public key cryptosystems also provide another function when used in reverse: authentication of the sender.

. In this case, Alice can encrypt a message using her private key and send it to Bob (or anyone else).

. Using Alice's public key (known to all), anyone can verify that the message was authored by Alice and has not been modified.

. However, it is not confidential because everyone has access to Alice's public key.

. To achieve authenticity, integrity, and confidentiality, Alice can encrypt a message using her private key and encrypt the result using Bob's public key.

. The result is a message that is reliably authored by Alice and is also confidential to Bob.
+
.The asymmetric cryptosystem can be used for confidentiality (encryption), authentication (digital signatures or signing), or both. When used for both, it produces a signed output that is confidential to the sender and the receiver. Public keys, as their name suggests, are not kept secret.
image::/assets/tcp-ip/security/asymmetric-cryptosystem.png[Asymmetric (Public Key) Cryptosystem,50%,50%]

When public key cryptography is used in "reverse" like this, it provides a *digital signature*.

* Digital signatures are important consequences of public key cryptography and can be used to help ensure authenticity and nonrepudiation.

* Only a party possessing Alice’s private key is able to author messages or carry out transactions as Alice.

In a *_hybrid_* cryptosystem, elements of both public key and symmetric key cryptography are used.

* Most often, public key operations are used to exchange a randomly generated confidential (symmetric) *session key*, which is used to encrypt traffic for a single transaction using a symmetric algorithm.

* The reason for doing so is performance—symmetric key operations are less computationally intensive than public key operations.

* Most systems today are of the hybrid type: public key cryptography is used to establish keys used for symmetric encryption of individual sessions.

=== Rivest, Shamir, and Adleman (RSA) Public Key Cryptography

The most common approach used for both digital signatures and confidentiality is called RSA in deference to its authors' names, Rivest, Shamir, and Adleman. The security of this system hinges on the difficulty of factoring large numbers into constituent primes.

=== Diffie-Hellman-Merkle Key Agreement (aka Diffie-Hellman or DH)

The Diffie-Hellman-Merkle Key Agreement protocol (more commonly called simply Diffie-Hellman or DH) provides a method to have two parties agree on a common set of secret bits that can be used as a symmetric key, based on the use of finite field arithmetic.

DH techniques are used in many of the Internet-related security protocols <<RFC2631>> and are closely related to the RSA approach for public key cryptography.

=== Signcryption and Elliptic Curve Cryptography (ECC)

When using RSA, additional security is provided with larger numbers. However, the basic mathematical operations required by RSA (e.g., exponentiation) can be computationally intensive and scale as the numbers grow. Reducing the effort of combining digital signatures and encryption for confidentiality, a class of *sign-cryption* schemes (also called *authenticated encryption*) provides both features at a cost less than the sum of the two if computed separately. However, even greater efficiency can sometimes be achieved by changing the mathematical basis for public key cryptography.

In a continuing search for security with greater efficiency and performance, researchers have explored other public key cryptosystems beyond RSA. An alternative based on the difficulty of finding the discrete logarithm of an *elliptic curve* element has emerged, known as *elliptic curve cryptography* (ECC, not to be confused with _error-correcting code_).

For equivalent security, ECC offers the benefit of using keys that are considerably smaller than those of RSA (e.g., by about a factor of 6 for a 1024-bit RSA modulus). This leads to simpler and faster implementations, issues of considerable practical concern.

ECC has been standardized for use in many of the applications where RSA still retains dominance, but adoption has remained somewhat sluggish because of patents on ECC technology held by the Certicom Corporation. (The RSA algorithm was also patented, but patent protection lapsed in the year 2000.)

=== Key Derivation and Perfect Forward Secrecy (PFS)

In communication scenarios where multiple messages are to be exchanged, it is common to establish a short-term session key to perform symmetric encryption.

The session key is ordinarily a random number generated by a function called a *key derivation function* (KDF), based on some input such as a master key or a previous session key. If a session key is compromised, any of the data encrypted with the key is subject to compromise. However, it is common practice to change keys (*_rekey_*) multiple times during an extended communication session.

A scheme in which the compromise of one session key keeps future communications secure is said to have *perfect forward secrecy* (PFS). Usually, schemes that provide PFS require additional key exchanges or verifications that introduce overhead. One example is the STS protocol for DH mentioned earlier.

=== Pseudorandom Numbers, Generators, and Function Families

In cryptography, random numbers are often used as initial input values to cryptographic functions, or for generating keys that are difficult to guess. Given that computers are not very random by nature, obtaining true random numbers is somewhat difficult. The numbers used in most computers for simulating randomness are called *pseudorandom numbers*. Such numbers are not usually truly random but instead exhibit a number of statistical properties that suggest that they are (e.g., when many of them are generated, they tend to be uniformly distributed across some range). Pseudorandom numbers are produced by an algorithm or device known as a *pseudorandom number generator* (PRNG) or *pseudorandom generator* (PRG), depending on the author.

Simple PRNGs are deterministic. That is, they have a small amount of internal state initialized by a *_seed_* value. Once the internal state is known, the sequence of PNs can be determined.

For example, the common _Linear Congruential Generator_ (LCG) algorithm produces random-appearing values that are entirely predictable if the input parameters are known or guessed. Consequently, LCGs are perfectly fine for use in certain programs (e.g., games that simulate random events) but insufficient for cryptographic purposes.

A *pseudorandom function family* (PRF) is a family of functions that appear to be algorithmically indistinguishable (by polynomial time algorithms) from truly random functions. A PRF is a stronger concept than a PRG, as a PRG can be created from a PRF.

PRFs are the basis for *_cryptographically strong_* (or secure) pseudorandom number generators, called CSPRNGs. CSPRNGs are necessary in cryptographic applications for several purposes, including session key generation, for which a sufficient amount of randomness must be guaranteed <<RFC4086>>.

=== Nonces and Salt

A *cryptographic nonce* is a number that is used once (or for one transaction) in a cryptographic protocol. Most commonly, a nonce is a random or pseudorandom number that is used in authentication protocols to ensure *_freshness_*. Freshness is the (desirable) property that a message or operation has taken place in the very recent past.

For example, in a *_challenge-response_* protocol, a server may provide a requesting client with a nonce, and the client may need to respond with authentication material as well as a copy of the nonce (or perhaps an encrypted copy of the nonce) within a certain period of time. This helps to avoid replay attacks, because old authentication exchanges that are replayed to the server would not contain the correct nonce value.

A *salt* or salt value, used in the cryptographic context, is a random or pseudorandom number used to frustrate *_brute-force_* attacks on secrets. Brute-force attacks usually involve repeatedly guessing a password, passphrase, key, or equivalent secret value and checking to see if the guess was correct. Salts work by frustrating the checking portion of a brute-force attack.

The best-known example is the way passwords used to be handled in the UNIX system. Users' passwords were encrypted and stored in a password file that all users could read. When logging in, each user would provide a password that was used to double encrypt a fixed value. The result was then compared against the user's entry in the password file. A match indicated that a correct password was provided.

At the time, the encryption method (DES) was well known and there was concern that a hardware-based *_dictionary attack_* would be possible whereby many words from a dictionary were encrypted with DES ahead of time (forming a *_rainbow table_*) and compared against the password file. A pseudorandom 12-bit salt was added to perturb the DES algorithm in one of 4096 (nonstandard) ways for each password in an effort to thwart this attack. Ultimately, the 12-bit salt was determined to be insufficient with improved computers (that could guess more values) and was expanded.

NOTE: However, there are limitations in the protections that a salt can provide. If the attacker is hitting an online service with a credential stuffing attack, a subset of the brute force attack category, salts won't help at all because the legitimate server is doing the salting+hashing for you. <<auth0-salt-hasing>>

=== Cryptographic Hash Functions and Message Digests

In most of the protocols, including Ethernet, IP, ICMP, UDP, and TCP, we have seen the use of a frame check sequence (FCS, either a checksum or a CRC) to determine whether a PDU has likely been delivered without bit errors. When considering security, ordinary FCS functions are not sufficient for this purpose.

A checksum or FCS can be used to verify message integrity if properly constructed using special functions, which are called *cryptographic hash functions*.

* The output of a cryptographic hash function _H_, when provided a message _M_, is called the *digest* or *fingerprint* of the message, _H(M)_.

* A message digest is a type of strong FCS that is easy to compute and has the following important properties:
+
--
* Preimage resistance: Given _H(M)_, it should be difficult to determine _M_ if not already known.

* Second preimage resistance: Given _H(M1)_, it should be difficult to determine an _M2 ≠ M1_ such that _H(M1) = H(M2)_.

* Collision resistance: It should be difficult to find any pair _M1_, _M2_ where _H(M1) = H(M2)_ when _M2 ≠ M1_.
--
+
If a hash function has all of these properties, then if two messages have the same cryptographic hash value, they are, with negligible doubt, the same message. The two most common cryptographic hash algorithms are at present the _Message Digest Algorithm 5_ (*_MD5_*, <<RFC1321>>), which produces a 128-bit (16-byte) digest, and the _Secure Hash Algorithm 1_ (*_SHA-1_*), which produces a 160-bit (20-byte) digest.
+
More recently, a family of functions based on SHA called *_SHA-2_* <<RFC6234>> produce digests with lengths of 224, 256, 384, or 512 bits (28, 32, 48, and 64 bytes, respectively). Others are under development.

[NOTE]
====
Cryptographic hash functions are often based on a compression function _f_, which takes an input of length _L_ and produces a collision-resistant but deterministic output of size less than _L_. The Merkle-Damgård construction, which essentially breaks an arbitrarily long input into blocks of length _L_, pads them, passes them to _f_, and combines the results, produces a cryptographic hash function capable of taking a long input and producing an output with collision resistance.
====

=== Message Authentication Codes (MACs, HMAC, CMAC, and GMAC)

A _message authentication code_ (unfortunately abbreviated *MAC* or sometimes *MIC* but unrelated to the link-layer MAC addresses) can be used to ensure message integrity and authentication.

MACs are usually based on *_keyed cryptographic hash functions_*, which are like _message digest algorithms_ but require a _private key_ to produce or verify the integrity of a message and may also be used to verify (authenticate) the message's sender.

MACs require resistance to various forms of *_forgery_*.

* For a given keyed hash function _H(M,K)_ taking input message _M_ and key _K_, resistance to *_selective forgery_* means that it is difficult for an adversary not knowing _K_ to form _H(M,K)_ given a specific _M_.
* _H(M,K)_ is resistant to *_existential forgery_* if it is difficult for an adversary lacking _K_ to find any previously unknown valid combination of _M_ and _H(M,K)_.

NOTE: Note that MACs do not provide exactly the same features as digital signatures. For example, they cannot be a solid basis for nonrepudiation because the secret key is known to more than one party.

A standard MAC that uses _cryptographic hash functions_ in a particular way is called the _keyed-hash message authentication code_ (*HMAC*) <<FIPS198>><<RFC2104>>.

* The HMAC "algorithm" uses a generic cryptographic hash algorithm, say _H(M)_.

* To form a _t_-byte HMAC on message _M_ with key _K_ using _H_ (called _HMAC-H_), we use the following definition:
+
[.text-center,subs="+quotes"]
----
_HMAC-H (K, M)t = Λt (H((K ⊕ opad)||H((K ⊕ ipad)||M)))_
----
+
In this definition, `opad` (outer pad) is an array containing the value `0x5C` repeated `|K|` times, and `ipad` (inner pad) is an array containing the value `0x36` repeated `|K|` times. `⊕` is the vector XOR operator, and `||` is the concatenation operator.
+
Normally the HMAC output is intended to be a certain number `t` of bytes in length, so the operator `Λt(M)` takes the left-most `t` bytes of `M`.

More recently, other forms of MACs have been standardized, called the _cipher-based MAC_ (*CMAC*) <<FIPS800-38B>> and *GMAC* <<NIST800-38D>>. Instead of using a cryptographic hash function such as HMAC, these use a block cipher such as AES or 3DES. CMAC is envisioned for use in environments where it is more convenient or efficient to use a block cipher in place of a hash function.

=== Cryptographic Suites and Cipher Suites

The combination of the mathematical or cryptographic techniques used in a particular system, especially the Internet protocols, are called a *cryptographic suite* or sometimes a *cipher suite*, although the first term is more accurate. A cryptographic suite defines not only an enciphering (encryption) algorithm but may also include a particular MAC algorithm, PRF, key agreement algorithm, signature algorithm, and associated key lengths and parameters.

Usually, an _encryption algorithm_ is specified by its name and description, how many bits are used for its keys (often a multiple of 128 bits), along with its operating *_mode_*. Encryption algorithms that have been standardized for use with Internet protocols include AES, 3DES, NULL [RFC2410], and CAMELLIA [RFC3713]. The NULL encryption algorithm does not modify the input and is used in certain circumstances where confidentiality is not required.

The operating *mode* of an encryption algorithm, especially a block cipher, describes how to use the encryption function for a single block repeatedly (e.g., in a cascade) to encrypt or decrypt an entire message with a single key. Common modes today include _cipher block chaining_ (*CBC*) and _counter_ (*CTR*) mode, although many others have been defined.

* When performing encryption using CBC mode, a cleartext block to be encrypted is first XORed with the previous ciphertext block (the first block is XORed with a random _initialization vector_ or *IV*).

* Encrypting in CTR mode involves first creating a value combining a nonce (or IV) and a counter that increments with each successive block to be encrypted.
+
The combination is then encrypted, the output is XORed with a cleartext block to produce a ciphertext block, and the process repeats for successive blocks.
+
In effect, this approach uses a block cipher to produce a *keystream*, a sequence of (random-appearing) bits that are combined (e.g., XORed) with cleartext bits to produce a ciphertext. Doing so essentially converts a block cipher into a stream cipher because no explicit padding of the input is required.

* CBC requires a serial process for encryption and a partly serial process for decryption, whereas counter mode algorithms allow more efficient fully parallel encryption and decryption implementations. Consequently, counter mode is gaining popularity.

In addition, variants of CTR mode (e.g., counter mode with CBC-MAC (CCM), Galois Counter Mode, or GCM) can be used for authenticated encryption [RFC4309], and possibly to authenticate (but not encrypt) additional data (called _authenticated encryption with associated data_ or *AEAD*) [RFC5116].

When an encryption algorithm is specified as part of a cryptographic suite, its name usually includes the mode, and the key length is often implied. For example, ENCR_AES_CTR refers to AES-128 used in CTR mode.

When a PRF is included in the definition of a cryptographic suite, it is usually based on a cryptographic hash algorithm family such as SHA-2 [RFC6234] or a cryptographic MAC such as CMAC [RFC4434][RFC4615]. For example, the algorithm AES-CMAC-PRF-128 refers to a PRF constructed using a CMAC based on AES-128. It is also written as PRF_AES128_CMAC. The algorithm PRF_HMAC_SHA1 refers to a PRF based on HMAC-SHA1.

_Key agreement_ parameters, when included with an Internet cryptographic suite definition, refer to DH group definitions, as no other key agreement protocol is in widespread use. When DH key agreement is used in generating keys for a particular encryption algorithm, care must be taken to ensure that the keys produced are of sufficient length (strength) to avoid compromising the security of the encryption algorithm.

A _signature algorithm_ is sometimes included in the definition of a cryptographic suite. It may be used for signing a variety of values including data, MACs, and DH values. The most common is to use RSA to sign a hashed value for some block of data, although the _digital signature standard_ (written as DSS or DSA to indicate the digital signature algorithm) [FIPS186-3] is also used in some circumstances. With the advent of ECC, signatures based on elliptic curves (e.g., ECDSA [X9.62-
2005]) are also now supported in many systems.

The concept of a cryptographic suite evolved in the context of Internet security protocols because of a need for modularity and decoupled evolution. As computational power has improved, older cryptographic algorithms and smaller key lengths have fallen victim to various forms of brute-force attacks. In some cases, more sophisticated attacks have revealed flaws that necessitate the replacement of the underlying mathematical and cryptographic methods, but the basic protocol machinery is otherwise sound. As a result, the choice of a cryptographic suite can now be made separately from the communication protocol details and depends on factors such as convenience, performance, and security. Protocols tend to make use of the components of a cryptographic suite in a standard way, so an appropriate cryptographic suite can be “snapped in” when deemed appropriate.












[bibliography]
== References

* [[[TCPIPV1,1]]] Kevin Fall, W. Stevens _TCP/IP Illustrated: The Protocols, Volume 1_. 2nd edition, Addison-Wesley Professional, 2011
* [[[auth0-salt-hasing,2]]] https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/
* [[[FIPS186-3]]] National Institute for Standards and Technology, “Digital Signature Standard (DSS),” FIPS PUB 186-3, June 2009.
* [[[FIPS198]]] National Institute for Standards and Technology, “The Keyed-Hash Message Authentication Code (HMAC),” FIPS PUB 198, Mar. 2002.
* [[[FIPS800-38B]]] National Institute for Standards and Technology, “Recommendation for Block Cipher Modes of Operation: The CMAC Mode for Authentication,”NIST Special Publication 800-38B, May 2005.
* [[[NIST800-38D]]] National Institute for Standards and Technology, “Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC,” NIST Special Publication 800-38D, Nov. 2005.
* [[[RFC1321]]] R. Rivest, “The MD5 Message-Digest Algorithm,” Internet RFC 1321 (informational), Apr. 1992.
* [[[RFC2104]]] H. Krawczyk, M. Bellare, and R. Canetti, “HMAC: Keyed-Hashing for Message Authentication,” Internet RFC 2104 (informational), Feb. 1997.
* [[[RFC2631]]] E. Rescorla, “Diffie-Hellman Key Agreement Method,” Internet RFC 2631, June 1999.
* [[[RFC4086]]] D. Eastlake 3rd, J. Schiller, and S. Crocker, “Randomness Requirements for Security,” Internet RFC 4086/BCP 0106, June 2005.
* [[[RFC6234]]] D. Eastlake 3rd and T. Hansen, “US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF),” Internet RFC 6234 (informational), May 2011.
