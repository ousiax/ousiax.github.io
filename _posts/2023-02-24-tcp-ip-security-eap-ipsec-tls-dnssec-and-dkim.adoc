= TCP/IP: Security: EAP, IPsec, TLS, DNSSEC, and DKIM
:page-layout: post
:page-categories: ['networking']
:page-tags: ['networking', 'tcp']
:page-date: 2023-02-24 08:27:23 +0800
:page-revdate: 2023-07-24 08:27:23 +0800
:toc: preamble
:toclevels: 4
:sectnums:
:sectnumlevels: 4

There are three primary properties of information, whether in a computer network or not, that may be desirable from an information security point of view: confidentiality, integrity, and availability (the CIA triad) [L01], summarized here:

* *Confidentiality* means that information is made known only to its intended users (which could include processing systems).
* *Integrity* means that information has not been modified in an unauthorized way before it is delivered.
* *Availability* means that information is available when needed.

These are core properties of information, yet there are other properties we may also desire, including _authentication_, _nonrepudiation_, and _auditability_.

* *Authentication* means that a particular identified party or principal is not impersonating another principal.

* *Nonrepudiation* means that if some action is performed by a principal (e.g., agreeing to the terms of a contract), this fact can be proven later (i.e., cannot successfully be denied).

* *Auditability* means that some sort of trustworthy log or accounting describing how information has been used is available.
+
Such logs are often important for forensic (i.e., legal and prosecuritorial) purposes.

These principles are applicable to information in physical (e.g., printed) form, for which mechanisms such as safes, secured facilities, and guards have been used for thousands of years to enforce controlled sharing, storage, and dissemination. When information is to be moved through an unsecured environment, additional techniques are required.

== Threats to Network Communication

Attacks can generally be categorized as either passive or active.

* *Passive attacks* are mounted by monitoring or eavesdropping on the contents of network traffic, and if not handled they can lead to unauthorized release of information (loss of confidentiality).

* *Active attacks* can cause modification of information (with possible loss of integrity) or denial of service (loss of availability).
+
Logically, such attacks are carried out by an "intruder" or adversary.

.The principals, Alice and Bob, attempt to communicate securely, but Eve may eavesdrop and Mallory may modify messages in transit.
image::/assets/tcp-ip/security/passive-active-attacks.jpg[Passive and active attacks,50%,50%]

Eve is able to eavesdrop (listen in on, also called _capture_ or _sniff_) and perform *_traffic analysis_* on the traffic passing between Alice and Bob.

* Capturing the traffic could lead to compromise of confidentiality, as sensitive data may be available to Eve without Alice or Bob knowing.
+
In addition, traffic analysis can determine the features of the traffic, such as its size and when it is sent, and possibly identify the parties to a communication. This information, although it does not reveal the exact contents of the communication, could also lead to disclosure of sensitive information and could be used to mount more powerful active attacks in the future.

While the passive attacks are essentially impossible for Alice or Bob to detect, Mallory is capable of performing more easily noticed active attacks. These include
_message stream modification_ (MSM), _denial-of-service_ (DoS), and _spurious association_ attacks.

* MSM attacks (including so-called called *_man-in-the-middle_* or MITM_attacks) are a broad category and include any way traffic is modified in transit, including deletion, reordering, and content modification.

* DoS might include deletion of traffic, or generation of such large volumes of traffic so as to overwhelm Alice, Bob, or the communication channel connecting them.

* Spurious associations include *_masquerading_* (Mallory pretends to be Bob or Alice) and replay, whereby Alice or Bob’s earlier (authentic) communications are replayed later, from Mallory's memory.

.Attacks on communication are broadly classified as passive or active. Passive attacks are ordinarily more difficult to detect, and active attacks are ordinarily more difficult to prevent.
[%header,cols="1,1,1,1"]
|===
2+|Passive
2+|Active

h|Type
h|Threats
h|Type
h|Threats

|Eavesdropping
|Confidentiality
|Message stream modification
|Authenticity, integrity

|Traffic analysis
|Confidentiality
|Denial of service (DoS)
|Availability

|
|
|Spurious association
|Authenticity

|===

With effective and careful use of *cryptography*, passive attacks are rendered ineffective, and active attacks are made detectable (and to some degree preventable).

== Basic Cryptography and Security Mechanisms

Cryptography evolved from the desire to protect the confidentiality, integrity, and authenticity of information carried through unsecured communication channels.

The use of cryptography, at least in a primitive form, dates back to at least 3500 BCE. The earliest systems were usually *codes*.

Codes involve substitutions of groups of words, phrases, or sentences with groups of numbers or letters as given in a codebook. Codebooks needed to be kept secret in order to keep communications private, so distributing them required considerable care.

More advanced systems used *ciphers*, in which both substitution and rearrangement are used.

=== Cryptosystems

.The unencrypted (cleartext) message is passed through an encryption algorithm to produce an encrypted (ciphertext) message. In a symmetric cryptosystem, the same (secret) key is used for encryption and decryption. In an asymmetric or public key cryptosystem, confidentiality is achieved by using the recipient's public key for encryption and private (secret) key for decryption.
image::/assets/tcp-ip/security/symmetric-asymmetric-cryptosystem.png[Symmetric and asymmetric key cryptosystem,50%,50%]

* In each case, a *cleartext* message is processed by an encryption algorithm to produce *ciphertext* (scrambled text).

* The *key* is a particular sequence of bits used to drive the *encryption algorithm* or cipher.

* With different keys, the same input produces different outputs. Combining the algorithms with supporting protocols and operating methods forms a *cryptosystem*.

* In a *symmetric cryptosystem*, the encryption and decryption keys are typically identical, as are the encryption and decryption algorithms.

* In an *asymmetric cryptosystem*, each principal is generally provided with a *pair* of keys consisting of one public and one private key.
+
The public key is intended to be known to any party that might want to send a message to the key pair's owner.
+
The public and private keys are mathematically related and are themselves outputs of a *key generation* algorithm.

Without knowing the symmetric key (in a symmetric cryptosystem) or the private key (in a public key cryptosystem), it is (believed to be) effectively impossible
for any third party that intercepts the ciphertext to produce the corresponding cleartext. This provides the basis for confidentiality.

For the symmetric key cryptosystem, it also provides a degree of authentication, because only a party holding the key is able to produce a useful ciphertext that can be decrypted to something sensible.

* A receiver can decrypt the ciphertext, look for a portion of the resulting cleartext to contain a particular agreed-upon value, and conclude that the sender holds the appropriate key and is therefore authentic.

* Furthermore, most encryption algorithms work in such a way that if messages are modified in transit, they are unable to produce useful cleartext upon decryption.

Thus, symmetric cryptosystems provide a measure of both authentication and integrity protection for messages, but this approach alone is weak. Instead, special forms of checksums are usually coupled with symmetric cryptography to ensure integrity.

A symmetric encryption algorithm is usually classified as either a *block cipher* or a *stream cipher*.

* Block ciphers perform operations on a fixed number of bits (e.g., 64 or 128) at a time,

* and stream ciphers operate continuously on however many bits (or bytes) are provided as input.

For years, the most popular symmetric encryption algorithm was the *_Data Encryption Standard_* (DES), a block cipher that uses 64-bit blocks and 56-bit keys.

Eventually, the use of 56-bit keys was felt to be insecure, and many applications turned to *_triple_*-_DES_ (also denoted 3DES or TDES—applying DES three times with two or three different keys to each block of data).

Today, DES and 3DES have been largely phased out in favor of the *_Advanced Encryption Standard_* (AES), also known occasionally by its original name the _Rijndael_ algorithm (pronounced “rain-dahl”), in deference to its Belgian cryptographer inventors Vincent Rijmen and Joan Daemen.

Different variants of AES provide key lengths of 128, 192, and 256 bits and are usually written with the corresponding extension (i.e., AES-128, AES-192, and AES-256).

Asymmetric cryptosystems have some additional interesting properties beyond those of symmetric key cryptosystems.

. Assuming we have Alice as sender and Bob as intended recipient, any third party is assumed to know Bob's public key and can therefore send him a secret message—only Bob is able to decrypt it because only Bob knows the private key corresponding to his public key.

. However, Bob has no real assurance that the message is authentic, because any party can create a message and send it to Bob, encrypted in Bob's public key.

. Fortunately, public key cryptosystems also provide another function when used in reverse: authentication of the sender.

. In this case, Alice can encrypt a message using her private key and send it to Bob (or anyone else).

. Using Alice's public key (known to all), anyone can verify that the message was authored by Alice and has not been modified.

. However, it is not confidential because everyone has access to Alice's public key.

. To achieve authenticity, integrity, and confidentiality, Alice can encrypt a message using her private key and encrypt the result using Bob's public key.

. The result is a message that is reliably authored by Alice and is also confidential to Bob.
+
.The asymmetric cryptosystem can be used for confidentiality (encryption), authentication (digital signatures or signing), or both. When used for both, it produces a signed output that is confidential to the sender and the receiver. Public keys, as their name suggests, are not kept secret.
image::/assets/tcp-ip/security/asymmetric-cryptosystem.png[Asymmetric (Public Key) Cryptosystem,50%,50%]

When public key cryptography is used in "reverse" like this, it provides a *digital signature*.

* Digital signatures are important consequences of public key cryptography and can be used to help ensure authenticity and nonrepudiation.

* Only a party possessing Alice’s private key is able to author messages or carry out transactions as Alice.

In a *_hybrid_* cryptosystem, elements of both public key and symmetric key cryptography are used.

* Most often, public key operations are used to exchange a randomly generated confidential (symmetric) *session key*, which is used to encrypt traffic for a single transaction using a symmetric algorithm.

* The reason for doing so is performance—symmetric key operations are less computationally intensive than public key operations.

* Most systems today are of the hybrid type: public key cryptography is used to establish keys used for symmetric encryption of individual sessions.

=== Rivest, Shamir, and Adleman (RSA) Public Key Cryptography

The most common approach used for both digital signatures and confidentiality is called RSA in deference to its authors' names, Rivest, Shamir, and Adleman. The security of this system hinges on the difficulty of factoring large numbers into constituent primes.

=== Diffie-Hellman-Merkle Key Agreement (aka Diffie-Hellman or DH)

The Diffie-Hellman-Merkle Key Agreement protocol (more commonly called simply Diffie-Hellman or DH) provides a method to have two parties agree on a common set of secret bits that can be used as a symmetric key, based on the use of finite field arithmetic.

DH techniques are used in many of the Internet-related security protocols <<RFC2631>> and are closely related to the RSA approach for public key cryptography.

=== Signcryption and Elliptic Curve Cryptography (ECC)

When using RSA, additional security is provided with larger numbers. However, the basic mathematical operations required by RSA (e.g., exponentiation) can be computationally intensive and scale as the numbers grow. Reducing the effort of combining digital signatures and encryption for confidentiality, a class of *sign-cryption* schemes (also called *authenticated encryption*) provides both features at a cost less than the sum of the two if computed separately. However, even greater efficiency can sometimes be achieved by changing the mathematical basis for public key cryptography.

In a continuing search for security with greater efficiency and performance, researchers have explored other public key cryptosystems beyond RSA. An alternative based on the difficulty of finding the discrete logarithm of an *elliptic curve* element has emerged, known as *elliptic curve cryptography* (ECC, not to be confused with _error-correcting code_).

For equivalent security, ECC offers the benefit of using keys that are considerably smaller than those of RSA (e.g., by about a factor of 6 for a 1024-bit RSA modulus). This leads to simpler and faster implementations, issues of considerable practical concern.

ECC has been standardized for use in many of the applications where RSA still retains dominance, but adoption has remained somewhat sluggish because of patents on ECC technology held by the Certicom Corporation. (The RSA algorithm was also patented, but patent protection lapsed in the year 2000.)

=== Key Derivation and Perfect Forward Secrecy (PFS)

In communication scenarios where multiple messages are to be exchanged, it is common to establish a short-term session key to perform symmetric encryption.

The session key is ordinarily a random number generated by a function called a *key derivation function* (KDF), based on some input such as a master key or a previous session key. If a session key is compromised, any of the data encrypted with the key is subject to compromise. However, it is common practice to change keys (*_rekey_*) multiple times during an extended communication session.

A scheme in which the compromise of one session key keeps future communications secure is said to have *perfect forward secrecy* (PFS). Usually, schemes that provide PFS require additional key exchanges or verifications that introduce overhead. One example is the STS protocol for DH mentioned earlier.

=== Pseudorandom Numbers, Generators, and Function Families

In cryptography, random numbers are often used as initial input values to cryptographic functions, or for generating keys that are difficult to guess. Given that computers are not very random by nature, obtaining true random numbers is somewhat difficult. The numbers used in most computers for simulating randomness are called *pseudorandom numbers*. Such numbers are not usually truly random but instead exhibit a number of statistical properties that suggest that they are (e.g., when many of them are generated, they tend to be uniformly distributed across some range). Pseudorandom numbers are produced by an algorithm or device known as a *pseudorandom number generator* (PRNG) or *pseudorandom generator* (PRG), depending on the author.

Simple PRNGs are deterministic. That is, they have a small amount of internal state initialized by a *_seed_* value. Once the internal state is known, the sequence of PNs can be determined.

For example, the common _Linear Congruential Generator_ (LCG) algorithm produces random-appearing values that are entirely predictable if the input parameters are known or guessed. Consequently, LCGs are perfectly fine for use in certain programs (e.g., games that simulate random events) but insufficient for cryptographic purposes.

A *pseudorandom function family* (PRF) is a family of functions that appear to be algorithmically indistinguishable (by polynomial time algorithms) from truly random functions. A PRF is a stronger concept than a PRG, as a PRG can be created from a PRF.

PRFs are the basis for *_cryptographically strong_* (or secure) pseudorandom number generators, called CSPRNGs. CSPRNGs are necessary in cryptographic applications for several purposes, including session key generation, for which a sufficient amount of randomness must be guaranteed <<RFC4086>>.

=== Nonces and Salt

A *cryptographic nonce* is a number that is used once (or for one transaction) in a cryptographic protocol. Most commonly, a nonce is a random or pseudorandom number that is used in authentication protocols to ensure *_freshness_*. Freshness is the (desirable) property that a message or operation has taken place in the very recent past.

For example, in a *_challenge-response_* protocol, a server may provide a requesting client with a nonce, and the client may need to respond with authentication material as well as a copy of the nonce (or perhaps an encrypted copy of the nonce) within a certain period of time. This helps to avoid replay attacks, because old authentication exchanges that are replayed to the server would not contain the correct nonce value.

A *salt* or salt value, used in the cryptographic context, is a random or pseudorandom number used to frustrate *_brute-force_* attacks on secrets. Brute-force attacks usually involve repeatedly guessing a password, passphrase, key, or equivalent secret value and checking to see if the guess was correct. Salts work by frustrating the checking portion of a brute-force attack.

The best-known example is the way passwords used to be handled in the UNIX system. Users' passwords were encrypted and stored in a password file that all users could read. When logging in, each user would provide a password that was used to double encrypt a fixed value. The result was then compared against the user's entry in the password file. A match indicated that a correct password was provided.

At the time, the encryption method (DES) was well known and there was concern that a hardware-based *_dictionary attack_* would be possible whereby many words from a dictionary were encrypted with DES ahead of time (forming a *_rainbow table_*) and compared against the password file. A pseudorandom 12-bit salt was added to perturb the DES algorithm in one of 4096 (nonstandard) ways for each password in an effort to thwart this attack. Ultimately, the 12-bit salt was determined to be insufficient with improved computers (that could guess more values) and was expanded.

NOTE: However, there are limitations in the protections that a salt can provide. If the attacker is hitting an online service with a credential stuffing attack, a subset of the brute force attack category, salts won't help at all because the legitimate server is doing the salting+hashing for you. <<auth0-salt-hasing>>

=== Cryptographic Hash Functions and Message Digests

In most of the protocols, including Ethernet, IP, ICMP, UDP, and TCP, we have seen the use of a frame check sequence (FCS, either a checksum or a CRC) to determine whether a PDU has likely been delivered without bit errors. When considering security, ordinary FCS functions are not sufficient for this purpose.

A checksum or FCS can be used to verify message integrity if properly constructed using special functions, which are called *cryptographic hash functions*.

* The output of a cryptographic hash function _H_, when provided a message _M_, is called the *digest* or *fingerprint* of the message, _H(M)_.

* A message digest is a type of strong FCS that is easy to compute and has the following important properties:
+
--
* Preimage resistance: Given _H(M)_, it should be difficult to determine _M_ if not already known.

* Second preimage resistance: Given _H(M1)_, it should be difficult to determine an _M2 ≠ M1_ such that _H(M1) = H(M2)_.

* Collision resistance: It should be difficult to find any pair _M1_, _M2_ where _H(M1) = H(M2)_ when _M2 ≠ M1_.
--
+
If a hash function has all of these properties, then if two messages have the same cryptographic hash value, they are, with negligible doubt, the same message. The two most common cryptographic hash algorithms are at present the _Message Digest Algorithm 5_ (*_MD5_*, <<RFC1321>>), which produces a 128-bit (16-byte) digest, and the _Secure Hash Algorithm 1_ (*_SHA-1_*), which produces a 160-bit (20-byte) digest.
+
More recently, a family of functions based on SHA called *_SHA-2_* <<RFC6234>> produce digests with lengths of 224, 256, 384, or 512 bits (28, 32, 48, and 64 bytes, respectively). Others are under development.

[NOTE]
====
Cryptographic hash functions are often based on a compression function _f_, which takes an input of length _L_ and produces a collision-resistant but deterministic output of size less than _L_. The Merkle-Damgård construction, which essentially breaks an arbitrarily long input into blocks of length _L_, pads them, passes them to _f_, and combines the results, produces a cryptographic hash function capable of taking a long input and producing an output with collision resistance.
====

=== Message Authentication Codes (MACs, HMAC, CMAC, and GMAC)

A _message authentication code_ (unfortunately abbreviated *MAC* or sometimes *MIC* but unrelated to the link-layer MAC addresses) can be used to ensure message integrity and authentication.

MACs are usually based on *_keyed cryptographic hash functions_*, which are like _message digest algorithms_ but require a _private key_ to produce or verify the integrity of a message and may also be used to verify (authenticate) the message's sender.

MACs require resistance to various forms of *_forgery_*.

* For a given keyed hash function _H(M,K)_ taking input message _M_ and key _K_, resistance to *_selective forgery_* means that it is difficult for an adversary not knowing _K_ to form _H(M,K)_ given a specific _M_.
* _H(M,K)_ is resistant to *_existential forgery_* if it is difficult for an adversary lacking _K_ to find any previously unknown valid combination of _M_ and _H(M,K)_.

NOTE: Note that MACs do not provide exactly the same features as digital signatures. For example, they cannot be a solid basis for nonrepudiation because the secret key is known to more than one party.

A standard MAC that uses _cryptographic hash functions_ in a particular way is called the _keyed-hash message authentication code_ (*HMAC*) <<FIPS198>><<RFC2104>>.

* The HMAC "algorithm" uses a generic cryptographic hash algorithm, say _H(M)_.

* To form a _t_-byte HMAC on message _M_ with key _K_ using _H_ (called _HMAC-H_), we use the following definition:
+
[.text-center,subs="+quotes"]
----
_HMAC-H (K, M)t = Λt (H((K ⊕ opad)||H((K ⊕ ipad)||M)))_
----
+
In this definition, `opad` (outer pad) is an array containing the value `0x5C` repeated `|K|` times, and `ipad` (inner pad) is an array containing the value `0x36` repeated `|K|` times. `⊕` is the vector XOR operator, and `||` is the concatenation operator.
+
Normally the HMAC output is intended to be a certain number `t` of bytes in length, so the operator `Λt(M)` takes the left-most `t` bytes of `M`.

More recently, other forms of MACs have been standardized, called the _cipher-based MAC_ (*CMAC*) <<FIPS800-38B>> and *GMAC* <<NIST800-38D>>. Instead of using a cryptographic hash function such as HMAC, these use a block cipher such as AES or 3DES. CMAC is envisioned for use in environments where it is more convenient or efficient to use a block cipher in place of a hash function.

=== Cryptographic Suites and Cipher Suites

The combination of the mathematical or cryptographic techniques used in a particular system, especially the Internet protocols, defines not only an enciphering (encryption) algorithm but may also include a particular MAC algorithm, PRF (_pseudorandom function family_), key agreement algorithm, signature algorithm, and associated key lengths and parameters, are called a *cryptographic suite* or sometimes a *cipher suite*, although the first term is more accurate.

> From Wikipedia, the free encyclopedia
> 
> A *_cipher suite_* is a set of algorithms that help secure a network connection. Suites typically use Transport Layer Security (TLS) or its now-deprecated predecessor Secure Socket Layer (SSL). The set of algorithms that cipher suites usually contain include: a key exchange algorithm, a bulk encryption algorithm, and a message authentication code (MAC) algorithm. <<wiki_cipher_suite>>
> 
> The _key exchange algorithm_ is used to exchange a key between two devices. This key is used to encrypt and decrypt the messages being sent between two machines. The _bulk encryption algorithm_ is used to encrypt the data being sent. The _MAC algorithm_ provides data integrity checks to ensure that the data sent does not change in transit. In addition, cipher suites can include _signatures and an authentication algorithm_ to help authenticate the server and or client. 

Usually, an _encryption algorithm_ is specified by its name and description, how many bits are used for its keys (often a multiple of 128 bits), along with its operating _mode_.

* Encryption algorithms that have been standardized for use with Internet protocols include AES, 3DES, NULL <<RFC2410>>, and CAMELLIA <<RFC3713>>.
+
The NULL encryption algorithm does not modify the input and is used in certain circumstances where confidentiality is not required.

* The _operating_ *_mode_* of an encryption algorithm, especially a block cipher, describes how to use the encryption function for a single block repeatedly (e.g., in a cascade) to encrypt or decrypt an entire message with a single key.
+
--
* When performing encryption using CBC (*_cipher block chaining_*) mode, a cleartext block to be encrypted is first XORed with the previous ciphertext block (the first block is XORed with a random *_initialization vector_* or *IV*).

* Encrypting in CTR (*_counter_*) mode involves first creating a value combining a nonce (or IV) and a counter that increments with each successive block to be encrypted.
+
The combination is then encrypted, the output is XORed with a cleartext block to produce a ciphertext block, and the process repeats for successive blocks.
+
In effect, this approach uses a block cipher to produce a *keystream*, a sequence of (random-appearing) bits that are combined (e.g., XORed) with cleartext bits to produce a ciphertext. Doing so essentially converts a block cipher into a stream cipher because no explicit padding of the input is required.

* CBC requires a serial process for encryption and a partly serial process for decryption, whereas counter mode algorithms allow more efficient fully parallel encryption and decryption implementations. Consequently, counter mode is gaining popularity.

* In addition, variants of CTR mode (e.g., counter mode with CBC-MAC (CCM), Galois Counter Mode, or GCM) can be used for authenticated encryption [RFC4309], and possibly to authenticate (but not encrypt) additional data (called _authenticated encryption with associated data_ or *AEAD*) <<RFC5116>>.

* When an encryption algorithm is specified as part of a cryptographic suite, its name usually includes the mode, and the key length is often implied.
+
> For example, ENCR_AES_CTR refers to AES-128 used in CTR mode.
--

When a PRF (_pseudorandom function family_) is included in the definition of a cryptographic suite, it is usually based on a cryptographic hash algorithm family such as SHA-2 <<RFC6234>> or a cryptographic MAC such as CMAC <<RFC4434>><<RFC4615>>.

> For example, the algorithm AES-CMAC-PRF-128 refers to a PRF constructed using a CMAC based on AES-128. It is also written as PRF_AES128_CMAC. The algorithm PRF_HMAC_SHA1 refers to a PRF based on HMAC-SHA1.

*_Key agreement_* parameters, when included with an Internet cryptographic suite definition, refer to DH group definitions, as no other key agreement protocol is in widespread use. When DH key agreement is used in generating keys for a particular encryption algorithm, care must be taken to ensure that the keys produced are of sufficient length (strength) to avoid compromising the security of the encryption algorithm.

A _signature algorithm_ is sometimes included in the definition of a cryptographic suite. It may be used for signing a variety of values including data, MACs, and DH values. The most common is to use *RSA* to sign a hashed value for some block of data, although the _digital signature standard_ (written as DSS or DSA to indicate the digital signature algorithm) <<FIPS186-3>> is also used in some circumstances. With the advent of ECC, signatures based on elliptic curves (e.g., ECDSA <<X9.62-2005>>) are also now supported in many systems.

The concept of a cryptographic suite evolved in the context of Internet security protocols because of a need for modularity and decoupled evolution.

* As computational power has improved, older cryptographic algorithms and smaller key lengths have fallen victim to various forms of brute-force attacks.

* In some cases, more sophisticated attacks have revealed flaws that necessitate the replacement of the underlying mathematical and cryptographic methods, but the basic protocol machinery is otherwise sound.

* As a result, the choice of a cryptographic suite can now be made separately from the communication protocol details and depends on factors such as convenience, performance, and security.

* Protocols tend to make use of the components of a cryptographic suite in a standard way, so an appropriate cryptographic suite can be “snapped in” when deemed appropriate.

== Certificates, Certificate Authorities (CAs), and PKIs

*Key management*, how keys are _created_, _exchanged_, and _revoked_, remains one of the greatest challenges in deploying cryptographic systems on a widespread basis across multiple administrative domains.

One of the challenges with public key cryptosystems is to determine the correct public key for a principal or identity.

.The principals, Alice and Bob, attempt to communicate securely, but Eve may eavesdrop and Mallory may modify messages in transit.
image::/assets/tcp-ip/security/passive-active-attacks.jpg[Passive and active attacks,50%,50%]

> In our running example, if Alice were to send her public key to Bob, Mallory could modify it in transit to be her own public key, and Bob (called the _relying party_ here) might unknowingly be using Mallory’s key, thinking it is Alice’s. This would allow Mallory to effectively masquerade as Alice.

To address this problem, a *public key certificate* is used to bind an identity to a particular public key using a digital signature.

At first glance, this presents a certain “chicken-egg” problem: How can a public key become signed if the digital signature itself requires a reliable public key?

One model, called a *web of trust*, involves having a certificate (identity/key binding) _endorsed_ by a collection of existing users (called *endorsers*).

* An endorser signs a certificate and distributes the signed certificate.
+
--
The more endorsers for a certificate over time, the more reliable it is likely to be.

An entity checking a certificate might require some number of endorsers or possibly some particular endorsers to trust the certificate.
--

* The web of trust model is decentralized and “grassroots” in nature, with no central authority. This has mixed consequences.
+
Having no central authority suggests that the scheme will not collapse because of a single point of failure, but it also means that a new entrant may experience some delay in getting its key endorsed to a degree sufficient to be trusted by a significant number of users.

* The web of trust model was first described as part of the *Pretty Good Privacy* (_PGP_) encryption system for electronic mail <<NAZ00>>, which has evolved to support a standard encoding format called *OpenPGP*, defined by <<RFC4880>>.

A more formal approach, which has the added benefit of being provably secure under certain theoretical assumptions in exchange for more dependence on a centralized authority, involves the use of a *public key infrastructure* (*PKI*).

* A PKI is a service that operates with a collection of *_certificate authorities_* (*CAs*) responsible for creating, revoking, distributing, and updating key pairs and certificates.

* A CA is an entity and service set up to manage and attest to the bindings between identities and their corresponding public keys. There are several hundred commercial CAs.
+
> A CA usually employs a _hierarchical_ signing scheme. This means that a public key may be signed using a parent key which is in turn signed by a grand-parent key, and so on. Ultimately a CA has one or more *_root certificates_* upon which many subordinate certificates depend for trust.
>
> .https://letsencrypt.org/certificates/[Let's Encrypt's Hierarchy as of August 2021]
> image::https://letsencrypt.org/images/isrg-hierarchy.png["ISRG Certificate Hierarchy Diagram, as of December 2020",60%,60%]

* An entity that is authoritative for certificates and keys (e.g., a CA) is called a *_trust anchor_*, although this term is also used to describe the certificates or other cryptographic material associated with such entities <<RFC6024>>.

=== Public Key Certificates, Certificate Authorities, and X.509

While several types of certificates have been used in the past, the one of most interest to us is based on an Internet profile of the ITU-T X.509 standard <<RFC5280>>.

In addition, any particular certificate may be stored and exchanged in a number of file or encoding formats. The most common ones include DER, PEM (a Base64 encoded version of DER), PKCS#7 (P7B), PKCS#12 (PFX), and PKCS#1 <<RFC3447>>.

Today, Internet PKI-related standards tend to use the _cryptographic message syntax_ <<RFC5652>>, which is based on PKCS#7 version 1.5.

Certificates are primarily used in identifying four types of entities on the Internet: individuals, servers, software publishers, and CAs. Certificate classes are primarily a convenience for grouping and naming types of certificates and for defining different security policies associated with them.

In practice, systems requiring public key operations have root certificates for popular CAs installed at configuration time (e.g., Microsoft Internet Explorer, Mozilla’s Firefox, and Google’s Chrome are all capable of accessing a preconfigured database of root certificates), to solve the chicken-egg PKI bootstrapping problem.

The `openssl` command, available for most common platforms including Linux and Windows, allows us to see the certificates for a Web site:

[source,console]
----
$ openssl version -d
OPENSSLDIR: "/usr/lib/ssl"
$ openssl s_client -CApath /usr/lib/ssl/certs/ -connect www.digicert.com:443 > digicert.out 2>1
^C (to interrupt)
----

* The first command determines where the local system stores its preconfigured CA certificates. This is usually a directory that varies by system.

* The next makes a connection to the HTTPS port (443) on the `www.digicert.com` server and redirect the output to the `digicert.out` file.

* The `openssl` command takes care to print the entity identified by each of the certificates, and at what depth they are in the certificate hierarchy relative to the root (depth 0 is the server’s certificate, so the depth numbers are counted bottom to top).
+
[source,console]
----
$ head digicert.out 
CONNECTED(00000003)
---
Certificate chain
 0 s:jurisdictionC = US, jurisdictionST = Utah, businessCategory = Private Organization, serialNumber = 5299537-0142, C = US, ST = Utah, L = Lehi, O = "DigiCert, Inc.", CN = www.digicert.com
   i:C = US, O = DigiCert Inc, CN = DigiCert EV RSA CA G2
   a:PKEY: rsaEncryption, 2048 (bit); sigalg: RSA-SHA256
   v:NotBefore: Jun 26 00:00:00 2023 GMT; NotAfter: Jun 25 23:59:59 2024 GMT
 1 s:C = US, O = DigiCert Inc, CN = DigiCert EV RSA CA G2
   i:C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root G2
   a:PKEY: rsaEncryption, 2048 (bit); sigalg: RSA-SHA256
----

* It also checks the certificates against the stored CA certificates to see if they verify properly.
+
In this case, they do, as indicated by “verify return” having value `0` (ok).
+
[source,console]
----
$ grep 'return code' digicert.out 
Verify return code: 0 (ok)
----

To get the certificate into a more usable form, we can extract the certificate data, convert it, and place the result into a PEM-encoded certificate file:

[source,console]
----
$ openssl x509 -in digicert.out -out digicert.pem
----

Given the certificate in PEM format, we can now use a variety of `openssl` functions to manipulate and inspect it. At the highest level, the certificate includes some _data_ to be signed (called the _To Be Signed (TBS) certificate_) followed by a _signature algorithm identifier_ and _signature value_.

[source,console]
----
$ openssl x509 -in digicert.pem -text 
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            09:fc:b7:40:3f:fd:79:b6:8f:e2:4f:74:80:5f:5d:00
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = US, O = DigiCert Inc, CN = DigiCert EV RSA CA G2
        Validity
            Not Before: Jun 26 00:00:00 2023 GMT
            Not After : Jun 25 23:59:59 2024 GMT
        Subject: jurisdictionC = US, jurisdictionST = Utah, businessCategory = Private Organization, serialNumber = 5299537-0142, C = US, ST = Utah, L = Lehi, O = "DigiCert, Inc.", CN = www.digicert.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:98:df:33:59:c1:3b:a7:38:8c:5d:9e:2f:e3:cf:
                    cb:ea:50:3a:36:fe:77:a7:98:52:4d:c2:ca:94:78:
                    8f:e6:f3:57:5d:38:77:f2:d3:d7:6b:a4:90:42:f7:
                    71:1e:58:6a:92:0d:95:91:5f:32:71:b1:93:1c:f5:
                    db:e0:0a:d6:d2:a8:da:6f:1a:80:39:57:4d:e5:af:
                    97:58:52:d1:ac:42:18:e1:99:2f:5e:b0:bd:1d:3b:
                    f2:8c:5e:8c:ad:a7:99:f5:a5:51:d1:61:4a:65:a9:
                    17:23:9e:bb:10:86:b5:36:9e:aa:33:87:8c:00:6f:
                    28:ec:2a:5c:d9:51:4e:5c:34:08:24:3a:8f:61:85:
                    a8:b1:8f:6c:9e:72:7e:a1:8b:88:31:81:07:e8:95:
                    75:2f:28:09:0e:91:b4:f9:2c:1c:7f:c5:34:15:5e:
                    59:bc:21:1c:4e:a3:ac:7f:b2:4c:76:e4:c4:9c:d9:
                    c1:ce:56:f3:a6:07:1f:43:f0:9a:c5:dd:09:3f:60:
                    77:27:d8:0f:55:05:9b:82:f2:f6:20:40:0a:05:04:
                    61:b9:d7:11:e6:26:89:95:78:d3:20:c5:6f:09:19:
                    d8:9b:e1:9a:d8:cd:e3:32:69:11:ce:3f:0c:fe:34:
                    c0:ca:25:49:9d:45:d0:67:7e:d9:78:c9:0e:34:95:
                    88:39
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Authority Key Identifier: 
                6A:4E:50:BF:98:68:9D:5B:7B:20:75:D4:59:01:79:48:66:92:32:06
            X509v3 Subject Key Identifier: 
                D4:38:B0:9D:E2:63:52:91:C7:82:03:F0:1F:00:CE:EE:A0:FA:B7:93
            X509v3 Subject Alternative Name: 
                DNS:www.digicert.com, DNS:digicert.com, DNS:admin.digicert.com, DNS:api.digicert.com, DNS:content.digicert.com, DNS:order.digicert.com, DNS:login.digicert.com, DNS:ws.digicert.com
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 CRL Distribution Points: 
                Full Name:
                  URI:http://crl3.digicert.com/DigiCertEVRSACAG2.crl
                Full Name:
                  URI:http://crl4.digicert.com/DigiCertEVRSACAG2.crl
            X509v3 Certificate Policies: 
                Policy: 2.16.840.1.114412.2.1
                Policy: 2.23.140.1.1
                  CPS: http://www.digicert.com/CPS
            Authority Information Access: 
                OCSP - URI:http://ocsp.digicert.com
                CA Issuers - URI:http://cacerts.digicert.com/DigiCertEVRSACAG2.crt
            X509v3 Basic Constraints: 
                CA:FALSE
            CT Precertificate SCTs: 
                Signed Certificate Timestamp:
                    Version   : v1 (0x0)
                    Log ID    : 76:FF:88:3F:0A:B6:FB:95:51:C2:61:CC:F5:87:BA:34:
                                B4:A4:CD:BB:29:DC:68:42:0A:9F:E6:67:4C:5A:3A:74
                    Timestamp : Jun 26 17:26:00.704 2023 GMT
                    Extensions: none
                    Signature : ecdsa-with-SHA256
                                30:46:02:21:00:89:EB:FD:DB:D0:80:4F:31:30:73:D8:
                                19:F3:B4:3B:44:96:33:A9:95:32:8B:27:EE:5A:2E:94:
                                A7:4C:C8:BC:9E:02:21:00:A0:39:06:E3:1F:15:6F:F3:
                                8D:D0:B6:D2:72:EE:8E:69:B5:23:FF:2B:8A:42:03:A1:
                                27:74:33:78:C4:AC:AF:18
                Signed Certificate Timestamp:
                    Version   : v1 (0x0)
                    Log ID    : 48:B0:E3:6B:DA:A6:47:34:0F:E5:6A:02:FA:9D:30:EB:
                                1C:52:01:CB:56:DD:2C:81:D9:BB:BF:AB:39:D8:84:73
                    Timestamp : Jun 26 17:26:00.754 2023 GMT
                    Extensions: none
                    Signature : ecdsa-with-SHA256
                                30:44:02:20:79:AB:36:3F:F9:22:B1:E1:2D:F4:57:16:
                                57:9D:38:85:70:E7:0B:8A:04:CB:CC:37:3B:91:5E:17:
                                8D:06:8F:37:02:20:3E:B8:90:C7:68:4E:60:4C:DE:04:
                                FA:72:DF:D1:B4:95:93:3E:14:0B:21:32:AD:39:14:3F:
                                55:46:5E:B2:83:16
                Signed Certificate Timestamp:
                    Version   : v1 (0x0)
                    Log ID    : 3B:53:77:75:3E:2D:B9:80:4E:8B:30:5B:06:FE:40:3B:
                                67:D8:4F:C3:F4:C7:BD:00:0D:2D:72:6F:E1:FA:D4:17
                    Timestamp : Jun 26 17:26:00.748 2023 GMT
                    Extensions: none
                    Signature : ecdsa-with-SHA256
                                30:44:02:20:3A:F4:92:55:82:0E:1D:06:A6:21:90:C3:
                                9F:F5:41:3E:27:4F:D1:E9:59:6E:D5:50:BE:9B:1E:0C:
                                15:48:80:05:02:20:54:62:74:41:60:9B:A5:E5:EC:79:
                                F1:32:46:A2:F0:A3:8B:6B:4E:79:B0:A6:7C:6C:DB:D5:
                                CB:3A:14:83:07:27
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        5d:f7:f6:45:62:22:7e:93:dc:9e:5a:62:2b:3c:8a:f1:06:9b:
        b2:18:77:ce:f9:36:dc:ea:31:f8:b6:bb:6d:e7:7b:fe:52:10:
        20:ff:d6:12:bf:ec:e4:7d:73:c5:ee:2c:dc:25:38:df:9f:03:
        2c:19:97:f7:70:7d:a0:ca:7e:69:fa:c7:3c:99:7f:66:41:00:
        bd:58:44:3a:d3:3e:39:ec:28:3a:58:da:a2:2f:14:99:60:ba:
        d2:29:9e:19:54:f8:34:86:45:ec:8d:e6:8a:09:9d:f3:ef:2b:
        b9:a3:30:0e:06:9f:45:93:70:99:b6:43:f5:2e:56:d2:fe:17:
        87:19:cc:b0:9d:36:67:a4:76:d3:d9:83:e2:c6:b9:fc:fa:a8:
        be:e5:a0:19:c8:fa:e1:88:d2:b2:9c:a2:35:0b:a8:61:09:bf:
        fc:4e:65:ee:ee:1d:9f:df:59:74:66:10:d9:f8:01:99:37:cf:
        ea:c9:83:3c:69:91:b3:2e:9d:e0:2e:ca:56:bd:f3:b6:fc:27:
        9e:eb:76:dd:42:65:8b:e8:25:0e:52:96:86:c4:5f:1e:03:1b:
        2d:5d:90:87:af:de:47:47:a8:bd:f9:3c:6e:dd:7c:42:ab:c7:
        a7:c3:f3:19:58:9d:63:98:4a:7a:8d:7a:de:84:64:10:85:7b:
        e6:4d:4e:9f
-----BEGIN CERTIFICATE-----
MIIHbDCCBlSgAwIBAgIQCfy3QD/9ebaP4k90gF9dADANBgkqhkiG9w0BAQsFADBE
MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMR4wHAYDVQQDExVE
...
AZk3z+rJgzxpkbMuneAuyla987b8J57rdt1CZYvoJQ5SlobEXx4DGy1dkIev3kdH
qL35PG7dfEKrx6fD8xlYnWOYSnqNet6EZBCFe+ZNTp8=
-----END CERTIFICATE-----
----

The decoded version of the certificate followed by an ASCII (PEM) representation of the certificate (between the `BEGIN CERTIFICATE` and `END CERTIFICATE` indicators) shows a _data_ portion and a _signature_ portion.

Within the data portion is some metadata including:

* a _Version_ field, indicating the particular X.509 certificate type (`3`, the most recent, is encoded using hex value `0x02`),

* a _Serial Number_ of the particular certificate, a number assigned by the CA unique to each certificate,

* and a _Validity_ field that gives the time during which the certificate should be treated as legitimate, starting with the _Not Before_ subfield and ending with the _Not After_ subfield.

* The certificate metadata also indicates which _signature algorithm_ is used to sign the data portion.
+
In this case (i.e. `sha256WithRSAEncryption`), it is signed by computing a hash using SHA-2 and signing the result using RSA. The signature itself appears at the end of the certificate.

* The _Issuer_ field indicates the _distinguished name_ (jargon from the ITU-T X.500 standard) of the entity that issued the certificate and may have these special subfields (based on X.501): _C_ (country), _L_ (locale or city), _O_ (organization), _OU_ (organizational unit), _ST_ (state or province), _CN_ (common name).
+
Other subfields have also been defined. In this case, we can see that an _extended validation_ (EV) <<CABF09>> CA certificate has been used to sign the server’s certificate.
+
--
EV certificates represent an industry response to certain phishing attacks involving malicious Web sites that were issued certificates without rigorous identity proofing. Issuing of an EV certificate takes place only under an agreed-upon set of stringent criteria, and a user visiting a Web site using EV certificates and a modern browser typically sees a _green_ title bar and CA information to indicate the enhanced level of rigor.

One of the requirements for EV certificates placed upon each CA is to provide a _certification practice statement_ (CPS), which outlines the practices used in issuing certificates. Considerations for authors of CPSs (and _certificate policies_ or CPs that apply on a per-certificate basis) are given in <<RFC5280>>.

Note that although EV certificates may provide higher assurance (e.g., for some Web sites), most users do not pay careful attention to the cues provided by Web browsers that reveal this fact <<BOPSW09>>.
--


[bibliography]
== References

* [[[TCPIPV1,1]]] Kevin Fall, W. Stevens _TCP/IP Illustrated: The Protocols, Volume 1_. 2nd edition, Addison-Wesley Professional, 2011
* [[[auth0-salt-hasing,2]]] https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/
* [[[wiki_cipher_suite,3]]] https://en.wikipedia.org/wiki/Cipher_suite
* [[[FIPS186-3]]] National Institute for Standards and Technology, “Digital Signature Standard (DSS),” FIPS PUB 186-3, June 2009.
* [[[FIPS198]]] National Institute for Standards and Technology, “The Keyed-Hash Message Authentication Code (HMAC),” FIPS PUB 198, Mar. 2002.
* [[[FIPS800-38B]]] National Institute for Standards and Technology, “Recommendation for Block Cipher Modes of Operation: The CMAC Mode for Authentication,”NIST Special Publication 800-38B, May 2005.
* [[[NIST800-38D]]] National Institute for Standards and Technology, “Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC,”NIST Special Publication 800-38D, Nov. 2005.
* [[[RFC1321]]] R. Rivest, “The MD5 Message-Digest Algorithm,”Internet RFC 1321 (informational), Apr. 1992.
* [[[RFC2104]]] H. Krawczyk, M. Bellare, and R. Canetti, “HMAC: Keyed-Hashing for Message Authentication,”Internet RFC 2104 (informational), Feb. 1997.
* [[[RFC2631]]] E. Rescorla, “Diffie-Hellman Key Agreement Method,” Internet RFC 2631, June 1999.
* [[[RFC4086]]] D. Eastlake 3rd, J. Schiller, and S. Crocker, “Randomness Requirements for Security,”Internet RFC 4086/BCP 0106, June 2005.
* [[[RFC6234]]] D. Eastlake 3rd and T. Hansen, “US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF),”Internet RFC 6234 (informational), May 2011.
* [[[RFC2410]]] R. Glenn and S. Kent, “The NULL Encryption Algorithm and Its Use with IPsec,” Internet RFC 2410, Nov. 1998.
* [[[RFC3713]]] M. Matsui, J. Nakajima, and S. Moriai, “A Description of the Camellia Encryption Algorithm,”Internet RFC 3713 (informational), Apr. 2004.
* [[[RFC5116]]] D. McGrew, “An Interface and Algorithms for Authenticated Encryption,”Internet RFC 5116, Jan. 2008.
* [[[RFC6234]]] D. Eastlake 3rd and T. Hansen, “US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF),” Internet RFC 6234 (informational), May 2011.
* [[[RFC4615]]] J. Song, R. Poovendran, J. Lee, and T. Iwata, “The Advanced Encryption Standard-Cipher-Based Message Authentication Code-Pseudo-Random Function-128 (AES-CMAC-PRF-128) Algorithm for the Internet Key Exchange Protocol (IKE),” Internet RFC 4615, Aug. 2006.
* [[[RFC4434]]] P. Hoffman, “The AES-XCBC-PRF-128 Algorithm for the Internet Key Exchange Protocol (IKE),” Internet RFC 4434, Feb. 2006.
* [[[FIPS186-3]]] National Institute for Standards and Technology, “Digital Signature Standard (DSS),” FIPS PUB 186-3, June 2009.
* [[[X9.62-2005]]] American National Standards Institute, “Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Standard (ECDSA),” ANSI X9.62, 2005.
* [[[RFC4880]]] J. Callas, L. Donnerhacke, H. Finney, D. Shaw, and R. Thayer, “Open-PGP Message Format,” Internet RFC 4880, Nov. 2007.
* [[[NAZ00]]] Network Associates and P. Zimmermann, Introduction to Cryptography, Part of PGP 7.0 Documentation, available from http://www.pgpi.org/doc/guide/7.0/en
* [[[RFC6024]]] R. Reddy and C. Wallace, “Trust Anchor Management Requirements,” Internet RFC 6024 (informational), Oct. 2010.
* [[[]]RFC5280] D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, and W. Polk, “Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,” Internet RFC 5280, May 2008.
* [[[RFC3447]]] J. Jonsson and B. Kaliski, “Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1,” Internet RFC 3447 (informational), Feb. 2003.
* [[[RFC5652]]] R. Housley, “Cryptographic Message Syntax (CMS),” Internet RFC 5652/STD 0070, Sept. 2009.
* [[[CABF09]]] CA/Browser Forum, “Guidelines for the Issuance and Management of Extended Validation Certificates (v1.4.6),” 2009, https://cabforum.org/wp-content/uploads/EV-SSL-Certificate-Guidelines-Version-1.4.6.pdf
* [[[BOPSW09]]] R. Biddle et al., “Browser Interfaces and Extended Validation SSL Certificates: An Empirical Study,” Proc. ACM Cloud Security Workshop, Nov. 2009.
* [[[RFC5280]]] D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, and W. Polk, “Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,” Internet RFC 5280, May 2008.
