= TCP/IP: Security: EAP, IPsec, TLS, DNSSEC, and DKIM
:page-layout: post
:page-categories: ['networking']
:page-tags: ['networking', 'tcp']
:page-date: 2023-02-24 08:27:23 +0800
:page-revdate: 2023-07-24 08:27:23 +0800
:toc: preamble
:toclevels: 4
:sectnums:
:sectnumlevels: 4

There are three primary properties of information, whether in a computer network or not, that may be desirable from an information security point of view: confidentiality, integrity, and availability (the CIA triad) [L01], summarized here:

* *Confidentiality* means that information is made known only to its intended users (which could include processing systems).
* *Integrity* means that information has not been modified in an unauthorized way before it is delivered.
* *Availability* means that information is available when needed.

These are core properties of information, yet there are other properties we may also desire, including _authentication_, _nonrepudiation_, and _auditability_.

* *Authentication* means that a particular identified party or principal is not impersonating another principal.

* *Nonrepudiation* means that if some action is performed by a principal (e.g., agreeing to the terms of a contract), this fact can be proven later (i.e., cannot successfully be denied).

* *Auditability* means that some sort of trustworthy log or accounting describing how information has been used is available.
+
Such logs are often important for forensic (i.e., legal and prosecuritorial) purposes.

These principles are applicable to information in physical (e.g., printed) form, for which mechanisms such as safes, secured facilities, and guards have been used for thousands of years to enforce controlled sharing, storage, and dissemination. When information is to be moved through an unsecured environment, additional techniques are required.

== Threats to Network Communication

Attacks can generally be categorized as either passive or active.

* *Passive attacks* are mounted by monitoring or eavesdropping on the contents of network traffic, and if not handled they can lead to unauthorized release of information (loss of confidentiality).

* *Active attacks* can cause modification of information (with possible loss of integrity) or denial of service (loss of availability).
+
Logically, such attacks are carried out by an "intruder" or adversary.

.The principals, Alice and Bob, attempt to communicate securely, but Eve may eavesdrop and Mallory may modify messages in transit.
image::/assets/tcp-ip/security/passive-active-attacks.jpg[Passive and active attacks,50%,50%]

Eve is able to eavesdrop (listen in on, also called _capture_ or _sniff_) and perform *_traffic analysis_* on the traffic passing between Alice and Bob.

* Capturing the traffic could lead to compromise of confidentiality, as sensitive data may be available to Eve without Alice or Bob knowing.
+
In addition, traffic analysis can determine the features of the traffic, such as its size and when it is sent, and possibly identify the parties to a communication. This information, although it does not reveal the exact contents of the communication, could also lead to disclosure of sensitive information and could be used to mount more powerful active attacks in the future.

While the passive attacks are essentially impossible for Alice or Bob to detect, Mallory is capable of performing more easily noticed active attacks. These include
_message stream modification_ (MSM), _denial-of-service_ (DoS), and _spurious association_ attacks.

* MSM attacks (including so-called called *_man-in-the-middle_* or MITM_attacks) are a broad category and include any way traffic is modified in transit, including deletion, reordering, and content modification.

* DoS might include deletion of traffic, or generation of such large volumes of traffic so as to overwhelm Alice, Bob, or the communication channel connecting them.

* Spurious associations include *_masquerading_* (Mallory pretends to be Bob or Alice) and replay, whereby Alice or Bob’s earlier (authentic) communications are replayed later, from Mallory's memory.

.Attacks on communication are broadly classified as passive or active. Passive attacks are ordinarily more difficult to detect, and active attacks are ordinarily more difficult to prevent.
[%header,cols="1,1,1,1"]
|===
2+|Passive
2+|Active

h|Type
h|Threats
h|Type
h|Threats

|Eavesdropping
|Confidentiality
|Message stream modification
|Authenticity, integrity

|Traffic analysis
|Confidentiality
|Denial of service (DoS)
|Availability

|
|
|Spurious association
|Authenticity

|===

With effective and careful use of *cryptography*, passive attacks are rendered ineffective, and active attacks are made detectable (and to some degree preventable).

== Basic Cryptography and Security Mechanisms

Cryptography evolved from the desire to protect the confidentiality, integrity, and authenticity of information carried through unsecured communication channels.

The use of cryptography, at least in a primitive form, dates back to at least 3500 BCE. The earliest systems were usually *codes*.

Codes involve substitutions of groups of words, phrases, or sentences with groups of numbers or letters as given in a codebook. Codebooks needed to be kept secret in order to keep communications private, so distributing them required considerable care.

More advanced systems used *ciphers*, in which both substitution and rearrangement are used.

=== Cryptosystems

.The unencrypted (cleartext) message is passed through an encryption algorithm to produce an encrypted (ciphertext) message. In a symmetric cryptosystem, the same (secret) key is used for encryption and decryption. In an asymmetric or public key cryptosystem, confidentiality is achieved by using the recipient's public key for encryption and private (secret) key for decryption.
image::/assets/tcp-ip/security/symmetric-asymmetric-cryptosystem.png[Symmetric and asymmetric key cryptosystem,50%,50%]

* In each case, a *cleartext* message is processed by an encryption algorithm to produce *ciphertext* (scrambled text).

* The *key* is a particular sequence of bits used to drive the *encryption algorithm* or cipher.

* With different keys, the same input produces different outputs. Combining the algorithms with supporting protocols and operating methods forms a *cryptosystem*.

* In a *symmetric cryptosystem*, the encryption and decryption keys are typically identical, as are the encryption and decryption algorithms.

* In an *asymmetric cryptosystem*, each principal is generally provided with a *pair* of keys consisting of one public and one private key.
+
The public key is intended to be known to any party that might want to send a message to the key pair's owner.
+
The public and private keys are mathematically related and are themselves outputs of a *key generation* algorithm.

Without knowing the symmetric key (in a symmetric cryptosystem) or the private key (in a public key cryptosystem), it is (believed to be) effectively impossible
for any third party that intercepts the ciphertext to produce the corresponding cleartext. This provides the basis for confidentiality.

For the symmetric key cryptosystem, it also provides a degree of authentication, because only a party holding the key is able to produce a useful ciphertext that can be decrypted to something sensible.

* A receiver can decrypt the ciphertext, look for a portion of the resulting cleartext to contain a particular agreed-upon value, and conclude that the sender holds the appropriate key and is therefore authentic.

* Furthermore, most encryption algorithms work in such a way that if messages are modified in transit, they are unable to produce useful cleartext upon decryption.

Thus, symmetric cryptosystems provide a measure of both authentication and integrity protection for messages, but this approach alone is weak. Instead, special forms of checksums are usually coupled with symmetric cryptography to ensure integrity.

A symmetric encryption algorithm is usually classified as either a *block cipher* or a *stream cipher*.

* Block ciphers perform operations on a fixed number of bits (e.g., 64 or 128) at a time,

* and stream ciphers operate continuously on however many bits (or bytes) are provided as input.

For years, the most popular symmetric encryption algorithm was the *_Data Encryption Standard_* (DES), a block cipher that uses 64-bit blocks and 56-bit keys.

Eventually, the use of 56-bit keys was felt to be insecure, and many applications turned to *_triple-DES_* (also denoted _3DES_ or _TDES_—applying DES three times with two or three different keys to each block of data).

Today, DES and 3DES have been largely phased out in favor of the *_Advanced Encryption Standard_* (AES), also known occasionally by its original name the _Rijndael_ algorithm (pronounced “rain-dahl”), in deference to its Belgian cryptographer inventors Vincent Rijmen and Joan Daemen.

Different variants of AES provide key lengths of 128, 192, and 256 bits and are usually written with the corresponding extension (i.e., AES-128, AES-192, and AES-256).

Asymmetric cryptosystems have some additional interesting properties beyond those of symmetric key cryptosystems.

. Assuming we have Alice as sender and Bob as intended recipient, any third party is assumed to know Bob's public key and can therefore send him a secret message—only Bob is able to decrypt it because only Bob knows the private key corresponding to his public key.

. However, Bob has no real assurance that the message is authentic, because any party can create a message and send it to Bob, encrypted in Bob's public key.

. Fortunately, public key cryptosystems also provide another function when used in reverse: authentication of the sender.

. In this case, Alice can encrypt a message using her private key and send it to Bob (or anyone else).

. Using Alice's public key (known to all), anyone can verify that the message was authored by Alice and has not been modified.

. However, it is not confidential because everyone has access to Alice's public key.

. To achieve _authenticity_, _integrity_, and _confidentiality_, *Alice can encrypt a message using her private key and encrypt the result using Bob's public key.*

. The result is a message that is reliably authored by Alice and is also confidential to Bob.
+
.The asymmetric cryptosystem can be used for confidentiality (encryption), authentication (digital signatures or signing), or both. When used for both, it produces a signed output that is confidential to the sender and the receiver. Public keys, as their name suggests, are not kept secret.
image::/assets/tcp-ip/security/asymmetric-cryptosystem.png[Asymmetric (Public Key) Cryptosystem,50%,50%]

When public key cryptography is used in "reverse" like this, it provides a *digital signature*.

* Digital signatures are important consequences of public key cryptography and can be used to help ensure authenticity and nonrepudiation.

* Only a party possessing Alice’s private key is able to author messages or carry out transactions as Alice.

In a *_hybrid_* cryptosystem, elements of both public key and symmetric key cryptography are used.

* Most often, public key operations are used to exchange a randomly generated confidential (symmetric) *session key*, which is used to encrypt traffic for a single transaction using a symmetric algorithm.

* The reason for doing so is performance—symmetric key operations are less computationally intensive than public key operations.

* Most systems today are of the hybrid type: public key cryptography is used to establish keys used for symmetric encryption of individual sessions.

=== Rivest, Shamir, and Adleman (RSA) Public Key Cryptography

The most common approach used for both digital signatures and confidentiality is called RSA in deference to its authors' names, Rivest, Shamir, and Adleman. The security of this system hinges on the difficulty of factoring large numbers into constituent primes.

=== Diffie-Hellman-Merkle Key Agreement (aka Diffie-Hellman or DH)

The Diffie-Hellman-Merkle Key Agreement protocol (more commonly called simply Diffie-Hellman or DH) provides a method to have two parties agree on a common set of secret bits that can be used as a symmetric key, based on the use of finite field arithmetic.

DH techniques are used in many of the Internet-related security protocols <<RFC2631>> and are closely related to the RSA approach for public key cryptography.

=== Signcryption and Elliptic Curve Cryptography (ECC)

When using RSA, additional security is provided with larger numbers. However, the basic mathematical operations required by RSA (e.g., exponentiation) can be computationally intensive and scale as the numbers grow. Reducing the effort of combining digital signatures and encryption for confidentiality, a class of *sign-cryption* schemes (also called *authenticated encryption*) provides both features at a cost less than the sum of the two if computed separately. However, even greater efficiency can sometimes be achieved by changing the mathematical basis for public key cryptography.

In a continuing search for security with greater efficiency and performance, researchers have explored other public key cryptosystems beyond RSA. An alternative based on the difficulty of finding the discrete logarithm of an *elliptic curve* element has emerged, known as *elliptic curve cryptography* (ECC, not to be confused with _error-correcting code_).

For equivalent security, ECC offers the benefit of using keys that are considerably smaller than those of RSA (e.g., by about a factor of 6 for a 1024-bit RSA modulus). This leads to simpler and faster implementations, issues of considerable practical concern.

ECC has been standardized for use in many of the applications where RSA still retains dominance, but adoption has remained somewhat sluggish because of patents on ECC technology held by the Certicom Corporation. (The RSA algorithm was also patented, but patent protection lapsed in the year 2000.)

=== Key Derivation and Perfect Forward Secrecy (PFS)

In communication scenarios where multiple messages are to be exchanged, it is common to establish a short-term session key to perform symmetric encryption.

The session key is ordinarily a random number generated by a function called a *key derivation function* (KDF), based on some input such as a master key or a previous session key. If a session key is compromised, any of the data encrypted with the key is subject to compromise. However, it is common practice to change keys (*_rekey_*) multiple times during an extended communication session.

A scheme in which the compromise of one session key keeps future communications secure is said to have *perfect forward secrecy* (PFS). Usually, schemes that provide PFS require additional key exchanges or verifications that introduce overhead. One example is the STS protocol for DH mentioned earlier.

=== Pseudorandom Numbers, Generators, and Function Families

In cryptography, random numbers are often used as initial input values to cryptographic functions, or for generating keys that are difficult to guess. Given that computers are not very random by nature, obtaining true random numbers is somewhat difficult. The numbers used in most computers for simulating randomness are called *pseudorandom numbers*. Such numbers are not usually truly random but instead exhibit a number of statistical properties that suggest that they are (e.g., when many of them are generated, they tend to be uniformly distributed across some range). Pseudorandom numbers are produced by an algorithm or device known as a *pseudorandom number generator* (PRNG) or *pseudorandom generator* (PRG), depending on the author.

Simple PRNGs are deterministic. That is, they have a small amount of internal state initialized by a *_seed_* value. Once the internal state is known, the sequence of PNs can be determined.

For example, the common _Linear Congruential Generator_ (LCG) algorithm produces random-appearing values that are entirely predictable if the input parameters are known or guessed. Consequently, LCGs are perfectly fine for use in certain programs (e.g., games that simulate random events) but insufficient for cryptographic purposes.

A *pseudorandom function family* (PRF) is a family of functions that appear to be algorithmically indistinguishable (by polynomial time algorithms) from truly random functions. A PRF is a stronger concept than a PRG, as a PRG can be created from a PRF.

PRFs are the basis for *_cryptographically strong_* (or secure) pseudorandom number generators, called CSPRNGs. CSPRNGs are necessary in cryptographic applications for several purposes, including session key generation, for which a sufficient amount of randomness must be guaranteed <<RFC4086>>.

=== Nonces and Salt

A *cryptographic nonce* is a number that is used once (or for one transaction) in a cryptographic protocol. Most commonly, a nonce is a random or pseudorandom number that is used in authentication protocols to ensure *_freshness_*. Freshness is the (desirable) property that a message or operation has taken place in the very recent past.

For example, in a *_challenge-response_* protocol, a server may provide a requesting client with a nonce, and the client may need to respond with authentication material as well as a copy of the nonce (or perhaps an encrypted copy of the nonce) within a certain period of time. This helps to avoid replay attacks, because old authentication exchanges that are replayed to the server would not contain the correct nonce value.

A *salt* or salt value, used in the cryptographic context, is a random or pseudorandom number used to frustrate *_brute-force_* attacks on secrets. Brute-force attacks usually involve repeatedly guessing a password, passphrase, key, or equivalent secret value and checking to see if the guess was correct. Salts work by frustrating the checking portion of a brute-force attack.

The best-known example is the way passwords used to be handled in the UNIX system. Users' passwords were encrypted and stored in a password file that all users could read. When logging in, each user would provide a password that was used to double encrypt a fixed value. The result was then compared against the user's entry in the password file. A match indicated that a correct password was provided.

At the time, the encryption method (DES) was well known and there was concern that a hardware-based *_dictionary attack_* would be possible whereby many words from a dictionary were encrypted with DES ahead of time (forming a *_rainbow table_*) and compared against the password file. A pseudorandom 12-bit salt was added to perturb the DES algorithm in one of 4096 (nonstandard) ways for each password in an effort to thwart this attack. Ultimately, the 12-bit salt was determined to be insufficient with improved computers (that could guess more values) and was expanded.

NOTE: However, there are limitations in the protections that a salt can provide. If the attacker is hitting an online service with a credential stuffing attack, a subset of the brute force attack category, salts won't help at all because the legitimate server is doing the salting+hashing for you. <<auth0-salt-hasing>>

=== Cryptographic Hash Functions and Message Digests

In most of the protocols, including Ethernet, IP, ICMP, UDP, and TCP, we have seen the use of a frame check sequence (FCS, either a checksum or a CRC) to determine whether a PDU has likely been delivered without bit errors. When considering security, ordinary FCS functions are not sufficient for this purpose.

A checksum or FCS can be used to verify message integrity if properly constructed using special functions, which are called *cryptographic hash functions*.

* The output of a cryptographic hash function _H_, when provided a message _M_, is called the *digest* or *fingerprint* of the message, _H(M)_.

* A message digest is a type of strong FCS that is easy to compute and has the following important properties:
+
--
* Preimage resistance: Given _H(M)_, it should be difficult to determine _M_ if not already known.

* Second preimage resistance: Given _H(M1)_, it should be difficult to determine an _M2 ≠ M1_ such that _H(M1) = H(M2)_.

* Collision resistance: It should be difficult to find any pair _M1_, _M2_ where _H(M1) = H(M2)_ when _M2 ≠ M1_.
--
+
If a hash function has all of these properties, then if two messages have the same cryptographic hash value, they are, with negligible doubt, the same message. The two most common cryptographic hash algorithms are at present the _Message Digest Algorithm 5_ (*_MD5_*, <<RFC1321>>), which produces a 128-bit (16-byte) digest, and the _Secure Hash Algorithm 1_ (*_SHA-1_*), which produces a 160-bit (20-byte) digest.
+
More recently, a family of functions based on SHA called *_SHA-2_* <<RFC6234>> produce digests with lengths of 224, 256, 384, or 512 bits (28, 32, 48, and 64 bytes, respectively). Others are under development.

[NOTE]
====
Cryptographic hash functions are often based on a compression function _f_, which takes an input of length _L_ and produces a collision-resistant but deterministic output of size less than _L_. The Merkle-Damgård construction, which essentially breaks an arbitrarily long input into blocks of length _L_, pads them, passes them to _f_, and combines the results, produces a cryptographic hash function capable of taking a long input and producing an output with collision resistance.
====

=== Message Authentication Codes (MACs, HMAC, CMAC, and GMAC)

A _message authentication code_ (unfortunately abbreviated *MAC* or sometimes *MIC* but unrelated to the link-layer MAC addresses) can be used to ensure message integrity and authentication.

MACs are usually based on *_keyed cryptographic hash functions_*, which are like _message digest algorithms_ but require a _private key_ to produce or verify the integrity of a message and may also be used to verify (authenticate) the message's sender.

MACs require resistance to various forms of *_forgery_*.

* For a given keyed hash function _H(M,K)_ taking input message _M_ and key _K_, resistance to *_selective forgery_* means that it is difficult for an adversary not knowing _K_ to form _H(M,K)_ given a specific _M_.
* _H(M,K)_ is resistant to *_existential forgery_* if it is difficult for an adversary lacking _K_ to find any previously unknown valid combination of _M_ and _H(M,K)_.

NOTE: Note that MACs do not provide exactly the same features as digital signatures. For example, they cannot be a solid basis for nonrepudiation because the secret key is known to more than one party.

A standard MAC that uses _cryptographic hash functions_ in a particular way is called the _keyed-hash message authentication code_ (*HMAC*) <<FIPS198>><<RFC2104>>.

* The HMAC "algorithm" uses a generic cryptographic hash algorithm, say _H(M)_.

* To form a _t_-byte HMAC on message _M_ with key _K_ using _H_ (called _HMAC-H_), we use the following definition:
+
[.text-center,subs="+quotes"]
----
_HMAC-H (K, M)t = Λt (H((K ⊕ opad)||H((K ⊕ ipad)||M)))_
----
+
In this definition, `opad` (outer pad) is an array containing the value `0x5C` repeated `|K|` times, and `ipad` (inner pad) is an array containing the value `0x36` repeated `|K|` times. `⊕` is the vector XOR operator, and `||` is the concatenation operator.
+
Normally the HMAC output is intended to be a certain number `t` of bytes in length, so the operator `Λt(M)` takes the left-most `t` bytes of `M`.

More recently, other forms of MACs have been standardized, called the _cipher-based MAC_ (*CMAC*) <<FIPS800-38B>> and *GMAC* <<NIST800-38D>>. Instead of using a cryptographic hash function such as HMAC, these use a block cipher such as AES or 3DES. CMAC is envisioned for use in environments where it is more convenient or efficient to use a block cipher in place of a hash function.

=== Cryptographic Suites and Cipher Suites

The combination of the mathematical or cryptographic techniques used in a particular system, especially the Internet protocols, defines not only an enciphering (encryption) algorithm but may also include a particular MAC algorithm, PRF (_pseudorandom function family_), key agreement algorithm, signature algorithm, and associated key lengths and parameters, are called a *cryptographic suite* or sometimes a *cipher suite*, although the first term is more accurate.

> From Wikipedia, the free encyclopedia
> 
> A *_cipher suite_* is a set of algorithms that help secure a network connection. Suites typically use Transport Layer Security (TLS) or its now-deprecated predecessor Secure Socket Layer (SSL). The set of algorithms that cipher suites usually contain include: a key exchange algorithm, a bulk encryption algorithm, and a message authentication code (MAC) algorithm. <<CSWIKIPEDIA>>
> 
> The _key exchange algorithm_ is used to exchange a key between two devices. This key is used to encrypt and decrypt the messages being sent between two machines. The _bulk encryption algorithm_ is used to encrypt the data being sent. The _MAC algorithm_ provides data integrity checks to ensure that the data sent does not change in transit. In addition, cipher suites can include _signatures and an authentication algorithm_ to help authenticate the server and or client. 
>
> .Algorithms supported in TLS 1.0–1.2 cipher suites 
> [%header,cols="1,1,1,1"]
> |===
> |Key exchange/agreement
> |Authentication
> |Block/stream ciphers
> |Message authentication
> 
> |RSA
> |RSA
> |RC4
> |Hash-based MD5
> 
> |Diffie–Hellman
> |DSA
> |Triple DES
> |SHA hash function
> 
> |ECDH
> |ECDSA
> |AES 	
> |
> 
> |SRP
> |
> |IDEA 	
> |
> 
> |PSK
> |
> |DES 	
> |
> 
> |
> |
> |Camellia 	
> |
> 
> |
> |
> |ChaCha20 	
> |
> |===
> 
> . For more information about algorithms supported in TLS 1.0–1.2, see also: https://en.wikipedia.org/wiki/Transport_Layer_Security#Applications_and_adoption[Transport Layer Security § Applications and adoption]
> . In TLS 1.3, many legacy algorithms that were supported in early versions of TLS have been dropped in an effort to make the protocol more secure.

.TLS Cipher Suites: https://www.iana.org/assignments/tls-parameters/tls-parameters.xml
[%header,cols="1,3,1,1,1"]
|===
|Value 
|Description 
|DTLS-OK 
|Recommended 
|Reference

|0x13,0x01
|TLS_AES_128_GCM_SHA256
|Y
|Y
|[RFC8446]

|0xD0,0x05
|TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256
|Y
|Y
|[RFC8442]

|0xD0,0x01
|TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256
|Y
|Y
|[RFC8442]

|0xC0,0x2F
|TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
|Y
|Y
|[RFC5289]

|0xC0,0x2B
|TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
|Y
|Y
|[RFC5289]

|===

Usually, an _encryption algorithm_ is specified by its name and description, how many bits are used for its keys (often a multiple of 128 bits), along with its operating _mode_.

.https://learn.microsoft.com/en-us/windows/win32/secauthn/cipher-suites-in-schannel
image::https://learn.microsoft.com/en-us/windows/win32/secauthn/images/tls-cipher-suite.png[Diagram that shows a single string for a Cipher Suite.,55%,55%]

* Encryption algorithms that have been standardized for use with Internet protocols include AES, 3DES, NULL <<RFC2410>>, and CAMELLIA <<RFC3713>>.
+
The NULL encryption algorithm does not modify the input and is used in certain circumstances where confidentiality is not required.

* The _operating_ *_mode_* of an encryption algorithm, especially a block cipher, describes how to use the encryption function for a single block repeatedly (e.g., in a cascade) to encrypt or decrypt an entire message with a single key.
+
--
* When performing encryption using CBC (*_cipher block chaining_*) mode, a cleartext block to be encrypted is first XORed with the previous ciphertext block (the first block is XORed with a random *_initialization vector_* or *IV*).

* Encrypting in CTR (*_counter_*) mode involves first creating a value combining a nonce (or IV) and a counter that increments with each successive block to be encrypted.
+
The combination is then encrypted, the output is XORed with a cleartext block to produce a ciphertext block, and the process repeats for successive blocks.
+
In effect, this approach uses a block cipher to produce a *keystream*, a sequence of (random-appearing) bits that are combined (e.g., XORed) with cleartext bits to produce a ciphertext. Doing so essentially converts a block cipher into a stream cipher because no explicit padding of the input is required.

* CBC requires a serial process for encryption and a partly serial process for decryption, whereas counter mode algorithms allow more efficient fully parallel encryption and decryption implementations. Consequently, counter mode is gaining popularity.

* In addition, variants of CTR mode (e.g., counter mode with CBC-MAC (CCM), Galois Counter Mode, or GCM) can be used for authenticated encryption <<RFC4309>>, and possibly to authenticate (but not encrypt) additional data (called _authenticated encryption with associated data_ or *AEAD*) <<RFC5116>>.

* When an encryption algorithm is specified as part of a cryptographic suite, its name usually includes the mode, and the key length is often implied.
+
> For example, ENCR_AES_CTR refers to AES-128 used in CTR mode.
--

When a PRF (_pseudorandom function family_) is included in the definition of a cryptographic suite, it is usually based on a cryptographic hash algorithm family such as SHA-2 <<RFC6234>> or a cryptographic MAC such as CMAC <<RFC4434>><<RFC4615>>.

> For example, the algorithm AES-CMAC-PRF-128 refers to a PRF constructed using a CMAC based on AES-128. It is also written as PRF_AES128_CMAC. The algorithm PRF_HMAC_SHA1 refers to a PRF based on HMAC-SHA1.

*_Key agreement_* parameters, when included with an Internet cryptographic suite definition, refer to DH group definitions, as no other key agreement protocol is in widespread use. When DH key agreement is used in generating keys for a particular encryption algorithm, care must be taken to ensure that the keys produced are of sufficient length (strength) to avoid compromising the security of the encryption algorithm.

A _signature algorithm_ is sometimes included in the definition of a cryptographic suite. It may be used for signing a variety of values including data, MACs, and DH values. The most common is to use *RSA* to sign a hashed value for some block of data, although the _digital signature standard_ (written as DSS or DSA to indicate the digital signature algorithm) <<FIPS186-3>> is also used in some circumstances. With the advent of ECC, signatures based on elliptic curves (e.g., ECDSA <<X9.62-2005>>) are also now supported in many systems.

The concept of a cryptographic suite evolved in the context of Internet security protocols because of a need for modularity and decoupled evolution.

* As computational power has improved, older cryptographic algorithms and smaller key lengths have fallen victim to various forms of brute-force attacks.

* In some cases, more sophisticated attacks have revealed flaws that necessitate the replacement of the underlying mathematical and cryptographic methods, but the basic protocol machinery is otherwise sound.

* As a result, the choice of a cryptographic suite can now be made separately from the communication protocol details and depends on factors such as convenience, performance, and security.

* Protocols tend to make use of the components of a cryptographic suite in a standard way, so an appropriate cryptographic suite can be “snapped in” when deemed appropriate.

=== OpenSSL: Cryptography and SSL/TLS Toolkit

The https://www.openssl.org/[OpenSSL Project] develops and maintains the OpenSSL software - a robust, commercial-grade, full-featured toolkit for general-purpose cryptography and secure communication. <<OPENSSL>>

A good starting point for understanding some of the key concepts in OpenSSL 3.0 is the libcrypto https://www.openssl.org/docs/man3.0/man7/crypto.html[manual page]. Information and notes about migrating existing applications to OpenSSL 3.0 are available in the https://www.openssl.org/docs/man3.0/man7/migration_guide.html[OpenSSL 3.0 Migration Guide]. The https://www.openssl.org/docs/faq.html[frequently-asked questions (FAQ)] page is available.

> The OpenSSL crypto library ("libcrypto") implements a wide range of cryptographic algorithms used in various Internet standards. The services provided by this library are used by the OpenSSL implementations of TLS and CMS, and they have also been used to implement many other third party products and protocols.
>
> The functionality includes symmetric encryption, public key cryptography, key agreement, certificate handling, cryptographic hash functions, cryptographic pseudo-random number generators, message authentication codes (MACs), key derivation functions (KDFs), and various utilities.

[source,console]
----
$ openssl version 
OpenSSL 3.0.9 30 May 2023 (Library: OpenSSL 3.0.9 30 May 2023)
----

[source,console]
----
$ # Generate a private and public key pair for Alice
$ openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:4096 -out alice.pub -quiet 
$ openssl rsa -in alice.pub -pubout -out alice.key 
writing RSA key

$ # Generate a private and public key pair for Bob
$ openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:4096 -out bob.pub -quiet 
$ openssl rsa -in bob.pub -pubout -out bob.key 
writing RSA key

$ ls
alice.key  alice.pub  bob.key  bob.pub

$ MESSAGE="Hello, 世界"
----

== Certificates, Certificate Authorities (CAs), and PKIs

*Key management*, how keys are _created_, _exchanged_, and _revoked_, remains one of the greatest challenges in deploying cryptographic systems on a widespread basis across multiple administrative domains.

One of the challenges with public key cryptosystems is to determine the correct public key for a principal or identity.

.The principals, Alice and Bob, attempt to communicate securely, but Eve may eavesdrop and Mallory may modify messages in transit.
image::/assets/tcp-ip/security/passive-active-attacks.jpg[Passive and active attacks,50%,50%]

> In our running example, if Alice were to send her public key to Bob, Mallory could modify it in transit to be her own public key, and Bob (called the _relying party_ here) might unknowingly be using Mallory’s key, thinking it is Alice’s. This would allow Mallory to effectively masquerade as Alice.

To address this problem, a *public key certificate* is used to bind an identity to a particular public key using a digital signature.

At first glance, this presents a certain “chicken-egg” problem: How can a public key become signed if the digital signature itself requires a reliable public key?

One model, called a *web of trust*, involves having a certificate (identity/key binding) _endorsed_ by a collection of existing users (called *endorsers*).

* An endorser signs a certificate and distributes the signed certificate.
+
--
The more endorsers for a certificate over time, the more reliable it is likely to be.

An entity checking a certificate might require some number of endorsers or possibly some particular endorsers to trust the certificate.
--

* The web of trust model is decentralized and “grassroots” in nature, with no central authority. This has mixed consequences.
+
Having no central authority suggests that the scheme will not collapse because of a single point of failure, but it also means that a new entrant may experience some delay in getting its key endorsed to a degree sufficient to be trusted by a significant number of users.

* The web of trust model was first described as part of the *Pretty Good Privacy* (_PGP_) encryption system for electronic mail <<NAZ00>>, which has evolved to support a standard encoding format called *OpenPGP*, defined by <<RFC4880>>.

A more formal approach, which has the added benefit of being provably secure under certain theoretical assumptions in exchange for more dependence on a centralized authority, involves the use of a *public key infrastructure* (*PKI*).

* A PKI is a service that operates with a collection of *_certificate authorities_* (*CAs*) responsible for creating, revoking, distributing, and updating key pairs and certificates.

* A CA is an entity and service set up to manage and attest to the bindings between identities and their corresponding public keys. There are several hundred commercial CAs.
+
> A CA usually employs a _hierarchical_ signing scheme. This means that a public key may be signed using a parent key which is in turn signed by a grand-parent key, and so on. Ultimately a CA has one or more *_root certificates_* upon which many subordinate certificates depend for trust.
>
> .https://letsencrypt.org/certificates/[Let's Encrypt's Hierarchy as of August 2021]
> image::https://letsencrypt.org/images/isrg-hierarchy.png["ISRG Certificate Hierarchy Diagram, as of December 2020",60%,60%]

* An entity that is authoritative for certificates and keys (e.g., a CA) is called a *_trust anchor_*, although this term is also used to describe the certificates or other cryptographic material associated with such entities <<RFC6024>>.

=== Public Key Certificates, Certificate Authorities, and X.509

While several types of certificates have been used in the past, the one of most interest to us is based on an Internet profile of the ITU-T X.509 standard <<RFC5280>>.

In addition, any particular certificate may be stored and exchanged in a number of file or encoding formats. The most common ones include DER, PEM (a Base64 encoded version of DER), PKCS#7 (P7B), PKCS#12 (PFX), and PKCS#1 <<RFC3447>>.

Today, Internet PKI-related standards tend to use the _cryptographic message syntax_ <<RFC5652>>, which is based on PKCS#7 version 1.5.

Certificates are primarily used in identifying four types of entities on the Internet: individuals, servers, software publishers, and CAs. Certificate classes are primarily a convenience for grouping and naming types of certificates and for defining different security policies associated with them.

In practice, systems requiring public key operations have root certificates for popular CAs installed at configuration time (e.g., Microsoft Internet Explorer, Mozilla’s Firefox, and Google’s Chrome are all capable of accessing a preconfigured database of root certificates), to solve the chicken-egg PKI bootstrapping problem.

The `openssl` command, available for most common platforms including Linux and Windows, allows us to see the certificates for a Web site:

[source,console]
----
$ openssl version -d
OPENSSLDIR: "/usr/lib/ssl"
$ openssl s_client -CApath /usr/lib/ssl/certs/ -connect www.digicert.com:443 > digicert.out 2>1
^C (to interrupt)
----

* The first command determines where the local system stores its preconfigured CA certificates. This is usually a directory that varies by system.

* The next makes a connection to the HTTPS port (443) on the `www.digicert.com` server and redirect the output to the `digicert.out` file.

* The `openssl` command takes care to print the entity identified by each of the certificates, and at what depth they are in the certificate hierarchy relative to the root (depth 0 is the server’s certificate, so the depth numbers are counted bottom to top).
+
[source,console]
----
$ head digicert.out 
CONNECTED(00000003)
---
Certificate chain
 0 s:jurisdictionC = US, jurisdictionST = Utah, businessCategory = Private Organization, serialNumber = 5299537-0142, C = US, ST = Utah, L = Lehi, O = "DigiCert, Inc.", CN = www.digicert.com
   i:C = US, O = DigiCert Inc, CN = DigiCert EV RSA CA G2
   a:PKEY: rsaEncryption, 2048 (bit); sigalg: RSA-SHA256
   v:NotBefore: Jun 26 00:00:00 2023 GMT; NotAfter: Jun 25 23:59:59 2024 GMT
 1 s:C = US, O = DigiCert Inc, CN = DigiCert EV RSA CA G2
   i:C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root G2
   a:PKEY: rsaEncryption, 2048 (bit); sigalg: RSA-SHA256
----

* It also checks the certificates against the stored CA certificates to see if they verify properly.
+
In this case, they do, as indicated by “verify return” having value `0` (ok).
+
[source,console]
----
$ grep 'return code' digicert.out 
Verify return code: 0 (ok)
----

To get the certificate into a more usable form, we can extract the certificate data, convert it, and place the result into a PEM-encoded certificate file:

[source,console]
----
$ openssl x509 -in digicert.out -out digicert.pem
----

Given the certificate in PEM format, we can now use a variety of `openssl` functions to manipulate and inspect it. At the highest level, the certificate includes some _data_ to be signed (called the _To Be Signed (TBS) certificate_) followed by a _signature algorithm identifier_ and _signature value_.

[source,console]
----
$ openssl x509 -in digicert.pem -text 
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            09:fc:b7:40:3f:fd:79:b6:8f:e2:4f:74:80:5f:5d:00
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = US, O = DigiCert Inc, CN = DigiCert EV RSA CA G2
        Validity
            Not Before: Jun 26 00:00:00 2023 GMT
            Not After : Jun 25 23:59:59 2024 GMT
        Subject: jurisdictionC = US, jurisdictionST = Utah, businessCategory = Private Organization, serialNumber = 5299537-0142, C = US, ST = Utah, L = Lehi, O = "DigiCert, Inc.", CN = www.digicert.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:98:df:33:59:c1:3b:a7:38:8c:5d:9e:2f:e3:cf:
                    ...
                    c0:ca:25:49:9d:45:d0:67:7e:d9:78:c9:0e:34:95:
                    88:39
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Authority Key Identifier: 
                6A:4E:50:BF:98:68:9D:5B:7B:20:75:D4:59:01:79:48:66:92:32:06
            X509v3 Subject Key Identifier: 
                D4:38:B0:9D:E2:63:52:91:C7:82:03:F0:1F:00:CE:EE:A0:FA:B7:93
            X509v3 Subject Alternative Name: 
                DNS:www.digicert.com, DNS:digicert.com, DNS:admin.digicert.com, DNS:api.digicert.com, DNS:content.digicert.com, DNS:order.digicert.com, DNS:login.digicert.com, DNS:ws.digicert.com
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 CRL Distribution Points: 
                Full Name:
                  URI:http://crl3.digicert.com/DigiCertEVRSACAG2.crl
                Full Name:
                  URI:http://crl4.digicert.com/DigiCertEVRSACAG2.crl
            X509v3 Certificate Policies: 
                Policy: 2.16.840.1.114412.2.1
                Policy: 2.23.140.1.1
                  CPS: http://www.digicert.com/CPS
            Authority Information Access: 
                OCSP - URI:http://ocsp.digicert.com
                CA Issuers - URI:http://cacerts.digicert.com/DigiCertEVRSACAG2.crt
            X509v3 Basic Constraints: 
                CA:FALSE
            CT Precertificate SCTs: 
                Signed Certificate Timestamp:
                    Version   : v1 (0x0)
                    Log ID    : 76:FF:88:3F:0A:B6:FB:95:51:C2:61:CC:F5:87:BA:34:
                                B4:A4:CD:BB:29:DC:68:42:0A:9F:E6:67:4C:5A:3A:74
                    Timestamp : Jun 26 17:26:00.704 2023 GMT
                    Extensions: none
                    Signature : ecdsa-with-SHA256
                                30:46:02:21:00:89:EB:FD:DB:D0:80:4F:31:30:73:D8:
                                ...
                                27:74:33:78:C4:AC:AF:18
                Signed Certificate Timestamp:
                    Version   : v1 (0x0)
                    Log ID    : 48:B0:E3:6B:DA:A6:47:34:0F:E5:6A:02:FA:9D:30:EB:
                                1C:52:01:CB:56:DD:2C:81:D9:BB:BF:AB:39:D8:84:73
                    Timestamp : Jun 26 17:26:00.754 2023 GMT
                    Extensions: none
                    Signature : ecdsa-with-SHA256
                                30:44:02:20:79:AB:36:3F:F9:22:B1:E1:2D:F4:57:16:
                                ...
                                55:46:5E:B2:83:16
                Signed Certificate Timestamp:
                    Version   : v1 (0x0)
                    Log ID    : 3B:53:77:75:3E:2D:B9:80:4E:8B:30:5B:06:FE:40:3B:
                                67:D8:4F:C3:F4:C7:BD:00:0D:2D:72:6F:E1:FA:D4:17
                    Timestamp : Jun 26 17:26:00.748 2023 GMT
                    Extensions: none
                    Signature : ecdsa-with-SHA256
                                30:44:02:20:3A:F4:92:55:82:0E:1D:06:A6:21:90:C3:
                                ...
                                CB:3A:14:83:07:27
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        5d:f7:f6:45:62:22:7e:93:dc:9e:5a:62:2b:3c:8a:f1:06:9b:
        ...
        e6:4d:4e:9f
-----BEGIN CERTIFICATE-----
MIIHbDCCBlSgAwIBAgIQCfy3QD/9ebaP4k90gF9dADANBgkqhkiG9w0BAQsFADBE
...
qL35PG7dfEKrx6fD8xlYnWOYSnqNet6EZBCFe+ZNTp8=
-----END CERTIFICATE-----
----

The decoded version of the certificate followed by an ASCII (PEM) representation of the certificate (between the `BEGIN CERTIFICATE` and `END CERTIFICATE` indicators) shows a _data_ portion and a _signature_ portion.

Within the data portion is some metadata including:

* a _Version_ field, indicating the particular X.509 certificate type (`3`, the most recent, is encoded using hex value `0x02`),

* a _Serial Number_ of the particular certificate, a number assigned by the CA unique to each certificate,

* and a _Validity_ field that gives the time during which the certificate should be treated as legitimate, starting with the _Not Before_ subfield and ending with the _Not After_ subfield.

* The certificate metadata also indicates which _signature algorithm_ is used to sign the data portion.
+
In this case (i.e. `sha256WithRSAEncryption`), it is signed by computing a hash using SHA-2 and signing the result using RSA. The signature itself appears at the end of the certificate.

* The _Issuer_ field indicates the _distinguished name_ (jargon from the ITU-T X.500 standard) of the entity that issued the certificate and may have these special subfields (based on X.501): _C_ (country), _L_ (locale or city), _O_ (organization), _OU_ (organizational unit), _ST_ (state or province), _CN_ (common name).

* The _Subject_ field identifies the entity this certificate is about, and the owner of the public key contained in the subsequent _Subject Public Key Info_ field.
+
In this example, the _Subject_ field is a somewhat complex structure like the _Issuer_ field and contains multiple _object IDs_ (_OIDs_) <<ITUOID>>. Most are decoded with names (e.g., _O_, _C_, _ST_, _L_, _CN_), but some are not because the particular version of `openssl` that printed the output did not understand them.
+
Note that the _CN_ subfield tends to be an important one when identifying subjects and issuers for certificates used on the Internet.
+
For this certificate, it gives the correct matching name for the server (along with any names included in the _Subject Alternative Name_ (_SAN_) extension). Nonmatching names or URLs (e.g., `https://digicert.com` instead of `https://www.digicert.com`) referring to the same server, when accessed, is also ok.
+
NOTE: Note that _CN_ is not really the field for holding a DNS name; SANs are intended for this purpose.
+
When a certificate needs to be validated, a recursive process works up the certificate hierarchy to a root CA certificate by matching the issuer distinguished name in one certificate with the subject name in another.
+
In this case, the certificate was issued by `DigiCert EV RSA CA G2` (the issuer’s _CN_ subfield). Assuming all certificates are current in their validity periods and are being used in appropriate ways, some parent certificate (immediate parent, grandparent, etc., but usually a root CA certificate) to the _Subject_ field of the certificate we are evaluating must be trusted for validation to be successful.
+
--
* The _Subject Public Key Info_ field gives the algorithm and public key belonging to the entity specified in the _Subject_ field.
+
In this case, the public key is an RSA public key with a 2048-bit modulus and public exponent of 65537. The subject is in possession of the matching RSA private key (modulus plus private exponent) that is paired to the public key. If the private key is compromised, or if the public key needs to be changed for other reasons, the public and private keys must be regenerated and a new certificate issued. The old certificate is then revoked.
--

* Version 3 X.509 certificates may include zero or more _extensions_.
+
Extensions are either critical or noncritical, and some are required by the Internet profile in [RFC5280]. If critical, an extension must be processed and found acceptable by the relying party’s (CPS jargon) policy. Noncritical extensions are processed if supported but do not otherwise cause errors.
+
--
* The _Basic Constraints_ extension, a critical extension, indicates whether the certificate is a CA certificate.
+
In this case it is not, so it cannot be used for signing other certificates. A certificate indicating that it is a CA certificate may be used in a certificate validation chain at a location other than a leaf. This is common for root CA certificates or for other certificate-signing certificates (“intermediate” certificates, such as the `DigiCert EV RSA CA G2` certificate referenced in this example).

* The _Subject Key Identifier_ extension identifies the public key in the certificate.
+
It allows different keys owned by the same subject to be differentiated.

* The _Key Usage_ extension, a critical extension, determines the valid usage for the key.
+
Possible usages include _digital signature_, _nonrepudiation_ (content commitment), _key encipherment_, _data encipherment_, _key agreement_, _certificate signing_, _CRL signing_, _encipher only_, and _decipher only_.
+
Because server certificates of this kind are primarily used for identifying the two endpoints of a connection and encrypting a session key, the possible usages may be somewhat limited, as in this case.

* The _Extended Key Usage_ extension, which may be critical or noncritical, may provide further restrictions on the key use.
+
Possible values of this extension when used in the Internet profile include the following: _TLS client and server authentication_, _signing of downloadable code_, _e-mail protection_ (nonrepudiation and key agreement or encipherment), various _IPsec operating modes_, and _timestamping_.

* The _SAN_ extension allows a single certificate to be used for multiple purposes (e.g., for multiple Web sites with distinct DNS names).
+
This alleviates the need to have a separate certificate for each Web site, which can significantly reduce cost and administrative burden.
+
In this case, the certificate can be used for either of the DNS names `www.digicert.com` or `content.digicert.com` (and also `digicert.com`), and so on.
+
* The _CRL Distribution Points_ (CDP) extension gives a list of URLs for finding the CA’s certificate revocation list (CRL), a list of revoked certificates used to determine if a certificate in a validation chain has been revoked.

* The _Certificate Policies_ (CP) extension includes certificate policies applicable to the certificate <<RFC5280>>.
+
In this example, the CP extension contains three qulifiers, that is, two policies, and a CPS qualifier. The _Policy_ value of `2.16.840.1.114412.2.1`, a DigiCert Object Identifier (OID), and the _Policy_ value of `2.23.140.1.1`, a CABF OID, both indicate that the certificate complies with an EV policy. The _CPS_ qualifier gives a pointer to the URI where the particular applicable CPS for the policy may be found.

* The _Authority Key Identifier_ identifies the public key corresponding to the private key used to sign the certificate. It is useful when an issuer has multiple private keys used for generating signatures.

* The _Authority Information Access_ (AIA) extension indicates where information may be retrieved from the CA.
+
In this case, it indicates a URI used to determine if the certificate has been revoked using an online query protocol. It also indicates the list of CA issuers, which includes a URL containing the CA certificate responsible for signing the example server certificate.

* Following the extensions, the certificate contains the signature portion. It contains the identification of the signature algorithm (SHA-2 with RSA here), which must match the _Signature Algorithm_ field we encountered earlier.
+
In this case, the signature itself is a 256-byte value, corresponding to the 2048-bit modulus used for this use of RSA.
--

// [appendix]
// === Extended Validation Certificate

An *Extended Validation Certificate* (*EV*) is a certificate conforming to X.509 that proves the legal entity of the owner and is signed by a certificate authority key that can issue EV certificates. EV certificates can be used in the same manner as any other X.509 certificates, including securing web communications with HTTPS and signing software and documents. Unlike _domain-validated certificates_ and _organization-validation certificates_, EV certificates can be issued only by a subset of certificate authorities (CAs) and require verification of the requesting entity's legal identity before certificate issuance. <<EVCWIKIPEDIA>> 

* Removal of special UI indicators
+
In May 2018, Google announced plans to redesign user interfaces of Google Chrome to remove emphasis for EV certificates. Chrome 77, released in 2019, removed the EV certificate indication from omnibox, but EV certificate status can be viewed by clicking on lock icon and then checking for legal entity name listed as "issued to" under "certificate". Firefox 70 removed the distinction in the omnibox or URL bar (EV and DV certificates are displayed similarly with just a lock icon), but the details about certificate EV status are accessible in the more detailed view that opens after click on the lock icon.<<EVCWIKIPEDIA>>

* Extended Validation certificate identification
+
EV certificates are standard X.509 digital certificates. The primary way to identify an EV certificate is by referencing the Certificate Policies extension field. Each issuer uses a different _object identifier_ (OID) in this field to identify their EV certificates, and each OID is documented in the issuer's Certification Practice Statement. As with root certificate authorities in general, browsers may not recognize all issuers. <<EVCWIKIPEDIA>>
+
[source,console]
----
$ openssl s_client -connect www.globalsign.com:443 2>1 | openssl x509 -noout -ext certificatePolicies
X509v3 Certificate Policies: 
    Policy: 1.3.6.1.4.1.4146.1.1
      CPS: https://www.globalsign.com/repository/
    Policy: 2.23.140.1.1
----
+
.CA/Browser Forum CP OID
[%header,cols="1,1,1,1"]
|===
|Certificate Policy (CP)
|CA/Browser Forum CP OID <<CABFOID>>
|DigiCert CP (OID) [Legacy] <<DIGICERTCPS>>
|GlobalSign CP (OID) [Legacy] <<GLOBALSIGNCP>>

|Extended Validation Certificate Policy
|2.23.140.1.1
|2.16.840.1.114412.2.1
|1.3.6.1.4.1.4146.1.1

|EV Code Signing Certificates Policy
|2.23.140.1.3
|
|1.3.6.1.4.1.4146.1.2

|Domain Validation Certificates Policy
|2.23.140.1.2.1
|2.16.840.1.114412.1.2
|1.3.6.1.4.1.4146.1.10

|Organization Validation Certificates Policy
|2.23.140.1.2.2
|2.16.840.1.114412.1.1
|1.3.6.1.4.1.4146.1.20

|Individual Validation Certificate Policy
|2.23.140.1.2.3
|2.16.840.1.114412.1.1
|

|===
+
EV certificates represent an industry response to certain phishing attacks involving malicious Web sites that were issued certificates without rigorous identity proofing. Issuing of an EV certificate takes place only under an agreed-upon set of stringent criteria, and a user visiting a Web site using EV certificates and a modern browser typically sees a _green_ title bar and CA information to indicate the enhanced level of rigor.

One of the requirements for EV certificates placed upon each CA is to provide a _certification practice statement_ (CPS), which outlines the practices used in issuing certificates. Considerations for authors of CPSs (and _certificate policies_ or CPs that apply on a per-certificate basis) are given in <<RFC5280>>.

Note that although EV certificates may provide higher assurance (e.g., for some Web sites), most users do not pay careful attention to the cues provided by Web browsers that reveal this fact <<BOPSW09>>.

=== Validating and Revoking Certificates

Within the IETF, <<RFC5280>> defines the use of X.509 version 3 certificates with X.509 version 2 CRLs for the Internet that a certificate may have to be revoked and possibly replaced with a freshly issued certificate.

To validate a certificate, a _validation_ or _certification path_ must be established that includes a set of validated certificates, usually up to some trust anchor (e.g., root certificate) that is already known to the relying party. One of the key steps involves determining if one or more of the certificates in a chain have been revoked. If so, the path validation fails.

In the Internet, there are two primary ways to ensure that entities that wish to use a certificate become aware if it has been revoked: CRLs and the _Online Certificate Status Protocol_ (OCSP) [RFC2560].

When the _CRL Distribution Point_ extension includes an HTTP or FTP URI scheme, as it does in the preceding example, the complete URL gives the name of a file encoded in DER format containing an X.509 CRL. In our example, we can retrieve the CRL corresponding to the certificate using the following command:

[source,console]
----
$ wget -q http://crl3.digicert.com/DigiCertEVRSACAG2.crl
----

and print it out as follows:

[source,console]
----
$ openssl crl -inform DER -in DigiCertEVRSACAG2.crl -text 
Certificate Revocation List (CRL):
        Version 2 (0x1)
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = US, O = DigiCert Inc, CN = DigiCert EV RSA CA G2
        Last Update: Jul 31 19:48:27 2023 GMT
        Next Update: Aug  7 19:48:27 2023 GMT
        CRL extensions:
            X509v3 Authority Key Identifier: 
                6A:4E:50:BF:98:68:9D:5B:7B:20:75:D4:59:01:79:48:66:92:32:06
            X509v3 CRL Number: 
                1121
Revoked Certificates:
    Serial Number: 06AA5017961021B47CA95CE01C312405
        Revocation Date: Jul  8 17:31:01 2022 GMT
    Serial Number: 02FDC9206F81D00E3311F7B6D920B1A2
        Revocation Date: Jul 13 15:19:23 2022 GMT
    ...
    Serial Number: 0C2C2310AFDFF58F2E4A6454FA7B7801
        Revocation Date: Jul 31 17:32:07 2023 GMT
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        1f:ee:29:c7:fa:46:03:85:4a:cc:e0:c4:0b:9d:cd:cf:ea:4c:
        ...
        27:ca:42:1b
-----BEGIN X509 CRL-----
MIMCHE8wgwIbNgIBATANBgkqhkiG9w0BAQsFADBEMQswCQYDVQQGEwJVUzEVMBMG
...
3gwZtF3ABgkVW2jJCbM5+tDZzf/jSapQ3fOoPMNqCEknykIb
-----END X509 CRL-----
----

Here we can see the format of an X.509 v2 CRL.

* The format is very similar to that of a certificate, and the entire message is signed by a CA as certificates are.
+
This is useful because CRLs can be distributed like certificates: using otherwise untrusted communication channels and servers.

* In comparison with a certificate, the validity period is replaced by a list of the previous and next CRL updates.

* There is no subject and no public key but instead a list of serial numbers for revoked certificates plus the time and reason for revocation.

* There may also be CRL extensions that are unique to CRLs.
+
In this example, the _Authority Key Identifier_ extension gives a number identifying the key used by the CA in signing the CRL. The _CRL Number_ extension gives the sequence number of the CRL. Other values are given in <<RFC5280>>.

OCSP (_Online Certificate Status Protocol_), the other primary method for determining if a certificate has been revoked, is an application-level request/response protocol usually operated over HTTP (i.e., using the HTTP protocol with TCP/IP on TCP port 80).

* An OCSP request includes information identifying a particular certificate, plus some optional extensions. A response indicates whether the certificate is not revoked, unknown, or revoked. An error may be returned if the request cannot be parsed or otherwise acted upon.

* The key used for signing the OCSP response need not necessarily match the key used to sign the original certificate. This is possible if the issuer included a _Key Usage_ extension indicating an alternate OCSP provider.

* To see an OCSP request/response exchange, we can execute the following commands:
+
[source,console]
----
$ # CONNECTED COMMANDS: Q   End the current SSL connection and exit.
$ echo "Q" | \
> openssl s_client -connect www.digicert.com:443 2>1 | openssl x509 -out DigiCert.pem

$ echo "Q" | \
> openssl s_client -connect www.digicert.com:443 2>1 | openssl x509 -noout -subject -issuer -ext authorityInfoAccess
subject=jurisdictionC = US, jurisdictionST = Utah, businessCategory = Private Organization, serialNumber = 5299537-0142, C = US, ST = Utah, L = Lehi, O = "DigiCert, Inc.", CN = www.digicert.com
issuer=C = US, O = DigiCert Inc, CN = DigiCert EV RSA CA G2
Authority Information Access: 
    OCSP - URI:http://ocsp.digicert.com
    CA Issuers - URI:http://cacerts.digicert.com/DigiCertEVRSACAG2.crt
$ wget -q http://cacerts.digicert.com/DigiCertEVRSACAG2.crt

$ CA=DigiCertEVRSACAG2.crt
$ CERT=DigiCert.pem
$ OSCPURL=http://ocsp.digicert.com
$ openssl ocsp -issuer $CA -cert $CERT -url $OSCPURL -VAfile $CA -no_nonce -text
OCSP Request Data:
    Version: 1 (0x0)
    Requestor List:
        Certificate ID:
          Hash Algorithm: sha1
          Issuer Name Hash: D613075FB6DEA11BDF0182D397E1D37C6E925509
          Issuer Key Hash: 6A4E50BF98689D5B7B2075D45901794866923206
          Serial Number: 09FCB7403FFD79B68FE24F74805F5D00
OCSP Response Data:
    OCSP Response Status: successful (0x0)
    Response Type: Basic OCSP Response
    Version: 1 (0x0)
    Responder Id: 6A4E50BF98689D5B7B2075D45901794866923206
    Produced At: Aug  1 20:19:18 2023 GMT
    Responses:
    Certificate ID:
      Hash Algorithm: sha1
      Issuer Name Hash: D613075FB6DEA11BDF0182D397E1D37C6E925509
      Issuer Key Hash: 6A4E50BF98689D5B7B2075D45901794866923206
      Serial Number: 09FCB7403FFD79B68FE24F74805F5D00
    Cert Status: good
    This Update: Aug  1 20:03:02 2023 GMT
    Next Update: Aug  8 19:03:02 2023 GMT

    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        49:59:d8:0f:6c:e4:12:41:ab:0e:7a:4a:ad:94:7c:20:04:5e:
        ...
        bf:cf:a4:ad:95:2b:4b:16:f8:8c:61:79:63:48:42:57:d3:d2:
        21:6a:d3:fe
Response verify OK
DigiCert.pem: good
	This Update: Aug  1 20:03:02 2023 GMT
	Next Update: Aug  8 19:03:02 2023 GMT
----
+
--
* The request included the identification of a hash algorithm (SHA-1), a hash of the issuer name, a number identifying the issuer’s key (the same as the _Authority Key Identifier_ extension in the certificate), plus the certificate’s serial number.

* The responder, identified by the responder ID, identifies itself and signs the response. The response includes the hashes and numbers from the request, as well as the certificate status of “good” (i.e., not revoked).
--
+
NOTE: OCSP-based revocation is not an effective technique to mitigate against the compromise of an HTTPS server's private key. <<OCSPWIKIPEDIA>>

=== Attribute Certificates

In addition to public key certificates (PKCs) used to bind names to public keys, X.509 defines another type of certificate called an *attribute certificate* (AC).

* ACs are similar in structure to PKCs but lack a public key.

* They are used to indicate other information, including authorization information that may have a lifetime different from (e.g., shorter than) a corresponding PKC <<RFC5755>>.

* ACs contain other structures similar to PKCs, including extensions and AC policies.

[bibliography]
== References

* [[[TCPIPV1,1]]] Kevin Fall, W. Stevens _TCP/IP Illustrated: The Protocols, Volume 1_. 2nd edition, Addison-Wesley Professional, 2011
* [[[auth0-salt-hasing,2]]] https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/
* [[[CSWIKIPEDIA]]] https://en.wikipedia.org/wiki/Cipher_suite
* [[[FIPS186-3]]] National Institute for Standards and Technology, “Digital Signature Standard (DSS),” FIPS PUB 186-3, June 2009.
* [[[FIPS198]]] National Institute for Standards and Technology, “The Keyed-Hash Message Authentication Code (HMAC),” FIPS PUB 198, Mar. 2002.
* [[[FIPS800-38B]]] National Institute for Standards and Technology, “Recommendation for Block Cipher Modes of Operation: The CMAC Mode for Authentication,”NIST Special Publication 800-38B, May 2005.
* [[[NIST800-38D]]] National Institute for Standards and Technology, “Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC,”NIST Special Publication 800-38D, Nov. 2005.
* [[[RFC1321]]] R. Rivest, “The MD5 Message-Digest Algorithm,”Internet RFC 1321 (informational), Apr. 1992.
* [[[RFC2104]]] H. Krawczyk, M. Bellare, and R. Canetti, “HMAC: Keyed-Hashing for Message Authentication,”Internet RFC 2104 (informational), Feb. 1997.
* [[[RFC2631]]] E. Rescorla, “Diffie-Hellman Key Agreement Method,” Internet RFC 2631, June 1999.
* [[[RFC4086]]] D. Eastlake 3rd, J. Schiller, and S. Crocker, “Randomness Requirements for Security,”Internet RFC 4086/BCP 0106, June 2005.
* [[[RFC6234]]] D. Eastlake 3rd and T. Hansen, “US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF),”Internet RFC 6234 (informational), May 2011.
* [[[RFC2410]]] R. Glenn and S. Kent, “The NULL Encryption Algorithm and Its Use with IPsec,” Internet RFC 2410, Nov. 1998.
* [[[RFC3713]]] M. Matsui, J. Nakajima, and S. Moriai, “A Description of the Camellia Encryption Algorithm,”Internet RFC 3713 (informational), Apr. 2004.
* [[[RFC5116]]] D. McGrew, “An Interface and Algorithms for Authenticated Encryption,”Internet RFC 5116, Jan. 2008.
* [[[RFC6234]]] D. Eastlake 3rd and T. Hansen, “US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF),” Internet RFC 6234 (informational), May 2011.
* [[[RFC4615]]] J. Song, R. Poovendran, J. Lee, and T. Iwata, “The Advanced Encryption Standard-Cipher-Based Message Authentication Code-Pseudo-Random Function-128 (AES-CMAC-PRF-128) Algorithm for the Internet Key Exchange Protocol (IKE),” Internet RFC 4615, Aug. 2006.
* [[[RFC4434]]] P. Hoffman, “The AES-XCBC-PRF-128 Algorithm for the Internet Key Exchange Protocol (IKE),” Internet RFC 4434, Feb. 2006.
* [[[FIPS186-3]]] National Institute for Standards and Technology, “Digital Signature Standard (DSS),” FIPS PUB 186-3, June 2009.
* [[[X9.62-2005]]] American National Standards Institute, “Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Standard (ECDSA),” ANSI X9.62, 2005.
* [[[RFC4880]]] J. Callas, L. Donnerhacke, H. Finney, D. Shaw, and R. Thayer, “Open-PGP Message Format,” Internet RFC 4880, Nov. 2007.
* [[[NAZ00]]] Network Associates and P. Zimmermann, Introduction to Cryptography, Part of PGP 7.0 Documentation, available from http://www.pgpi.org/doc/guide/7.0/en
* [[[RFC6024]]] R. Reddy and C. Wallace, “Trust Anchor Management Requirements,” Internet RFC 6024 (informational), Oct. 2010.
* [[[]]RFC5280] D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, and W. Polk, “Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,” Internet RFC 5280, May 2008.
* [[[RFC3447]]] J. Jonsson and B. Kaliski, “Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1,” Internet RFC 3447 (informational), Feb. 2003.
* [[[RFC5652]]] R. Housley, “Cryptographic Message Syntax (CMS),” Internet RFC 5652/STD 0070, Sept. 2009.
* [[[CABF09]]] CA/Browser Forum, “Guidelines for the Issuance and Management of Extended Validation Certificates (v1.4.6),” 2009, https://cabforum.org/wp-content/uploads/EV-SSL-Certificate-Guidelines-Version-1.4.6.pdf
* [[[BOPSW09]]] R. Biddle et al., “Browser Interfaces and Extended Validation SSL Certificates: An Empirical Study,” Proc. ACM Cloud Security Workshop, Nov. 2009.
* [[[RFC5280]]] D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, and W. Polk, “Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,” Internet RFC 5280, May 2008.
* [[[EVCWIKIPEDIA]]] _Extended Validation Certificate - Wikipedia_ [online]. https://en.wikipedia.org/wiki/Extended_Validation_Certificate
* [[[SSLGREENBAR]]] _Why the green bar is gone for good | SSLs.com Blog_ [online]. https://www.ssls.com/blog/why-the-green-bar-is-gone-for-good/
* [[[SSLDVOVEV]]] _DV, OV, IV, and EV Certificates - SSL.com_ [online]. https://www.ssl.com/article/dv-ov-and-ev-certificates/
* [[[ITUOID]]] http://www.itu.int/ITU-T/asn1
* [[[CABFOID]]] https://cabforum.org/object-registry/
* [[[DIGICERTCPS]]] https://www.digicert.com/content/dam/digicert/pdfs/legal/DigiCert-CPS-V.5.6.pdf
* [[[GLOBALSIGNCP]]] https://www.globalsign.com/en/repository/GlobalSign_CP_v6.6_final.pdf
* [[[OCSPWIKIPEDIA]]] https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol
* [[[RFC5755]]] S. Farrell, R. Housley, and S. Turner, “An Internet Attribute Certificate Profile for Authorization,” Internet RFC 5755, Jan. 2010.
* [[[RFC4309]]] R. Housley, “Using Advanced Encryption Standard (AES) CCM Mode with IPsec Encapsulating Security Payload (ESP),” Internet RFC 4309, Dec. 2005.
* [[[OPENSSL]]] https://www.openssl.org/
