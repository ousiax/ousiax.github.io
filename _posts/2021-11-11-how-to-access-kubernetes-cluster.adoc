= How to access kubernetes cluster
:page-layout: post
:page-categories: ['kubernetes']
:page-tags: ['kubernetes', 'certificate', 'x509']
:page-date: 2021-11-11 13:40:22 +0800
:page-revdate: 2021-11-11 13:40:22 +0800
:sectnums:
:toc:

== Users in Kubernetes

All Kubernetes clusters have two categories of users: *service accounts* managed by Kubernetes, and *normal users*.

It is assumed that a cluster-independent service manages normal users in the following ways:

* an administrator distributing private keys
* a user store like Keystone or Google Accounts
* a file with a list of usernames and passwords

In this regard, Kubernetes does not have objects which represent normal user accounts. Normal users cannot be added to a cluster through an API call.

Even though a normal user cannot be added via an API call, _any user that presents a valid certificate signed by the cluster's certificate authority (CA) is considered authenticated_. In this configuration, Kubernetes determines the username from the common name field in the 'subject' of the cert (e.g., "/CN=bob"). From there, the role based access control (RBAC) sub-system would determine whether the user is authorized to perform a specific operation on a resource. For more details, refer to the normal users topic in https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user[certificate request] for more details about this.

In contrast, service accounts are users managed by the Kubernetes API. They are bound to specific namespaces, and created automatically by the API server or manually through API calls. Service accounts are tied to a set of credentials stored as `Secrets`, which are mounted into pods allowing _in-cluster_ processes to talk to the Kubernetes API.

API requests are tied to either a normal user or a service account, or are treated as https://kubernetes.io/docs/reference/access-authn-authz/authentication/#anonymous-requests[anonymous] requests. This means every process inside or outside the cluster, from a human user typing kubectl on a workstation, to kubelets on nodes, to members of the control plane, must authenticate when making requests to the API server, or be treated as an anonymous user.

When a request reaches the https://kubernetes.io/docs/concepts/overview/kubernetes-api/[Kubernetes API], it goes through several stages, illustrated in the following diagram:

image::https://d33wubrfki0l68.cloudfront.net/673dbafd771491a080c02c6de3fdd41b09623c90/50100/images/docs/admin/access-control-overview.svg[75%,75%,title="Diagram of request handling steps for Kubernetes API request"]

== Authentication strategies

Kubernetes uses *client certificates*, *bearer tokens*, an *authenticating proxy*, or *HTTP basic auth* to authenticate API requests through authentication plugins. As HTTP requests are made to the API server, plugins attempt to associate the following attributes with the request:

* `Username`: a string which identifies the end user. Common values might be `kube-admin` or `jane@example.com`.
* `UID`: a string which identifies the end user and attempts to be more consistent and unique than username.
* `Groups`: a set of strings, each of which indicates the user's membership in a named logical collection of users. Common values might be `system:masters` or `devops-team`.
* `Extra fields`: a map of strings to list of strings which holds additional information authorizers may find useful.

All values are opaque to the authentication system and only hold significance when interpreted by an https://kubernetes.io/docs/reference/access-authn-authz/authorization/[authorizer].

You can enable multiple authentication methods at once. You should usually use at least two methods:

* service account tokens for service accounts
* at least one other method for user authentication.

When multiple authenticator modules are enabled, the first module to successfully authenticate the request *_short-circuits_* evaluation. The API server does not guarantee the order authenticators run in.

The `system:authenticated` group is included in the list of groups for all authenticated users.

=== X509 Client Certs

Client certificate authentication is enabled by passing the `--client-ca-file=SOMEFILE` option to API server. The referenced file must contain one or more certificate authorities to use to validate client certificates presented to the API server. If a client certificate is presented and verified, the *_common name_* of the subject is used as the user name for the request. As of Kubernetes 1.4, client certificates can also indicate a user's group memberships using the certificate's *_organization_* fields. To include multiple group memberships for a user, include multiple organization fields in the certificate.

For example, using the `openssl` command line tool to generate a certificate signing request:

[source,sh]
----
openssl req \
    -nodes -newkey rsa -keyout jbeda.pem \
    -out jbeda-csr.pem -subj "/CN=jbeda/O=app1/O=app2"
----

This would create a CSR for the username "jbeda", belonging to two groups, "app1" and "app2".

[source,bash]
----
kubectl apply -f - << EOF
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: jbeda
spec:
  username: jbeda
  groups: ["app1", "app2"]
  request: $(base64 <(cat jbeda-csr.pem) | tr -d '\n')
  usages: ["digital signature", "key encipherment", "client auth"]
  expirationSeconds: 7200
  signerName: kubernetes.io/kube-apiserver-client
EOF
----

[source,sh]
kubectl certificate approve jbeda

[source,sh]
kubectl get csr jbeda -ojsonpath='{.status.certificate}' | base64 -d > jbeda.crt

[source,sh]
----
kubectl config set-cluster kubernetes \
    --kubeconfig jbeda.config \
    --server $(kubectl config view --minify | grep server | awk '{print $NF}') \
    --certificate-authority /etc/kubernetes/pki/ca.crt \
    --embed-certs

kubectl config set-credentials jbeda \
    --kubeconfig jbeda.config \
    --user jbeda \
    --client-key jbeda.pem \
    --client-certificate jbeda.crt \
    --embed-certs

kubectl config set-context \
    --kubeconfig jbeda.config \
    jbeda@kubernetes \
    --cluster kubernetes \
    --user jbeda

kubectl config use-context jbeda@kubernetes --kubeconfig jbeda.config
----

[source,console]
----
$ kubectl get ns --kubeconfig jbeda.config 
Error from server (Forbidden): namespaces is forbidden: User "jbeda" cannot list resource "namespaces" in API group "" at the cluster scope

$ kubectl create clusterrolebinding jbeda-cluster-view --clusterrole=view --user jbeda
clusterrolebinding.rbac.authorization.k8s.io/jbeda-cluster-view created

$ kubectl get ns --kubeconfig jbeda.config 
NAME              STATUS   AGE
default           Active   54d
ingress-nginx     Active   10d
kube-node-lease   Active   54d
kube-public       Active   54d
kube-system       Active   54d

$ kubectl delete clusterrolebindings jbeda-cluster-view 
clusterrolebinding.rbac.authorization.k8s.io "jbeda-cluster-view" deleted
----

=== Static Token File

The API server reads bearer tokens from a file when given the `--token-auth-file=SOMEFILE` option on the command line. Currently, tokens last indefinitely, and the token list cannot be changed without restarting API server.

The token file is a csv file with a minimum of 3 columns: token, user name, user uid, followed by optional group names.

[NOTE]
====
If you have more than one group the column must be double quoted e.g.

[source,csv]
token,user,uid,"group1,group2,group3"
====

=== Putting a Bearer Token in a Request

When using https://datatracker.ietf.org/doc/html/rfc6750[bearer token authentication] from an http client, the API server expects an `Authorization` header with a value of `Bearer THETOKEN`. The bearer token must be a character sequence that can be put in an HTTP header value using no more than the encoding and quoting facilities of HTTP. For example: if the bearer token is `31ada4fd-adec-460c-809a-9e56ceb75269` then it would appear in an HTTP header as shown below.

[source,text]
Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269

=== Service Account Tokens

A service account is an automatically enabled authenticator that uses signed bearer tokens to verify requests. The plugin takes two optional flags:

* `--service-account-key-file` A file containing a PEM encoded key for signing bearer tokens. If unspecified, the API server's TLS private key will be used.
* `--service-account-lookup` If enabled, tokens which are deleted from the API will be revoked.

Service accounts are usually created automatically by the API server and associated with pods running in the cluster through the `ServiceAccount` https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/[Admission Controller]. Bearer tokens are mounted into pods at well-known locations, and allow *_in-cluster_* processes to talk to the API server. Accounts may be explicitly associated with pods using the `serviceAccountName` field of a `PodSpec`.

Service account bearer tokens are perfectly valid to use *_outside the cluster_* and can be used to create identities for long standing jobs that wish to talk to the Kubernetes API. To manually create a service account, use the `kubectl create serviceaccount (NAME)` command. This creates a service account in the current namespace and an associated secret.

[source,console]
----
$ kubectl create serviceaccount jenkins
serviceaccount/jenkins created
----

Check an associated secret:

[source,console]
----
$ kubectl get serviceaccounts jenkins -oyaml
----

[source,yml]
----
apiVersion: v1
kind: ServiceAccount
metadata:
  # ...
secrets:
- name: jenkins-token-z792q
----

The created secret holds the public CA of the API server and a signed JSON Web Token (JWT).

[source,console]
----
$ kubectl get secrets jenkins-token-z792q -oyaml
----

[source,yml]
----
apiVersion: v1
data:
  ca.crt: (APISERVER'S CA BASE64 ENCODED)
  namespace: ZGVmYXVsdA==
  token: (BEARER TOKEN BASE64 ENCODED)
kind: Secret
metadata:
  # ...
type: kubernetes.io/service-account-token
----

NOTE: Values are base64 encoded because secrets are always base64 encoded. 

The signed JWT can be used as a bearer token to authenticate as the given service account. _Normally these secrets are mounted into pods for in-cluster access to the API server, but can be used from outside the cluster as well._

[source,sh]
----
token=$(kubectl get secrets jenkins-token-z792q -ojsonpath='{.data.token}' | base64 -d)
----

[source,sh]
----
echo $token cut -d '.' -f2 \
    | base64 -d \
    | jq
----

[source,console]
----
{
  "iss": "kubernetes/serviceaccount",
  "kubernetes.io/serviceaccount/namespace": "default",
  "kubernetes.io/serviceaccount/secret.name": "jenkins-token-z792q",
  "kubernetes.io/serviceaccount/service-account.name": "jenkins",
  "kubernetes.io/serviceaccount/service-account.uid": "7053145a-d791-48e1-829c-8d8852d36e4f",
  "sub": "system:serviceaccount:default:jenkins"
}
----

[source,sh]
----
curl -k https://localhost:6443/api/v1/namespaces/default \
    -H "Authorization: Bearer $token" \
    -H "Accept: application/yaml"
----

[source,console,highlight=2]
----
apiVersion: v1
code: 403
details:
  kind: namespaces
  name: default
kind: Status
message: 'namespaces "default" is forbidden: User "system:serviceaccount:default:jenkins"
  cannot get resource "namespaces" in API group "" in the namespace "default"'
metadata: {}
reason: Forbidden
status: Failure
----

Service accounts authenticate with the username `system:serviceaccount:(NAMESPACE):(SERVICEACCOUNT)`, and are assigned to the groups `system:serviceaccounts and system:serviceaccounts:(NAMESPACE)`.

WARNING: Because service account tokens are stored in secrets, any user with read access to those secrets can authenticate as the service account. Be cautious when granting permissions to service accounts and read capabilities for secrets.

== Authorization Overview

In Kubernetes, you must be authenticated (logged in) before your request can be authorized (granted permission to access).

Kubernetes expects attributes that are common to REST API requests. This means that Kubernetes authorization works with existing organization-wide or cloud-provider-wide access control systems which may handle other APIs besides the Kubernetes API.

=== Determine Whether a Request is Allowed or Denied

Kubernetes authorizes API requests using the API server. It evaluates all of the request attributes against all policies and allows or denies the request. All parts of an API request must be allowed by some policy in order to proceed. This means that permissions are denied by default.

(Although Kubernetes uses the API server, access controls and policies that depend on specific fields of specific kinds of objects are handled by *Admission Controllers*.)

When multiple authorization modules are configured, each is checked in sequence. If any authorizer approves or denies a request, that decision is immediately returned and no other authorizer is consulted. If all modules have no opinion on the request, then the request is denied. A deny returns an HTTP status code 403.

=== Review Your Request Attributes

Kubernetes reviews only the following API request attributes:

* *user* - The `user` string provided during authentication.
* *group* - The list of group names to which the authenticated user belongs.
* *extra* - A map of arbitrary string keys to string values, provided by the authentication layer.
* *API* - Indicates whether the request is for an API resource.
* *Request path* - Path to miscellaneous non-resource endpoints like `/api` or `/healthz`.
* *API request verb* - API verbs like `get`, `list`, `create`, `update`, `patch`, `watch`, `delete`, and `deletecollection` are used for resource requests.
* *HTTP request verb* - Lowercased HTTP methods like `get`, `post`, `put`, and `delete` are used for non-resource requests.
* *Resource* - The ID or name of the resource that is being accessed (for resource requests only) -- For resource requests using `get`, `update`, `patch`, and `delete` verbs, you must provide the resource name.
* *Subresource* - The subresource that is being accessed (for resource requests only).
* *Namespace* - The namespace of the object that is being accessed (for namespaced resource requests only).
* *API group* - The API Group being accessed (for resource requests only). An empty string designates the core https://kubernetes.io/docs/reference/using-api/#api-groups[API group].

=== Determine the Request Verb 

*Non-resource requests* Requests to endpoints other than `/api/v1/...` or `/apis/<group>/<version>/...` are considered "non-resource requests", and use the lower-cased HTTP method of the request as the verb. For example, a GET request to endpoints like `/api` or `/healthz` would use `get` as the verb.

*Resource requests* To determine the request verb for a resource API endpoint, review the HTTP verb used and whether or not the request acts on an individual resource or a collection of resources:

[%header,cols="1,7"]
|===
|HTTP verb
|request verb

|POST
|create

|GET, HEAD
|get (for individual resources), list (for collections, including full object content), watch (for watching an individual resource or collection of resources)

|PUT
|update

|PATCH
|patch

|DELETE
|delete (for individual resources), deletecollection (for collections)
|===

Kubernetes sometimes checks authorization for additional permissions using specialized verbs. For example:

* RBAC
+
`bind` and `escalate` verbs on `roles` and `clusterroles` resources in the `rbac.authorization.k8s.io` API group.

* Authentication
+
`impersonate` verb on `users`, `groups`, and `serviceaccounts` in the `core` API group, and the `userextras` in the `authentication.k8s.io` API group.

=== Authorization Modes

The Kubernetes API server may authorize a request using one of several authorization modes:

* *Node* - A special-purpose authorization mode that grants permissions to kubelets based on the pods they are scheduled to run.

* *ABAC* - Attribute-based access control (ABAC) defines an access control paradigm whereby access rights are granted to users through the use of policies which combine attributes together. The policies can use any type of attributes (user attributes, resource attributes, object, environment attributes, etc).

* *RBAC* - Role-based access control (RBAC) is a method of regulating access to computer or network resources based on the roles of individual users within an enterprise. In this context, access is the ability of an individual user to perform a specific task, such as view, create, or modify a file.
** When specified RBAC (Role-Based Access Control) uses the `rbac.authorization.k8s.io` API group to drive authorization decisions, allowing admins to dynamically configure permission policies through the Kubernetes API.
** To enable RBAC, start the apiserver with `--authorization-mode=RBAC`.

* *Webhook* - A WebHook is an HTTP callback: an HTTP POST that occurs when something happens; a simple event-notification via HTTP POST. A web application implementing WebHooks will POST a message to a URL when certain things happen. 

==== Checking API Access

kubectl provides the `auth can-i` subcommand for quickly querying the API authorization layer. The command uses the `SelfSubjectAccessReview` API to determine if the current user can perform a given action, and works regardless of the authorization mode used.

[source,sh]
kubectl auth can-i create deployments --namespace dev

The output is similar to this:

[source,console]
yes

[source,sh]
kubectl auth can-i create deployments --namespace prod

The output is similar to this:

[source,console]
no

Administrators can combine this with https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation[user impersonation] to determine what action other users can perform.

[source,sh]
kubectl auth can-i list secrets --namespace dev --as dave

The output is similar to this:

[source,console]
no

Similarly, to check whether a Service Account named `dev-sa` in Namespace `dev` can list Pods in the Namespace `target`:

[source,sh]
----
kubectl auth can-i list pods \
	--namespace target \
	--as system:serviceaccount:dev:dev-sa
----

The output is similar to this:

[source,console]
yes

`SelfSubjectAccessReview` is part of the `authorization.k8s.io` API group, which exposes the API server authorization to external services. Other resources in this group include:

* `SubjectAccessReview` - Access review for any user, not only the current one. Useful for delegating authorization decisions to the API server. For example, the kubelet and extension API servers use this to determine user access to their own APIs.
* `LocalSubjectAccessReview` - Like `SubjectAccessReview` but restricted to a specific namespace.
* `SelfSubjectRulesReview` - A review which returns the set of actions a user can perform within a namespace. Useful for users to quickly summarize their own access, or for UIs to hide/show actions.

These APIs can be queried by creating normal Kubernetes resources, where the response "status" field of the returned object is the result of the query.

[source,sh]
----
kubectl create -f - -o yaml << EOF
apiVersion: authorization.k8s.io/v1
kind: SelfSubjectAccessReview
spec:
  resourceAttributes:
    group: apps
    resource: deployments
    verb: create
    namespace: dev
EOF
----

The generated `SelfSubjectAccessReview` is:

[source,yaml]
----
apiVersion: authorization.k8s.io/v1
kind: SelfSubjectAccessReview
metadata:
  creationTimestamp: null
spec:
  resourceAttributes:
    group: apps
    namespace: dev
    resource: deployments
    verb: create
status:
  allowed: true
----

== Using RBAC Authorization

Role-based access control (RBAC) is a method of regulating access to computer or network resources based on the roles of individual users within your organization.

RBAC authorization uses the `rbac.authorization.k8s.io` API group to drive authorization decisions, allowing you to dynamically configure policies through the Kubernetes API.

The RBAC API declares four kinds of Kubernetes object: `Role`, `ClusterRole`, `RoleBinding` and `ClusterRoleBinding`.

=== Role and ClusterRole

An RBAC _Role_ or _ClusterRole_ contains rules that represent a set of permissions. Permissions are purely additive (there are no "deny" rules).

A *Role* always sets permissions within a particular namespace; when you create a Role, you have to specify the namespace it belongs in.

*ClusterRole*, by contrast, is a non-namespaced resource. The resources have different names (Role and ClusterRole) because a Kubernetes object always has to be either namespaced or not namespaced; it can't be both.

ClusterRoles have several uses. You can use a ClusterRole to:

* define permissions on namespaced resources and be granted within individual namespace(s)
* define permissions on namespaced resources and be granted across all namespaces
* define permissions on cluster-scoped resources

If you want to define a role within a namespace, use a Role; if you want to define a role cluster-wide, use a ClusterRole.
Role example 

* Role example
+
Here's an example Role in the "default" namespace that can be used to grant read access to pods:
+
[source,yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: pod-reader
rules:
- apiGroups: [""] # "" indicates the core API group
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
----

* ClusterRole example
+
A ClusterRole can be used to grant the same permissions as a Role. Because ClusterRoles are cluster-scoped, you can also use them to grant access to:
+
--
** cluster-scoped resources (like _nodes_)
** non-resource endpoints (like _/healthz_)
** namespaced resources (like _Pods_), across all namespaces
** For example: you can use a ClusterRole to allow a particular user to run _kubectl get pods --all-namespaces_
--
+
Here is an example of a ClusterRole that can be used to grant read access to secrets in any particular namespace, or across all namespaces (depending on how it is https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding[bound]):
+
[source,yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  # "namespace" omitted since ClusterRoles are not namespaced
  name: secret-reader
rules:
- apiGroups: [""]
  #
  # at the HTTP level, the name of the resource for accessing Secret
  # objects is "secrets"
  resources: ["secrets"]
  verbs: ["get", "watch", "list"]
----

:path-segment-names: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#path-segment-names

The name of a Role or a ClusterRole object must be a valid {path-segment-names}[path segment name].

=== RoleBinding and ClusterRoleBinding

A role binding grants the permissions defined in a role to a user or set of users. It holds a list of _subjects_ (users, groups, or service accounts), and a reference to the role being granted. A RoleBinding grants permissions within a specific namespace whereas a ClusterRoleBinding grants that access cluster-wide.

_A RoleBinding may reference any Role in the same namespace. Alternatively, a RoleBinding can reference a ClusterRole and bind that ClusterRole to the namespace of the RoleBinding. If you want to bind a ClusterRole to all the namespaces in your cluster, you use a ClusterRoleBinding.)_

The name of a RoleBinding or ClusterRoleBinding object must be a valid {path-segment-names}[path segment name].

* RoleBinding examples
+
Here is an example of a RoleBinding that grants the "pod-reader" Role to the user "jane" within the "default" namespace. This allows "jane" to read pods in the "default" namespace.
+
[source,yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
# This role binding allows "jane" to read pods in the "default" namespace.
# You need to already have a Role named "pod-reader" in that namespace.
kind: RoleBinding
metadata:
  name: read-pods
  namespace: default
subjects:
# You can specify more than one "subject"
- kind: User
  name: jane # "name" is case sensitive
  apiGroup: rbac.authorization.k8s.io
roleRef:
  # "roleRef" specifies the binding to a Role / ClusterRole
  kind: Role #this must be Role or ClusterRole
  name: pod-reader # this must match the name of the Role or ClusterRole you wish to bind to
  apiGroup: rbac.authorization.k8s.io
----
+
A RoleBinding can also reference a ClusterRole to grant the permissions defined in that ClusterRole to resources inside the RoleBinding's namespace. This kind of reference lets you define a set of common roles across your cluster, then reuse them within multiple namespaces.
+
For instance, even though the following RoleBinding refers to a ClusterRole, "dave" (the subject, case sensitive) will only be able to read Secrets in the "development" namespace, because the RoleBinding's namespace (in its metadata) is "development".
+
[source,yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
# This role binding allows "dave" to read secrets in the "development" namespace.
# You need to already have a ClusterRole named "secret-reader".
kind: RoleBinding
metadata:
  name: read-secrets
  #
  # The namespace of the RoleBinding determines where the permissions are granted.
  # This only grants permissions within the "development" namespace.
  namespace: development
subjects:
- kind: User
  name: dave # Name is case sensitive
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io
----

* ClusterRoleBinding example
+
To grant permissions across a whole cluster, you can use a ClusterRoleBinding. The following ClusterRoleBinding allows any user in the group "manager" to read secrets in any namespace.
+
[source,yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
# This cluster role binding allows anyone in the "manager" group to read secrets in any namespace.
kind: ClusterRoleBinding
metadata:
  name: read-secrets-global
subjects:
- kind: Group
  name: manager # Name is case sensitive
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io
----

=== Referring to resources

In the Kubernetes API, most resources are represented and accessed using a string representation of their object name, such as `pods` for a Pod. RBAC refers to resources using exactly the same name that appears in the URL for the relevant API endpoint. Some Kubernetes APIs involve a _subresource_, such as the logs for a Pod. A request for a Pod's logs looks like:

[source,console]
GET /api/v1/namespaces/{namespace}/pods/{name}/log

In this case, `pods` is the namespaced resource for Pod resources, and `log` is a subresource of pods. To represent this in an RBAC role, use a slash (`/`) to delimit the resource and subresource. To allow a subject to read `pods` and also access the `log` subresource for each of those Pods, you write:

[source,yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: pod-and-pod-logs-reader
rules:
- apiGroups: [""]
  resources: ["pods", "pods/log"]
  verbs: ["get", "list"]
----

You can also refer to resources by name for certain requests through the `resourceNames` list. When specified, requests can be restricted to individual instances of a resource. Here is an example that restricts its subject to only `get` or `update` a ConfigMap named `my-configmap`:

[source,yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: configmap-updater
rules:
- apiGroups: [""]
  #
  # at the HTTP level, the name of the resource for accessing ConfigMap
  # objects is "configmaps"
  resources: ["configmaps"]
  resourceNames: ["my-configmap"]
  verbs: ["update", "get"]
----

=== Aggregated ClusterRoles

You can _aggregate_ several ClusterRoles into one combined ClusterRole. A controller, running as part of the cluster control plane, watches for ClusterRole objects with an `aggregationRule` set. The `aggregationRule` defines a label selector that the controller uses to match other ClusterRole objects that should be combined into the `rules` field of this one.

Here is an example aggregated ClusterRole:

[source,yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: monitoring
aggregationRule:
  clusterRoleSelectors:
  - matchLabels:
      rbac.example.com/aggregate-to-monitoring: "true"
rules: [] # The control plane automatically fills in the rules
----

_If you create a new ClusterRole that matches the label selector of an existing aggregated ClusterRole, that change triggers adding the new rules into the aggregated ClusterRole._

=== Referring to subjects

A RoleBinding or ClusterRoleBinding binds a role to subjects. Subjects can be groups, users or ServiceAccounts.

Kubernetes represents usernames as strings. These can be: plain names, such as "alice"; email-style names, like "+++bob@example.com+++"; or numeric user IDs represented as a string. It is up to you as a cluster administrator to configure the authentication modules so that authentication produces usernames in the format you want.

CAUTION: The prefix `system:` is reserved for Kubernetes system use, so you should ensure that you don't have users or groups with names that start with `system:` by accident. Other than this special prefix, the RBAC authorization system does not require any format for usernames.

In Kubernetes, Authenticator modules provide group information. Groups, like users, are represented as strings, and that string has no format requirements, other than that the prefix `system:` is reserved.

ServiceAccounts have names prefixed with `system:serviceaccount:`, and belong to groups that have names prefixed with `system:serviceaccounts:`.

[NOTE]
====
* `system:serviceaccount:` (singular) is the prefix for service account usernames.
* `system:serviceaccounts:` (plural) is the prefix for service account groups.
====

=== Default roles and role bindings

API servers create a set of default ClusterRole and ClusterRoleBinding objects. Many of these are `system:` prefixed, which indicates that the resource is directly managed by the cluster control plane. All of the default ClusterRoles and ClusterRoleBindings are labeled with `kubernetes.io/bootstrapping=rbac-defaults`.

CAUTION: Take care when modifying ClusterRoles and ClusterRoleBindings with names that have a `system:` prefix. Modifications to these resources can result in non-functional clusters.

* Auto-reconciliation
+
At each start-up, the API server updates default cluster roles with any missing permissions, and updates default cluster role bindings with any missing subjects. This allows the cluster to repair accidental modifications, and helps to keep roles and role bindings up-to-date as permissions and subjects change in new Kubernetes releases.
+
To opt out of this reconciliation, set the `rbac.authorization.kubernetes.io/autoupdate` annotation on a default cluster role or rolebinding to `false`. Be aware that missing default permissions and subjects can result in non-functional clusters.
+
Auto-reconciliation is enabled by default if the RBAC authorizer is active.

* User-facing roles
+
Some of the default ClusterRoles are not `system:` prefixed. These are intended to be user-facing roles. They include super-user roles (`cluster-admin`), roles intended to be granted cluster-wide using ClusterRoleBindings, and roles intended to be granted within particular namespaces using RoleBindings (`admin`, `edit`, `view`).
+
User-facing ClusterRoles use ClusterRole _aggregation_ to allow admins to include rules for custom resources on these ClusterRoles. To add rules to the `admin`, `edit`, or `view` roles, create a ClusterRole with one or more of the following labels:
+
[source,yaml]
----
metadata:
  labels:
    rbac.authorization.k8s.io/aggregate-to-admin: "true"
    rbac.authorization.k8s.io/aggregate-to-edit: "true"
    rbac.authorization.k8s.io/aggregate-to-view: "true"
----

== Accessing with `kubectl`

When accessing the Kubernetes API for the first time, we suggest using the Kubernetes CLI, `kubectl`.

To access a cluster, you need to know the location of the cluster and have credentials to access it.

Check the location and credentials that kubectl knows about with this command:

[source,sh]
kubectl config view

Many of the https://kubernetes.io/docs/reference/kubectl/cheatsheet/[examples] provide an introduction to using kubectl and complete documentation is found in the https://kubernetes.io/docs/reference/kubectl/overview/[kubectl manual].

== Directly accessing the REST API 

Kubectl handles locating and authenticating to the apiserver. If you want to directly access the REST API with an http client like curl or wget, or a browser, there are several ways to locate and authenticate:

* Run kubectl in proxy mode.
** Recommended approach.
*** Uses stored apiserver location.
*** Verifies identity of apiserver using self-signed cert. No MITM possible.
*** Authenticates to apiserver.
*** In future, may do intelligent client-side load-balancing and failover.
** Provide the location and credentials directly to the http client.
*** Alternate approach.
*** Works with some types of client code that are confused by using a proxy.
*** Need to import a root cert into your browser to protect against MITM.

=== Using kubectl proxy 

The following command runs kubectl in a mode where it acts as a reverse proxy. It handles locating the apiserver and authenticating. Run it like this:

[source,sh]
kubectl proxy --port 8080 --address [::1]

See https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/#proxy[kubectl proxy] for more details.

Then you can explore the API with curl, wget, or a browser, replacing localhost with [::1] for IPv6, like so:

[source,sh]
curl -i6  http://localhost:8080/api/

The output is similar to this:

[source,console]
----
HTTP/1.1 200 OK
Audit-Id: e7dc7494-c763-4888-8e5b-2d0bd3b29746
Cache-Control: no-cache, private
Content-Length: 186
Content-Type: application/json
Date: Thu, 11 Nov 2021 05:55:19 GMT
X-Kubernetes-Pf-Flowschema-Uid: 493378c9-c25f-4280-a891-f58e097ddfc0
X-Kubernetes-Pf-Prioritylevel-Uid: 10b96c65-c47e-4144-b335-b896a44b84d0

{
  "kind": "APIVersions",
  "versions": [
    "v1"
  ],
  "serverAddressByClientCIDRs": [
    {
      "clientCIDR": "0.0.0.0/0",
      "serverAddress": "104.197.5.247:6443"
    }
  ]
}
----

=== Without kubectl proxy

* Use `kubectl describe secret...` to get the token for the default service account with _grep/cut_:
+
[souce,sh]
----
APISERVER=$(kubectl config view --minify | grep server | cut -f 2- -d ":" | tr -d " ")
SECRET_NAME=$(kubectl get secrets | grep ^default | cut -f1 -d ' ')
TOKEN=$(kubectl describe secret $SECRET_NAME | grep -E '^token' | cut -f2 -d':' | tr -d " ")

curl $APISERVER/api --header "Authorization: Bearer $TOKEN" --insecure
----
+
The output is similar to this:
+
[source,console]
----
{
  "kind": "APIVersions",
  "versions": [
    "v1"
  ],
  "serverAddressByClientCIDRs": [
    {
      "clientCIDR": "0.0.0.0/0",
      "serverAddress": "104.197.5.247:6443"
    }
  ]
}
----

* Using `jsonpath`:
+
[source,sh]
----
APISERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
SECRET_NAME=$(kubectl get serviceaccount default -o jsonpath='{.secrets[0].name}')
TOKEN=$(kubectl get secret $SECRET_NAME -o jsonpath='{.data.token}' | base64 --decode)

curl $APISERVER/api --header "Authorization: Bearer $TOKEN" --insecure
----

The above examples use the `--insecure` flag. This leaves it subject to MITM attacks. When kubectl accesses the cluster it uses a stored root certificate and client certificates to access the server. (These are installed in the `~/.kube` directory). Since cluster certificates are typically self-signed, it may take special configuration to get your http client to use root certificate.

On some clusters, the apiserver does not require authentication; it may serve on localhost, or be protected by a firewall. There is not a standard for this. Controlling Access to the API describes how a cluster admin can configure this.

== Programmatic access to the API

Kubernetes officially supports https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/#go-client[Go] and https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/#python-client[Python] client libraries.

==== Go client 

* To get the library, run the following command: `go get k8s.io/client-go@kubernetes-<kubernetes-version-number>`, see https://github.com/kubernetes/client-go/blob/master/INSTALL.md#for-the-casual-user[INSTALL.md] for detailed installation instructions. See https://github.com/kubernetes/client-go to see which versions are supported.
* Write an application atop of the client-go clients. Note that client-go defines its own API objects, so if needed, please import API definitions from client-go rather than from the main repository, e.g., `import "k8s.io/client-go/kubernetes"` is correct.

The Go client can use the same https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/[kubeconfig file] as the kubectl CLI does to locate and authenticate to the apiserver.

[source,go]
----
package main

import (
	"flag"
	"path/filepath"

	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/homedir"
)

func main() {
	var kubeconfig *string
	if home := homedir.HomeDir(); home != "" {
		kubeconfig = flag.String("kubeconfig", filepath.Join(home, ".kube", "config"), "(optional) absolute path to the kubeconfig file")
	} else {
		kubeconfig = flag.String("kubeconfig", "", "absolute path to the kubeconfig file")
	}
	flag.Parse()

	// use the current context in kubeconfig
	config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	if err != nil {
		panic(err.Error())
	}

	_ = config
}
----

If the application is deployed as a Pod in the cluster, please refer to the link:#accessing-the-api-from-a-pod[next section].

== Accessing the API from a Pod

When accessing the API from a pod, locating and authenticating to the apiserver are somewhat different.

The recommended way to locate the apiserver within the pod is with the `kubernetes.default.svc` DNS name, which resolves to a Service IP which in turn will be routed to an apiserver.

The recommended way to authenticate to the apiserver is with a https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[service account] credential. By kube-system, a pod is associated with a service account, and a credential (token) for that service account is placed into the filesystem tree of each container in that pod, at `/var/run/secrets/kubernetes.io/serviceaccount/token`.

If available, a certificate bundle is placed into the filesystem tree of each container at `/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`, and should be used to verify the serving certificate of the apiserver.

Finally, the default namespace to be used for namespaced API operations is placed in a file at `/var/run/secrets/kubernetes.io/serviceaccount/namespace` in each container.

From within a pod the recommended ways to connect to API are:

* Run `kubectl proxy` in a sidecar container in the pod, or as a background process within the container. This proxies the Kubernetes API to the localhost interface of the pod, so that other processes in any container of the pod can access it.
* Use the Go client library, and create a client using the `rest.InClusterConfig()` and `kubernetes.NewForConfig()` functions. They handle locating and authenticating to the apiserver.
+
[source,go]
----
package main

import (
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

func main() {
	// creates the in-cluster config
	config, err := rest.InClusterConfig()
	if err != nil {
		panic(err.Error())
	}
	// creates the clientset
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		panic(err.Error())
	}
	_ = clientset
}
----

In each case, the credentials of the pod are used to communicate securely with the apiserver.

== Accessing services running on the cluster

In Kubernetes, the *nodes*, *pods* and *services* all have their own IPs. In many cases, the node IPs, pod IPs, and some service IPs on a cluster will not be routable, so they will not be reachable from a machine outside the cluster, such as your desktop machine.

=== Ways to connect

You have several options for connecting to nodes, pods and services from outside the cluster:

* Access services through public IPs.
** Use a service with type `NodePort` or `LoadBalancer` to make the service reachable outside the cluster.
** Depending on your cluster environment, this may only expose the service to your corporate network, or it may expose it to the internet. Think about whether the service being exposed is secure. Does it do its own authentication?
** Place pods behind services. To access one specific pod from a set of replicas, such as for debugging, place a unique label on the pod and create a new service which selects this label.
** In most cases, it should not be necessary for application developer to directly access nodes via their nodeIPs.
* Access services, nodes, or pods using the Proxy Verb.
** Does apiserver authentication and authorization prior to accessing the remote service. Use this if the services are not secure enough to expose to the internet, or to gain access to ports on the node IP, or for debugging.
** Proxies may cause problems for some web applications.
** Only works for HTTP/HTTPS.
* Access from a node or pod in the cluster.
** Run a pod, and then connect to a shell in it using https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/#exec[kubectl exec]. Connect to other nodes, pods, and services from that shell.
** Some clusters may allow you to ssh to a node in the cluster. From there you may be able to access cluster services. This is a non-standard method, and will work on some clusters but not others. Browsers and other tools may or may not be installed. Cluster DNS may not work.

=== Discovering builtin services 

Typically, there are several services which are started on a cluster by kube-system. Get a list of these with the kubectl cluster-info command:

[souce,sh]
kubectl cluster-info

The output is similar to this:

[souce,console]
----
Kubernetes control plane is running at https://104.197.5.247:6443
CoreDNS is running at https://104.197.5.247:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
----

[source,yaml,highlight='6-9,12']
----
#$ kubectl get svc -n kube-system kube-dns -oyaml
apiVersion: v1
kind: Service
metadata:
  labels:
    kubernetes.io/cluster-service: "true"
    kubernetes.io/name: CoreDNS
  name: kube-dns
  namespace: kube-system
spec:
  ports:
  - name: dns
    port: 53
    protocol: UDP
    targetPort: 53
...
----

This shows the proxy-verb URL for accessing each service. For example, this cluster has cluster-level logging enabled (using Elasticsearch), which can be reached at `https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/` if suitable credentials are passed. Logging can also be reached through a kubectl proxy, for example at: `http://localhost:8080/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/`.

=== Manually constructing apiserver proxy URLs 

As mentioned above, you use the `kubectl cluster-info` command to retrieve the service's proxy URL. To create proxy URLs that include service endpoints, suffixes, and parameters, you append to the service's proxy URL: +++http:+++//_kubernetes_master_address_/api/v1/namespaces/_namespace_name_/services/_service_name[:port_name]_/proxy

If you haven't specified a name for your port, you don't have to specify port_name in the URL. You can also use the port number in place of the port_name for both named and unnamed ports.

By default, the API server proxies to your service using http. To use https, prefix the service name with https:: pass:[http]://kubernetes_master_address/api/v1/namespaces/namespace_name/services/_pass:[https]:service_name:[port_name]_/proxy

The supported formats for the name segment of the URL are:

* `<service_name>` - proxies to the default or unnamed port using http
* `<service_name>:<port_name>` - proxies to the specified port name or port number using http
* `https:<service_name>:` - proxies to the default or unnamed port using https (note the trailing colon)
* `https:<service_name>:<port_name>` - proxies to the specified port name or port number using https

*Examples*

* To access the Elasticsearch service endpoint `_search?q=user:kimchy`, you would use: `http://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_search?q=user:kimchy`
* To access the Elasticsearch cluster health information `_cluster/health?pretty=true`, you would use: `https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_cluster/health?pretty=true`

== References

* https://kubernetes.io/docs/reference/access-authn-authz/authentication/
* https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/
* https://kubernetes.io/docs/reference/access-authn-authz/authorization/
* https://kubernetes.io/docs/reference/access-authn-authz/rbac
* https://kubernetes.io/docs/reference/kubectl/cheatsheet/
* https://kubernetes.io/docs/reference/kubectl/overview/
* https://github.com/ahmetb/kubectx/blob/master/kubens
* https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/
* https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
* https://datatracker.ietf.org/doc/html/rfc6750
