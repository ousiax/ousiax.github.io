= How to access kubernetes cluster
:page-layout: post
:page-categories: ['kubernetes']
:page-tags: ['kubernetes', 'certificate', 'x509']
:page-date: 2021-11-11 13:40:22 +0800
:page-revdate: 2021-11-11 13:40:22 +0800
:sectnums:
:toc:

== Accessing for the first time with `kubectl`

When accessing the Kubernetes API for the first time, we suggest using the Kubernetes CLI, `kubectl`.

To access a cluster, you need to know the location of the cluster and have credentials to access it.

Check the location and credentials that kubectl knows about with this command:

[source,sh]
kubectl config view

Many of the https://kubernetes.io/docs/reference/kubectl/cheatsheet/[examples] provide an introduction to using kubectl and complete documentation is found in the https://kubernetes.io/docs/reference/kubectl/overview/[kubectl manual].

== Directly accessing the REST API 

Kubectl handles locating and authenticating to the apiserver. If you want to directly access the REST API with an http client like curl or wget, or a browser, there are several ways to locate and authenticate:

* Run kubectl in proxy mode.
** Recommended approach.
*** Uses stored apiserver location.
*** Verifies identity of apiserver using self-signed cert. No MITM possible.
*** Authenticates to apiserver.
*** In future, may do intelligent client-side load-balancing and failover.
** Provide the location and credentials directly to the http client.
*** Alternate approach.
*** Works with some types of client code that are confused by using a proxy.
*** Need to import a root cert into your browser to protect against MITM.

=== Using kubectl proxy 

The following command runs kubectl in a mode where it acts as a reverse proxy. It handles locating the apiserver and authenticating. Run it like this:

[source,sh]
kubectl proxy --port 8080 --address [::1]

See https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/#proxy[kubectl proxy] for more details.

Then you can explore the API with curl, wget, or a browser, replacing localhost with [::1] for IPv6, like so:

[source,sh]
curl -i6  http://localhost:8080/api/

The output is similar to this:

[source,console]
----
HTTP/1.1 200 OK
Audit-Id: e7dc7494-c763-4888-8e5b-2d0bd3b29746
Cache-Control: no-cache, private
Content-Length: 186
Content-Type: application/json
Date: Thu, 11 Nov 2021 05:55:19 GMT
X-Kubernetes-Pf-Flowschema-Uid: 493378c9-c25f-4280-a891-f58e097ddfc0
X-Kubernetes-Pf-Prioritylevel-Uid: 10b96c65-c47e-4144-b335-b896a44b84d0

{
  "kind": "APIVersions",
  "versions": [
    "v1"
  ],
  "serverAddressByClientCIDRs": [
    {
      "clientCIDR": "0.0.0.0/0",
      "serverAddress": "104.197.5.247:6443"
    }
  ]
}
----

=== Without kubectl proxy

* Use `kubectl describe secret...` to get the token for the default service account with _grep/cut_:
+
[souce,sh]
----
APISERVER=$(kubectl config view --minify | grep server | cut -f 2- -d ":" | tr -d " ")
SECRET_NAME=$(kubectl get secrets | grep ^default | cut -f1 -d ' ')
TOKEN=$(kubectl describe secret $SECRET_NAME | grep -E '^token' | cut -f2 -d':' | tr -d " ")

curl $APISERVER/api --header "Authorization: Bearer $TOKEN" --insecure
----
+
The output is similar to this:
+
[source,console]
----
{
  "kind": "APIVersions",
  "versions": [
    "v1"
  ],
  "serverAddressByClientCIDRs": [
    {
      "clientCIDR": "0.0.0.0/0",
      "serverAddress": "104.197.5.247:6443"
    }
  ]
}
----

* Using `jsonpath`:
+
[source,sh]
----
APISERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
SECRET_NAME=$(kubectl get serviceaccount default -o jsonpath='{.secrets[0].name}')
TOKEN=$(kubectl get secret $SECRET_NAME -o jsonpath='{.data.token}' | base64 --decode)

curl $APISERVER/api --header "Authorization: Bearer $TOKEN" --insecure
----

The above examples use the `--insecure` flag. This leaves it subject to MITM attacks. When kubectl accesses the cluster it uses a stored root certificate and client certificates to access the server. (These are installed in the `~/.kube` directory). Since cluster certificates are typically self-signed, it may take special configuration to get your http client to use root certificate.

On some clusters, the apiserver does not require authentication; it may serve on localhost, or be protected by a firewall. There is not a standard for this. Controlling Access to the API describes how a cluster admin can configure this.

== Programmatic access to the API

Kubernetes officially supports https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/#go-client[Go] and https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/#python-client[Python] client libraries.

==== Go client 

* To get the library, run the following command: `go get k8s.io/client-go@kubernetes-<kubernetes-version-number>`, see https://github.com/kubernetes/client-go/blob/master/INSTALL.md#for-the-casual-user[INSTALL.md] for detailed installation instructions. See https://github.com/kubernetes/client-go to see which versions are supported.
* Write an application atop of the client-go clients. Note that client-go defines its own API objects, so if needed, please import API definitions from client-go rather than from the main repository, e.g., `import "k8s.io/client-go/kubernetes"` is correct.

The Go client can use the same https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/[kubeconfig file] as the kubectl CLI does to locate and authenticate to the apiserver.

[source,go]
----
package main

import (
	"flag"
	"path/filepath"

	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/homedir"
)

func main() {
	var kubeconfig *string
	if home := homedir.HomeDir(); home != "" {
		kubeconfig = flag.String("kubeconfig", filepath.Join(home, ".kube", "config"), "(optional) absolute path to the kubeconfig file")
	} else {
		kubeconfig = flag.String("kubeconfig", "", "absolute path to the kubeconfig file")
	}
	flag.Parse()

	// use the current context in kubeconfig
	config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	if err != nil {
		panic(err.Error())
	}

	_ = config
}
----

If the application is deployed as a Pod in the cluster, please refer to the link:#accessing-the-api-from-a-pod[next section].

== Accessing the API from a Pod

When accessing the API from a pod, locating and authenticating to the apiserver are somewhat different.

The recommended way to locate the apiserver within the pod is with the `kubernetes.default.svc` DNS name, which resolves to a Service IP which in turn will be routed to an apiserver.

The recommended way to authenticate to the apiserver is with a https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[service account] credential. By kube-system, a pod is associated with a service account, and a credential (token) for that service account is placed into the filesystem tree of each container in that pod, at `/var/run/secrets/kubernetes.io/serviceaccount/token`.

If available, a certificate bundle is placed into the filesystem tree of each container at `/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`, and should be used to verify the serving certificate of the apiserver.

Finally, the default namespace to be used for namespaced API operations is placed in a file at `/var/run/secrets/kubernetes.io/serviceaccount/namespace` in each container.

From within a pod the recommended ways to connect to API are:

* Run `kubectl proxy` in a sidecar container in the pod, or as a background process within the container. This proxies the Kubernetes API to the localhost interface of the pod, so that other processes in any container of the pod can access it.
* Use the Go client library, and create a client using the `rest.InClusterConfig()` and `kubernetes.NewForConfig()` functions. They handle locating and authenticating to the apiserver.
+
[source,go]
----
package main

import (
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

func main() {
	// creates the in-cluster config
	config, err := rest.InClusterConfig()
	if err != nil {
		panic(err.Error())
	}
	// creates the clientset
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		panic(err.Error())
	}
	_ = clientset
}
----

In each case, the credentials of the pod are used to communicate securely with the apiserver.

== Accessing services running on the cluster

In Kubernetes, the *nodes*, *pods* and *services* all have their own IPs. In many cases, the node IPs, pod IPs, and some service IPs on a cluster will not be routable, so they will not be reachable from a machine outside the cluster, such as your desktop machine.

=== Ways to connect

You have several options for connecting to nodes, pods and services from outside the cluster:

* Access services through public IPs.
** Use a service with type `NodePort` or `LoadBalancer` to make the service reachable outside the cluster.
** Depending on your cluster environment, this may only expose the service to your corporate network, or it may expose it to the internet. Think about whether the service being exposed is secure. Does it do its own authentication?
** Place pods behind services. To access one specific pod from a set of replicas, such as for debugging, place a unique label on the pod and create a new service which selects this label.
** In most cases, it should not be necessary for application developer to directly access nodes via their nodeIPs.
* Access services, nodes, or pods using the Proxy Verb.
** Does apiserver authentication and authorization prior to accessing the remote service. Use this if the services are not secure enough to expose to the internet, or to gain access to ports on the node IP, or for debugging.
** Proxies may cause problems for some web applications.
** Only works for HTTP/HTTPS.
* Access from a node or pod in the cluster.
** Run a pod, and then connect to a shell in it using https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/#exec[kubectl exec]. Connect to other nodes, pods, and services from that shell.
** Some clusters may allow you to ssh to a node in the cluster. From there you may be able to access cluster services. This is a non-standard method, and will work on some clusters but not others. Browsers and other tools may or may not be installed. Cluster DNS may not work.

=== Discovering builtin services 

Typically, there are several services which are started on a cluster by kube-system. Get a list of these with the kubectl cluster-info command:

[souce,sh]
kubectl cluster-info

The output is similar to this:

[souce,console]
----
Kubernetes control plane is running at https://104.197.5.247:6443
CoreDNS is running at https://104.197.5.247:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
----

[source,yaml,highlight='6-9,12']
----
#$ kubectl get svc -n kube-system kube-dns -oyaml
apiVersion: v1
kind: Service
metadata:
  labels:
    kubernetes.io/cluster-service: "true"
    kubernetes.io/name: CoreDNS
  name: kube-dns
  namespace: kube-system
spec:
  ports:
  - name: dns
    port: 53
    protocol: UDP
    targetPort: 53
...
----

This shows the proxy-verb URL for accessing each service. For example, this cluster has cluster-level logging enabled (using Elasticsearch), which can be reached at `https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/` if suitable credentials are passed. Logging can also be reached through a kubectl proxy, for example at: `http://localhost:8080/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/`.

=== Manually constructing apiserver proxy URLs 

As mentioned above, you use the `kubectl cluster-info` command to retrieve the service's proxy URL. To create proxy URLs that include service endpoints, suffixes, and parameters, you append to the service's proxy URL: +++http:+++//_kubernetes_master_address_/api/v1/namespaces/_namespace_name_/services/_service_name[:port_name]_/proxy

If you haven't specified a name for your port, you don't have to specify port_name in the URL. You can also use the port number in place of the port_name for both named and unnamed ports.

By default, the API server proxies to your service using http. To use https, prefix the service name with https:: pass:[http]://kubernetes_master_address/api/v1/namespaces/namespace_name/services/_pass:[https]:service_name:[port_name]_/proxy

The supported formats for the name segment of the URL are:

* `<service_name>` - proxies to the default or unnamed port using http
* `<service_name>:<port_name>` - proxies to the specified port name or port number using http
* `https:<service_name>:` - proxies to the default or unnamed port using https (note the trailing colon)
* `https:<service_name>:<port_name>` - proxies to the specified port name or port number using https

*Examples*

* To access the Elasticsearch service endpoint `_search?q=user:kimchy`, you would use: `http://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_search?q=user:kimchy`
* To access the Elasticsearch cluster health information `_cluster/health?pretty=true`, you would use: `https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_cluster/health?pretty=true`

== Configure Service Accounts for Pods

A service account provides an identity for processes that run in a Pod.

When you (a human) access the cluster (for example, using `kubectl`), you are authenticated by the apiserver as a particular User Account (currently this is usually _admin_, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, _default_).

== References

* https://kubernetes.io/docs/reference/kubectl/cheatsheet/
* https://kubernetes.io/docs/reference/kubectl/overview/
* https://github.com/ahmetb/kubectx/blob/master/kubens
* https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/
* https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
