= Kubernetes Volumes
:page-layout: post
:page-categories: ['kubernetes']
:page-tags: ['kubernetes', 'container', 'docker', 'csi']
:page-date: 2024-02-29 20:07:20 +0800
:page-revdate: 2024-02-29 20:07:20 +0800
:toc:
:toclevels: 4
:sectnums:
:sectnumlevels: 4

== Docker Storage Drivers and Volumes

Docker uses https://docs.docker.com/storage/storagedriver/select-storage-driver/[storage drivers] to store image layers, and to store data in the writable layer of a container. <<docker-storagedriver>>

Storage drivers are optimized for space efficiency, but (depending on the storage driver) write speeds are lower than native file system performance, especially for storage drivers that use a _copy-on-write_ filesystem.

Use Docker https://docs.docker.com/storage/volumes/[volumes] for write-intensive data, data that must persist beyond the container's lifespan, and data that must be shared between containers.

=== Storage Drivers

A Docker image is built up from a series of layers. Each layer represents an instruction in the image's Dockerfile. Each layer except the very last one is read-only. Consider the following Dockerfile:

```dockerfile
# syntax=docker/dockerfile:1

FROM ubuntu:22.04
LABEL org.opencontainers.image.authors="org@example.com"
COPY . /app
RUN make /app
RUN rm -r $HOME/.cache
CMD python /app/app.py
```

This Dockerfile contains four commands. _Commands that modify the filesystem create a layer._

* The `FROM` statement starts out by creating a layer from the `ubuntu:22.04` image.
* The `LABEL` command only modifies the image's metadata, and doesn't produce a new layer.
* The `COPY` command adds some files from your Docker client's current directory.
* The first `RUN` command builds your application using the make command, and writes the result to a new layer.
+
The second `RUN` command removes a cache directory, and writes the result to a new layer.
* Finally, the `CMD` instruction specifies what command to run within the container, which only modifies the image's metadata, which doesn't produce an image layer.

When a new container is created, a new writable layer is added on top of the underlying layers, which is often called the container layer.

image::https://docs.docker.com/storage/storagedriver/images/container-layers.webp?w=450&h=300[Layers of a container based on the Ubuntu image,35%,35%]

A storage driver handles the details about the way these layers interact with each other.

To see what storage driver Docker is currently using, use `docker` info and look for the `Storage Driver` line:

```console
$ docker info 2> /dev/null | grep 'Storage Driver' -A 5
 Storage Driver: overlay2
  Backing Filesystem: extfs
  Supports d_type: true
  Using metacopy: false
  Native Overlay Diff: true
  userxattr: false
$ df -T /var/lib/docker
Filesystem     Type 1K-blocks     Used Available Use% Mounted on
/dev/sda1      ext4 102624184 57865288  39499736  60% /
```

[TIP]
====
containerd, the industry-standard container runtime, uses snapshotters instead of the classic storage drivers for storing image and container data. While the `overlay2` driver still remains the default driver for Docker Engine, you can opt in to using containerd snapshotters as an experimental feature. <<docker-storage-containerd>>

. Add the following configuration to the `/etc/docker/daemon.json` configuration file:
+
```json
{
  "features": {
    "containerd-snapshotter": true
  }
}
```

. Restart the daemon for the changes to take effect.
+
```sh
sudo systemctl restart docker
```

. Check the Storage Driver.
+
```sh
$ docker info 2> /dev/null | grep 'Storage Driver' -A 2
 Storage Driver: overlayfs
  driver-type: io.containerd.snapshotter.v1
```
====

=== Volumes

Docker has two options for containers to store files on the host machine, so that the files are persisted even after the container stops: _volumes_, and _bind mounts_. <<docker-storage>>

image::https://docs.docker.com/storage/images/types-of-mounts.webp?w=450&h=300a[Types of mounts and where they live on the Docker host,35%,35%]

* *Volumes* are stored in a part of the host filesystem which is _managed by Docker_ (`/var/lib/docker/volumes/` on Linux). Non-Docker processes should not modify this part of the filesystem. Volumes are the best way to persist data in Docker.

* *Bind mounts* may be stored anywhere on the host system. They may even be important system files or directories. Non-Docker processes on the Docker host or a Docker container can modify them at any time.

* *tmpfs mounts* are stored in the host system's memory only, and are never written to the host system's filesystem.

== Kubernetes Volumes

:ephemeral-volumes: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/
:persistent-volumes: https://kubernetes.io/docs/concepts/storage/persistent-volumes/

Kubernetes supports many types of volumes. {ephemeral-volumes}[Ephemeral volume] types have a lifetime of a pod, but {persistent-volumes}[persistent volumes] exist beyond the lifetime of a pod. <<kube-storage-volumes>>

To use a volume, specify the volumes to provide for the Pod in `.spec.volumes` and declare where to mount those volumes into containers in `.spec.containers[*].volumeMounts`.

A process in a container sees a filesystem view composed from the initial contents of the container image, plus volumes (if defined) mounted inside the container.

=== Types of volumes 

Kubernetes supports several types of volumes.

* configMap
+
A https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/[ConfigMap] provides a way to inject configuration data into pods. The data stored in a ConfigMap can be referenced in a volume of type `configMap` and then consumed by containerized applications running in a pod.

* downwardAPI
+
A `downwardAPI` volume makes downward API data available to applications. Within the volume, you can find the exposed data as read-only files in plain text format.

* emptyDir
+
For a Pod that defines an `emptyDir` volume, the volume is created when the Pod is assigned to a node.
+
As the name says, the `emptyDir` volume is initially empty.
+
All containers in the Pod can read and write the same files in the emptyDir volume, though that volume can be mounted at the same or different paths in each container.
+
When a Pod is removed from a node for any reason, the data in the `emptyDir` is deleted permanently.
+
The `emptyDir.medium` field controls where emptyDir volumes are stored.
+
--
* By default emptyDir volumes are stored on whatever medium that backs the node such as disk, SSD, or network storage, determined by the medium of the filesystem holding the kubelet root dir (typically `/var/lib/kubelet`).

* If you set the `emptyDir.medium` field to "Memory", Kubernetes mounts a tmpfs (RAM-backed filesystem) for you instead.
+
While tmpfs is very fast be aware that, unlike disks, files you write count against the memory limit of the container that wrote them.
--

* hostPath
+
A `hostPath` volume mounts a file or directory from the host node's filesystem into your Pod. This is not something that most Pods will need, but it offers a powerful escape hatch for some applications.
+
WARNING: Using the `hostPath` volume type presents many security risks.

* local
+
A `local` volume represents a mounted local storage device such as a disk, partition or directory.
+
Local volumes can only be used as a statically created PersistentVolume. When using local volumes, it is recommended to create a StorageClass with `volumeBindingMode` set to `WaitForFirstConsumer`.

* nfs
+
An `nfs` volume allows an existing NFS (Network File System) share to be mounted into a Pod.
+
NFS can be mounted by multiple writers simultaneously.

* persistentVolumeClaim
+
A `persistentVolumeClaim` volume is used to mount a {persistent-volumes}[PersistentVolume] into a Pod.
+
PersistentVolumeClaims are a way for users to "claim" durable storage (such as an iSCSI volume) without knowing the details of the particular cloud environment.

* projected
+
A `projected` volume maps several existing volume sources into the same directory. 

* secret
+
A `secret` volume is used to pass sensitive information, such as passwords, to Pods, which is backed by tmpfs (a RAM-backed filesystem) so they are never written to non-volatile storage.


[bibliography]
== Referenes

* [[[docker-storagedriver,1]]] https://docs.docker.com/storage/storagedriver/
* [[[docker-storage-containerd,2]]] https://docs.docker.com/storage/containerd/
* [[[docker-storage,3]]] https://docs.docker.com/storage/
* [[[kube-storage-volumes,4]]] https://kubernetes.io/docs/concepts/storage/volumes/
