= Scala in Action
:page-layout: post
:page-categories: ['scala']
:page-tags: ['scala']
:page-date: 2022-05-01 09:10:23 +0800
:page-revdate: 2022-05-01 09:10:23 +0800
:toc:
:sectnums:

== First Steps in Scala

=== Learn to use the Scala interpreter

The easiest way to get started with Scala is by using the Scala interpreter, an interactive “shell” for writing Scala expressions and programs. Simply type an expression into the interpreter and it will evaluate the expression and print the resulting value. The interactive shell for Scala is simply called `scala`.

You use it by typing `scala` at a command prompt:

[source,console]
----
$ scala
Welcome to Scala 2.12.14 (OpenJDK 64-Bit Server VM, Java 17.0.2).
Type in expressions for evaluation. Or try :help.

scala> 2 + 2
res0: Int = 4

scala> res0
res1: Int = 4

scala> res0 + res0
res2: Int = 8
----

=== Define some variables

Scala has two kinds of variables, *vals* and *vars*. A val is similar to a final variable in Java. Once initialized, a val can never be reassigned. A var, by contrast, is similar to a non-final variable in Java. A var can be reassigned throughout its lifetime. Here’s a val definition:

[source,console]
----
scala> val msg = "Hello, world!"
msg: java.lang.String = Hello, world!

scala> msg = "Hello, another world!"
<console>:12: error: reassignment to val
       msg = "Hello, another world!"
           ^

scala> var msg2 = "foo"
msg2: String = foo

scala> msg2 = "bar"
msg2: String = bar
----

=== Write some Scala scripts

Although Scala is designed to help programmers build very large-scale systems, it also scales down nicely to scripting. A script is just a sequence of statements in a file that will be executed sequentially. Put this into a file named _hello.scala_:

[source,console]
----
$ cat <<EOF > hello.scala
> println("Hello, world, from a script!")
> EOF

$ scala hello.scala
Hello, world, from a script!
----

Command line arguments to a Scala script are available via a Scala array named _args_.

[source,console]
----
$ cat <<EOF > helloarg.scala
> println("Hello, "+ args(0) +"!")
> EOF

$ scala helloarg.scala planet
Hello, planet!
----

=== Parameterize arrays with types

In Scala, you can instantiate objects, or class instances, using new. When you instantiate an object in Scala, you can parameterize it with values and types. Parameterization means “configuring” an instance when you create it. You parameterize an instance with values by passing objects to a constructor in parentheses. And parameterize an instance with types by specifying one or more types in square brackets.

[source,scala]
----
val greetStrings = new Array[String](3)
  greetStrings(0) = "Hello"
  greetStrings(1) = ", "
  greetStrings(2) = "world!\n"
  for (i <- 0 to 2)
    print(greetStrings(i))
----

=== Use Lists

* One of the big ideas of the functional style of programming is that methods should not have side effects.

* Applying this functional philosophy to the world of objects means making objects immutable.

* For an immutable sequence of objects that share the same type you can use Scala’s List class.
+
[source,console]
----
scala> val oneTwo = List(1, 2)
oneTwo: List[Int] = List(1, 2)

scala> val threeFour = List(3, 4)
threeFour: List[Int] = List(3, 4)

scala> val oneTwoThreeFour = oneTwo ::: threeFour
oneTwoThreeFour: List[Int] = List(1, 2, 3, 4)
----
+
[source,console]
----
scala> val twoThree = List(2, 3)
twoThree: List[Int] = List(2, 3)

scala> val oneTwoThree = 1 :: twoThree
oneTwoThree: List[Int] = List(1, 2, 3)

scala> val oneTwoThree = 1 :: 2 :: 3 :: Nil
oneTwoThree: List[Int] = List(1, 2, 3)
----
+
[source,console]
----
scala> oneTwoThree(2)
res1: Int = 3
----
+
[source,console]
----
scala> oneTwoThree.head
res4: Int = 1

scala> oneTwoThree.tail
res5: List[Int] = List(2, 3)

scala> oneTwoThree.init
res6: List[Int] = List(1, 2)

scala> oneTwoThree.length
res7: Int = 3

scala> oneTwoThree.mkString(", ")
res8: String = 1, 2, 3

scala> oneTwoThree.reverse
res9: List[Int] = List(3, 2, 1)
----
+
* For a mutable sequence of objects that share the same type you can use Scala’s List class.
+
[source,console]
----
scala> val nums = scala.collection.mutable.ListBuffer(1, 2)
nums: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2)

scala> nums += 3
nums: nums.type = ListBuffer(1, 2, 3)

scala> nums
res15: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3)

scala> nums ++= Seq(4, 5)
res16: nums.type = ListBuffer(1, 2, 3, 4, 5)
----

=== Use sets and maps

[source,console]
----
scala> var jetSet = Set("Boeing", "Airbus")
jetSet: scala.collection.immutable.Set[String] = Set(Boeing, Airbus)

scala> jetSet += "Lear"

scala> println(jetSet)
Set(Boeing, Airbus, Lear)
----

[source,console]
----
scala> import scala.collection.mutable.Set
import scala.collection.mutable.Set

scala> val movieSet = Set("Hitch", "Poltergeist")
movieSet: scala.collection.mutable.Set[String] = Set(Poltergeist, Hitch)

scala> movieSet += "Shrek"
res4: movieSet.type = Set(Poltergeist, Shrek, Hitch)

scala> println(movieSet)
Set(Poltergeist, Shrek, Hitch)
----

[source,console]
----
scala> val romanNumeral = Map(
     |     1 -> "I", 2 -> "II", 3 -> "III", 4 -> "IV", 5 -> "V"
     |   )
romanNumeral: scala.collection.immutable.Map[Int,String] = Map(5 -> V, 1 -> I, 2 -> II, 3 -> III, 4 -> IV)

scala> println(romanNumeral)
Map(5 -> V, 1 -> I, 2 -> II, 3 -> III, 4 -> IV)
----

[source,console]
----
scala> import scala.collection.mutable.Map
import scala.collection.mutable.Map

scala> val treasureMap = Map[Int, String]()
treasureMap: scala.collection.mutable.Map[Int,String] = Map()

scala> treasureMap += (1 -> "Go to island.")
res8: treasureMap.type = Map(1 -> Go to island.)

scala> treasureMap += (2 -> "Find big X on ground.")
res9: treasureMap.type = Map(2 -> Find big X on ground., 1 -> Go to island.)

scala> treasureMap += (3 -> "Dig.")
res10: treasureMap.type = Map(2 -> Find big X on ground., 1 -> Go to island., 3 -> Dig.)

scala> println(treasureMap(2))
Find big X on ground.
----

=== Learn to recognize the functional style

Scala allows you to program in an *imperative style*, but encourages you to adopt a more *functional style*.

A balanced attitude for Scala programmers:

* Prefer vals, immutable objects, and methods without side effects. Reach for them first.
* Use vars, mutable objects, and methods with side effects when you have a specific need and justification for them.
+
[source,scala]
----
// imperative style
def printArgs(args: Array[String]): Unit = {
  var i = 0
  while (i < args.length) {
    println(args(i))
    i += 1
  }
}

// not purely functional style with side effects—in this case,
// its side effect is printing to the standard output stream.
def printArgs(args: Array[String]): Unit = {
  for (arg <- args)
    println(arg)
}

// or this:
def printArgs(args: Array[String]): Unit = {
  args.foreach(println)
}

// purely functional style without side effects or vars in sight.
def formatArgs(args: Array[String]) = args.mkString("\n")

val res = formatArgs(Array("zero", "one", "two"))
assert(res == "zero\none\ntwo")

println(formatArgs(args))
----

== Classes and Objects

A class is a blueprint for objects. Once you define a class, you can create objects from the class blueprint with the keyword *new*.

Inside a class definition, you place fields and methods, which are collectively called members.

* *Fields*, which you define with either val or var, are vari- ables that refer to objects.
* *Methods*, which you define with def, contain executable code.
* The fields hold the state, or data, of an object, whereas the methods use that data to do the computational work of the object. 
+
[source,console]
----
scala> class ChecksumAccumulator {
     |   private var sum = 0
     |   def add(b: Byte) { sum += b }
     |   def checksum(): Int = ~(sum & 0xFF) + 1
     | }
defined class ChecksumAccumulator

scala> val acc = new ChecksumAccumulator
acc: ChecksumAccumulator = ChecksumAccumulator@4756971e

scala> acc.add(22)

scala> acc.checksum
res13: Int = -22
----

=== Singleton object

A *singleton object* definition looks like a class definition, except instead of the keyword class you use the keyword object.

[source,scala]
----
import scala.collection.mutable.Map

object ChecksumAccumulator {
  private val cache = Map[String, Int]()

  def calculate(s: String): Int =
    if (cache.contains(s))
      cache(s)
    else {
      val acc = new ChecksumAccumulator
      for (c <- s)
        acc.add(c.toByte)
        val cs = acc.checksum()
        cache += (s -> cs)
        cs
    } 
}
----

=== Companion object

When a singleton object shares the same name with a class, it is called that class’s *companion object*.

* You must define both the class and its companion object in the same source file.
* The class is called the *companion class* of the singleton object.
* A class and its companion object can access each other’s private members.
+
[source,scala]
----
// In file ChecksumAccumulator.scala
class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte) { sum += b }
  def checksum(): Int = ~(sum & 0xFF) + 1
}

import scala.collection.mutable.Map

object ChecksumAccumulator {
  private val cache = Map[String, Int]()

  def calculate(s: String): Int =
    if (cache.contains(s))
      cache(s)
    else {
      val acc = new ChecksumAccumulator
      for (c <- s)
        acc.add(c.toByte)
        val cs = acc.checksum()
        cache += (s -> cs)
        cs
    } 
}
----

=== Standalone object

A singleton object that does not share the same name with a companion class is called a *standalone object*.

* You can use standalone objects for many purposes, including collecting related utility methods together, or defining an entry point to a Scala application. 
+
[source,scala]
----
// In file Summer.scala
import ChecksumAccumulator.calculate

object Summer {
  def main(args: Array[String]) {
    for (arg <- args)
      println(arg +": "+ calculate(arg))
  }
}
----
+
[source,console]
----
$ scalac Summer.scala ChecksumAccumulator.scala

$ scala Summer Hello World
Hello: -244
World: -8
----

=== Functional Objects

[source,scala]
----
// a functional objects that do not have any mutable state.
class Rational(n: Int, d: Int) { // class parameters and constructors
  require(d != 0) // checking preconditions

  private val g = gcd(n.abs, d.abs) // private fields and methods

  // adding fields
  val numer = n / g
  val denom = d / g

  def this(n: Int) = this(n, 1) // auxiliary constructor

  def + (that: Rational): Rational = // defining operators
    new Rational(
      this.numer * that.denom + that.numer * denom, // self references
      denom * that.denom
    )

  def + (i: Int): Rational = // method overloading
    new Rational(numer + i * denom, denom)

  def * (that: Rational): Rational =
    new Rational(numer * that.numer, denom * that.denom)

  // reimplementing the toString method
  override def toString = numer +"/"+ denom

  // private fields and methods
  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
}

// implicit conversions
object ImplicitConversions { 
  import scala.language.implicitConversions

  implicit def intToRational(x: Int) = new Rational(x)
}

object Main {
  def main(args: Array[String]) {
    val x = new Rational(2, 3)
    val y = new Rational(2)
    println(s"${x} + ${y} = ${x + y}")
    println(s"${x} + 2 = ${x + 2}")

    import ImplicitConversions._
    println(s"2 + ${x} = ${2 + x}")
  }
}
----

== Built-in Control Structures

Scala has only a handful of built-in control structures. The only control structures are *if*, *while*, *for*, *try*, *match*, and *function calls*.

One thing you will notice is that almost all of Scala’s control structures result in some value.

=== If expressions

[source,scala]
----
// imperative style
var filename = "default.txt"
if (!args.isEmpty)
  filename = args(0)
----

[source,scala]
----
// Scala’s idiom for conditional initialization.
val filename =
  if (!args.isEmpty) args(0)
  else "default.txt"
----

=== While loops

[source,scala]
----
// while loop
def gcdLoop(x: Long, y: Long): Long = {
  var a = x
  var b = y
  while (a != 0) {
    val temp = a a=b%a
    b = temp
  }
  b
}

// do-while
var line = ""
do {
  line = readLine()
  println("Read: "+ line)
} while (line != "")

// Scala assignment always results in the unit value, ().
var line = ""
while ((line = readLine()) != "") // This doesn’t work!
  println("Read: "+ line)
----

=== For expressions

* Iteration through collections
+
[source,console]
----
scala> val filesHere = (new java.io.File(".")).listFiles
filesHere: Array[java.io.File] = Array(./powerlog)

scala> for (file <- filesHere)
     | println(file)
./powerlog

scala> for (i <- 1 to 4)
     | println("Iteration "+ i)
Iteration 1
Iteration 2
Iteration 3
Iteration 4

scala> for (i <- 1 until 4)
     | println("Iteration "+ i)
Iteration 1
Iteration 2
Iteration 3

// Not common in Scala...
scala> for (i <- 0 to filesHere.length - 1)
     | println(filesHere(i))
./powerlog
----

* Filtering
+
[source,scala]
----
val filesHere = (new java.io.File(".")).listFiles
for (file <- filesHere if file.getName.endsWith(".scala"))
  println(file)

// imperative style
for (file <- filesHere)
  if (file.getName.endsWith(".scala"))
    println(file)

// keep adding `if` clauses to include more filters
for (
  file <- filesHere
  if file.isFile
  if file.getName.endsWith(".scala")
) println(file)
----

* Nested iteration
+
[source,scala]
----
// If you add multiple <- clauses, you will get nested “loops.
def fileLines(file: java.io.File) =
  scala.io.Source.fromFile(file).getLines().toList

def grep(pattern: String) =
  for (
     file <- filesHere
     if file.getName.endsWith(".scala");
     line <- fileLines(file)
     if line.trim.matches(pattern)
  ) println(file +": "+ line.trim)

grep(".*gcd.*")
----

* Mid-stream variable bindings
+
[source,scala]
----
def fileLines(file: java.io.File) =
  scala.io.Source.fromFile(file).getLines().toList

def grep(pattern: String) =
  for (
     file <- filesHere
     if file.getName.endsWith(".scala");
     line <- fileLines(file)
     // You can do this by binding the result to a new variable using an equals sign (=).
     // The bound variable is introduced and used just like a val, only with the val keyword left out.
     trimmed = line.trim
     if trimmed.matches(pattern)
  ) println(file +": "+ trimmed)

grep(".*gcd.*")
----

* Producing a new collection
+
[source,scala]
----
// for [clauses] yield [body]
def scalaFiles =
  for {
    file <- filesHere
    if file.getName.endsWith(".scala")
  } yield file
----
+
[source,scala]
----
for (file <- filesHere if file.getName.endsWith(".scala")) {
  yield file  // Syntax error!
}
----

=== Exception handling with try expressions

* *Throwing exceptions*
+
Throwing an exception looks the same as in Java. You create an exception object and then you throw it with the throw keyword:
+
[source,scala]
----
throw new IllegalArgumentException
----
+
Although it may seem somewhat paradoxical, in Scala, *throw is an expression* that has a result type. Here is an example in which that result type matters:
+
[source,scala]
----
// What happens here is that if n is even, half will be initialized to half of n.
// If n is not even, an exception will be thrown before half can be initialized to anything at all.
// Technically, an exception throw has type Nothing. 
val half =
  if (n % 2 == 0) {
    n/2
  }else{
    throw new RuntimeException("n must be even")
  }
----

* *Catching exceptions*
+
The syntax for catch clauses was chosen for its consistency with an important part of Scala: *pattern matching*.
+
[source,scala]
----
import java.io.FileReader
import java.io.FileNotFoundException
import java.io.IOException

try {
  val f = new FileReader("input.txt")
  // Use and close file
} catch {
  case ex: FileNotFoundException => // Handle missing file
  case ex: IOException => // Handle other I/O error
  case _: Exception => // Handle other error
}
----

* *The `finally` clause*
+
[source,scala]
----
import java.io.FileReader

val file = new FileReader("input.txt")
try {
  // Use the file
} finally {
  file.close()  // Be sure to close the file
}
----

.Loan Pattern
[NOTE]
====
[source,scala]
----
// In file Loan.scala
object Disposable {
  // using statement with C# style (disposable pattern)
  def using(closer: AutoCloseable)(op: => Unit) {
    try {
      op
    } finally {
      closer.close()
    }
  }
}

object Main {
  def main(args: Array[String]) {
    import Disposable._
    import java.io.{BufferedReader, FileReader, PrintWriter}
    import java.util.Date

    val writer = new PrintWriter("date.txt")
    using(writer) {
      writer.println(new Date)
    }

    val reader = new BufferedReader(new FileReader("date.txt"))
    using(reader) {
      println(reader.readLine())
    }
  }
}
----
====

* *Yielding a value*
+
As with most other Scala control structures, try-catch-finally results in a value.
+
--
** The result is that of the `try` clause if no exception is thrown, or the relevant `catch` clause if an exception is thrown and caught.
** If an exception is thrown but not caught, the expression has no result at all.
** The value computed in the `finally` clause, if there is one, is dropped.
** Usually `finally` clauses do some kind of clean up such as closing a file; they should not normally change the value computed in the main body or a `catch` clause of the `try`.
+
[source,console]
----
import java.net.URL

import java.net.MalformedURLException
def urlFor(path: String) =
  try {
    new URL(path)
  } catch {
    case e: MalformedURLException =>
      new URL("http://www.scala-lang.org")
  }
----
--
+
.The best way to think of finally clauses is as a way to ensure some side effect happens, such as closing an open file.
[source,console]
----
scala> def f(): Int = try { return 1 } finally { return 2 }
f: ()Int

scala> f
res9: Int = 2

scala> def g(): Int = try { 1 } finally { 2 }
<console>:11: warning: a pure expression does nothing in statement position
       def g(): Int = try { 1 } finally { 2 }
                                          ^
g: ()Int

scala> g
res10: Int = 1
----

=== Match expressions

Scala’s match expression lets you select from a number of alternatives, just like switch statements in other languages.

[source,console]
----
// A match expression that yields a value.
val firstArg = if (!args.isEmpty) args(0) else ""
val friend =
  firstArg match {
    case "salt" => "pepper"
    case "chips" => "salsa"
    case "eggs" => "bacon"
    // The default case is specified with an underscore (_), a wildcard symbol
    // frequently used in Scala as a placeholder for a completely unknown value.
    case _ => "huh?"
  }
println(friend)

----

=== Living without break and continue

You may have noticed that there has been no mention of break or continue. Scala leaves out these commands because they do not mesh well with function literals. It is clear what continue means inside a while loop, but what would it mean inside a function literal? While Scala supports both imperative and functional styles of programming, in this case it leans slightly towards *functional programming* in exchange for simplifying the language. Do not worry, though. There are many ways to program without break and continue, and if you take advantage of function literals, those alternatives can often be shorter than the original code.

[source,scala]
----
// searching through an argument list for a string that ends with “.scala”
// but does not start with a hyphen.
//
// int i = 0;                // This is Java
// boolean foundIt = false;
// while (i < args.length) {
//   if (args[i].startsWith("-")) {
//     i = i + 1;
//     continue;
//   }
// 
//   if (args[i].endsWith(".scala")) {
//     foundIt = true;
//     break; 
//   }
// 
//   i = i + 1;
// }
//
// Looping without break or continue in Scala
var i = 0
var foundIt = false
while (i < args.length && !foundIt) {
  if (!args(i).startsWith("-") && args(i).endsWith(".scala")) {
    foundIt = true
  }

  i = i + 1
}
println(foundIt)
----

If you wanted to get rid of the vars in the above code snippet, one approach you could try is to rewrite the loop as a *recursive* function.

[source,scala]
----
// Rewrite the loop as a recursive function to get rid of the vars
def searchFrom(i: Int): Int = {
  if (i >= args.length) -1
  else if (args(i).startsWith("-")) searchFrom(i + 1) 
  else if (args(i).endsWith(".scala")) i
  else searchFrom(i + 1)  
}
val foundIt = searchFrom(0) >= 0
println(foundIt)
----

If after all this discussion you still feel the need to use break, there’s help in Scala’s standard library. Class Breaks in package `scala.util.control` offers a `break` method, which can be used to exit the an enclosing block that’s marked with `breakable`.

[source,scala]
----
import scala.util.control.Breaks._

import java.io._

val in = new BufferedReader(new InputStreamReader(System.in))
breakable {
  while (true) {
    println("? ")
    if (in.readLine() == "") break
  }
}
----

The `Breaks` class implements `break` by throwing an exception that is caught by an enclosing application of the `breakable` method. Therefore, the call to `break` does not need to be in the same method as the call to `breakable`.

[source,scala]
----
// File in Breakable.scala
object Breaks {
  def breakable(op: => Unit) {
    try {
      op
    } catch {
      case _: BreakException => 
    }
  }

  def break() {
    throw new BreakException()
  }

  final case class BreakException() extends Exception()
}

object Main {
  def main(args: Array[String]) {
    import java.io._
    import Breaks._

    val in = new BufferedReader(new InputStreamReader(System.in))
    breakable {
      while (true) {
        println("? ")
        if (in.readLine() == "") break
      }
    }
  }
}
----

[source,console]
----
$ scala Breakable.scala
?

----

=== Refactoring imperative-style code

[source,scala]
----
//   1   2   3   4   5   6   7   8   9
//   2   4   6   8  10  12  14  16  18
//   3   6   9  12  15  18  21  24  27
//   4   8  12  16  20  24  28  32  36
//   5  10  15  20  25  30  35  40  45
//   6  12  18  24  30  36  42  48  54
//   7  14  21  28  35  42  49  56  63
//   8  16  24  32  40  48  56  64  72
//   9  18  27  36  45  54  63  72  81
object MultiTable {
  // imperative-style code
  // def printMultiTable() {
  //   for( row <- 1 to 9) {
  //     for( col <- 1 to 9) {
  //       val prod = (row * col).toString
  //       val padding = " " * (4 - prod.size)
  //       print(s"${padding}${prod}")
  //     }
  //     println()
  //   }
  // }

  // Returns a row as sequence
  def makeRowSeq(row: Int): Seq[Int] = { // ???
    for (col <- 1 to 9) yield row * col
  }

  def makeRow(row: Int): String = { // ???
    makeRowSeq(row).
    map(_.toString()).
    map(prod => s"${" " * (4 - prod.size)}${prod}").
    mkString("")
  }

  def multiTable(): String = { // ???
    val tableSeq =
      for (row <- 1 to 9) yield {
        makeRow(row)
      }
    tableSeq.mkString("\n")
  }

  def printMultiTable() {
    val table = multiTable 
    println(table)
  }

  def main(args: Array[String]) {
    printMultiTable()
  }
}
----
