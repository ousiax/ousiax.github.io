= Python Learning Notes
:page-layout: post
:page-categories: ['python']
:page-tags: ['python']
:page-date: 2024-05-17 10:29:20 +0800
:page-revdate: 2024-05-17 10:29:20 +0800
:toc: preamble
:toclevels: 4
:sectnums:
:sectnumlevels: 4

Python is a dynamically, strongly typed and garbage-collected programming language.

* In a dynamically typed language, the data type of a variable is NOT explicitly declared at the time of definition, and is determined at runtime.
+
```py
age = 30  # age is an integer (no need to declare the data type explicitly)
age = "thirty"  # age is now a string
```
+
In a statically typed language, the data type of a variable MUST be declared at compile time and the compiler ensures type compatibility throughout the code.
+
```java
// In Java, declare the type of a variable before assigning a value.
int age = 30;  // age is declared as an integer
age = "thirty";  // error: incompatible types: String cannot be converted to int
```

* In a strongly typed language, the data type of a variable MUST be declared at the time of definition, and the compiler or interpreter enforces type safety.

* In Python, everything is ultimately an object, even data types like integers and strings, that has associated methods and attributes. During runtime, Python checks if the methods or attributes involved are compatible with the object's type.
+
```py
# Like dynamic languages, Python infers types based on assigned values.
name = "Alice"  # name is a string
name + 10  # This would cause a TypeError in Python (mixing string and number)
```
+
[TIP]
====
In computer programming, https://en.wikipedia.org/wiki/Duck_typing[duck typing] is an application of the duck test—"If it walks like a duck and it quacks like a duck, then it must be a duck"—to determine whether an object can be used for a particular purpose.

[.text-right]
-- From Wikipedia, the free encyclopedia
====

== Running Python

* Using the interactive interpreter (shell)
+
```console
$ python3
Python 3.11.2 (main, Mar 13 2023, 12:18:29) [GCC 12.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
```
+
```py
>>> 2+2
4
>>> quit()
```

* Using python files
+
```console
$ echo 'print(2+2)' > test.py
$ python3 test.py
4
```

* Using python files with shebang
+
[TIP]
====
In computing, a https://en.wikipedia.org/wiki/Shebang_(Unix)[*shebang*] is the character sequence consisting of the characters number sign and exclamation mark (`#!`) at the beginning of a script. It is also called sharp-exclamation, sha-bang, *hashbang*, pound-bang, or hash-pling.

[.text-right]
-- From Wikipedia, the free encyclopedia
====
+
```console
$ cat <<EOF > test.py
> #!/usr/bin/env python3
> print(2+2)
> EOF
$ chmod +x test.py
$ ./test.py
4
```

== Indentations, comments, and multi-line expressions

* Python uses whitespace indentation (the recommended style, called PEP-8, is to use four spaces), rather than curly brackets or keywords, to delimit blocks.
+
--
** Don't use tabs, or mix tabs and spaces; it messes up the indent count.

** When designing the language that became Python, Guido van Rossum decided that the indentation itself was enough to define a program’s structure, and avoided typing all those parentheses and curly braces. Python is unusual in this use of white space to define program structure.
--
+
```py
disaster = True
if disaster:
    print("Woe!")
else:
    print("Whee!")
```

* A comment is marked by using the `#` (names: _hash_, _sharp_, _pound_, or or the sinister-sounding _octothorpe_) character; everything from that point on to the end of the current line is part of the comment.
+
```py
# 60 sec/min * 60 min/hr * 24 hr/day
seconds_per_day = 86400
```
+
```py
seconds_per_day = 86400 # 60 sec/min * 60 min/hr * 24 hr/day
```
+
```py
# Python does NOT
# have a multiline comment.
print("No comment: quotes make the # harmless.")
```

* Python allows to write expressions that span multiple lines within certain delimiters.

** In older versions of Python (pre-3.0), the backslash character (`\`) at the end of a line was used to indicate that the line continued on the next line, which  is no longer required in modern Python (versions 3.0 and above).
+
```py
# Example in older Python (not recommended)
long_expression = (1 + 2 + 3 + 4 + 5 + \
                  6 + 7 + 8 + 9 + 10)
```

** In modern Python, avoid using the continuation character (`\`) for line continuation, and utilize parentheses (`()`), brackets (`[]`), or braces (`[]`) for readability and structure in multi-line expressions.
+
```py
# Parentheses for complex calculations
long_calculation = (a * b +
                    c) * (d /
                          e - f)

# Brackets for multi-line lists or data structures
data = [
    "item1",
    "item2 with a longer description",
    "item3"
]

# Braces for multi-line dictionaries
person_info = {
    "name": "Alice",
    "age": 30,
    "hobbies": ["reading", "hiking"]
}
```

== Types, values, variables, and names

* Python’s basic data types
+
```py

bool # True, False

int # 47, 25000, 25_000, 0b0100_0000, 0o100, 0x40

float # 3.14, 2.7e5

complex # 3j, 5 + 9j

str # 'alas', "alack", '''a verse attack'''

list # ['Winken', 'Blinken', 'Nod']
tuple # (2, 4, 8)

bytes # b'ab\xff'
bytearray # bytearray(...)

set # set([3, 5, 7])
frozenset # frozenset(['Elsa', 'Otto'])

dict # {'game': 'bingo', 'dog': 'dingo', 'drummer': 'Ringo'}
```

* In Python, variables are NOT places, just names, and a name is a _reference_ to an object rather than the object itself.
+
```py
a = 3.14
print(a) // 3.14
b = a
print(b) // 3.14
```

* Python wraps each data value—booleans, integers, floats, strings, even large data structures, functions, and programs—in memory as an _object_, that is a chunk of data that contains at least a _type_, a unique _id_, a _value_, and a _reference count_.
+
```py
>>> type(5.20)
<class 'float'>
>>> id(5.20)
140683748269744
>>> x = y = z = 0
>>> sys.getrefcount(x)
1000000591
>>> del y
>>> sys.getrefcount(x)
1000000590
>>> del z
>>> sys.getrefcount(x)
1000000589
```

* A _class_ is the definition of an object, and "class" and "type" mean pretty much the same thing.
+
```py
>>> type(7)
<class 'int'>
>>> type(7) == int
True
>>> isinstance(7, int)
True
>>> int
<class 'int'>
>>> type(int)
<class 'type'>
>>> type(type)
<class 'type'>
>>> help(int)
```

* More than one variable name can be assigned a value at the same time
+
```py
two = deux = zwei = 2
```

* Non-zero numbers are considered `True`:
+
```py
>>> bool(True)
True
>>> bool(1)
True
>>> bool(45)
True
>>> bool(-45)
True
```

* Zero-valued ones are considered `False`:
+
```py
>>> bool(False)
False
>>> bool(0)
False
>>> bool(0.0)
False
```

* Python also promotes booleans to integers or floats:
+
```py
>>> False + 0
0
>>> False + 0.
0.0
>>> True + 0
1
>>> True + 0.
1.0
```

* Type converstions: `int()`, `float()`, `bin()`, `oct()`, `hex()`, `chr()`, and `ord()`
+
```py
>>> int(True)
1
>>> int(False)
0

>>> int(98.6)
98
>>> int(1.0e4)
10000

>>> int('99')
99
>>> int('-23')
-23
>>> int('+12')
12
>>> int('1_000_000')
1000000

>>> int('10', 2) # binary
2
>>> int('10', 8) # octal
8
>>> int('10', 16) # hexadecimal
16
>>> int('10', 22) # chesterdigital
22

>>> float(True)
1.0
>>> float(False)
0.0

>>> float('98.6')
98.6
>>> float('-1.5')
-1.5
>>> float('1.0e4')
10000.0

>>> value = 65
>>> bin(value)
'0b1000001'
>>> oct(value)
'0o101'
>>> hex(value)
'0x41'

>>> chr(65)
'A'
>>> ord('A')
65
```

== If, while, and for

* In Python, truthiness and falsiness are used to check a value in a Boolean context:

** Truthy: Values that evaluate to `True`, which includes most non-zero numbers, non-empty strings, lists, dictionaries, and many objects.

** Falsy: Values that evaluate to `False`, which include `False`, zero numbers (`0`, `0.0`), empty strings (`""`), empty lists (`[]`), empty tuples (`()`), and `None`.

* In Python, the logical operators `and`, `or`, `not` are used to combine Boolean values (True/False) or expressions that evaluate to Boolean values.
+
```py
letter = 'o'
if letter == 'a' or letter == 'e' or letter == 'i' or letter == 'o' or letter == 'u':
    print(letter, 'is a vowel')
else:
    print(letter, 'is not a vowel')
```

* In Python (version 3.8 and above), the walrus operator (`:=`, formally known as the assignment expression operator) combines assignment and expression evaluation in a single line.
+
```py
tweet_limit = 280
tweet_string = "Blah" * 50
if diff := tweet_limit - len(tweet_string) >= 0:  # walrus operator
    print("A fitting tweet")
else:
    print("Went over by", abs(diff))
```

* Compare with `if`, `elif`, and `else`:
+
```py
color = "mauve"
if color == "red":
    print("It's a tomato")
elif color == "green":
    print("It's a green pepper")
else:
    print("I've never heard of the color", color)
```

* Repeat with `while`, and `break`, `continue`, and `else`:
+
```py
while True:
    value = input("Integer, please [q to quit]: ")
    if value == 'q':  # quit
        break
    number = int(value)
    if number % 2 == 0:  # an even number
        continue
    print(number, "squared is", number*number)
```
+
```py
numbers = [1, 3, 5]
position = 0
while position < len(numbers):
    number = numbers[position]
    if number % 2 == 0:
        print('Found even number', number)
        break
    position += 1
else:  # break not called
    print('No even number found')
```

* Iterate with `for` and `in`, and `break`, `continue` and `else`:
+
```py
word = 'thud'
for letter in word:
    if letter == 'u':
        continue
    print(letter)
```
+
```py
word = 'thud'
for letter in word:
    if letter == 'x':
        print("Eek! An 'x'!")
        break
    print(letter)
else:
    print("No 'x' in there.")
```
+
```py
for num in range(0, 10, 2):
    print(num)  # 0 2 ... 8
```
+
```py
for nums in zip(range(0, 10, 2), range(1, 10, 2)):
    print(nums)  # (0, 1) (2, 3) .. (8, 9)
```

== Strings, tuples, lists, and slices

Both *strings*, *tuples* and *lists* are common built-in sequences, which are zero-based indexing and ordered collections that can store elements of any data types, except strings, which are sequences of characters themselves.

=== Strings

* Strings are created by enclosing characters in matching single, double, or triple quotes:
+
```py
'Snap'
"Crackle"
"'Nay!' said the naysayer. 'Neigh?' said the horse."
'The rare double quote in captivity: ".'
'''Boom!'''
"""Eek!"""
```

* Triple quotes are very useful to create multiline strings, like this classic poem from Edward Lear:
+
```py
poem = '''There was a Young Lady of Norway,
    Who casually sat in a doorway;
    When the door squeezed her flat,
    She exclaimed, "What of that?"
    This courageous Young Lady of Norway.'''
```
+
```py
# The line ending characters, and leading or trailing spaces will be preserved in the string:
poem = 'There was a Young Lady of Norway,\n    Who casually sat in a doorway;\n    When the door squeezed her flat,\n    She exclaimed, "What of that?"\n    This courageous Young Lady of Norway.'
```
+
```py
print(poem)
There was a Young Lady of Norway,
    Who casually sat in a doorway;
    When the door squeezed her flat,
    She exclaimed, "What of that?"
    This courageous Young Lady of Norway.
```
====

* Python has a few special types of strings, indicated by a letter before the first quote.

** `f` or `F` starts an _f-string_, used for formatting.
+
```py
>>> thing = 'wereduck'
>>> place = 'werepond'
>>> f'The {thing} is in the {place}'
'The wereduck is in the werepond'
```

** `r` or `R` starts a raw string, used to prevent escape sequences in the string.
+
```py
>>> info = r'Type a \n to get a new line in a normal string'
>>> info
'Type a \\n to get a new line in a normal string'
```
+
TIP: A raw string does not undo any real (not `\n`) newlines:
+
```py
>>> poem = r'''Boys and girls, come out to play.
... The moon doth shine as bright as day.'''
>>> poem
'Boys and girls, come out to play.\nThe moon doth shine as bright as day.'
```

** `fr` (or `FR`, `Fr`, or `fR`), the combination, that starts a raw f-string.
+
```py
>>> hello = 'Hello'
>>> world = '世界'
>>> print(fr'{hello}, {world}!')
Hello, 世界!
```

** `u` starts a Unicode string, which is the same as a plain string.
+
TIP: Python 3 strings are Unicode character sequences, not byte arrays.
+
```py
>>> hi = u'Hello, 世界!'  # same as 'Hello, 世界!'
```

** `b` starts a value of type bytes.
+
```py
>>> ip = [20, 205, 243, 166]
>>> bytes(ip)
b'\x14\xcd\xf3\xa6'
```


* Create with commas and `()`
+
```py
# to make a tuple with one or more elements, follow each element with a comma (`,`):
>>> one_marx = 'Groucho',
>>> one_marx
('Groucho',)
>>> marx_tuple = 'Groucho', 'Chico', 'Harpo'
>>> marx_tuple
('Groucho', 'Chico', 'Harpo')
```
+
```py
# to make an empty tuple, using `()`:
>>> empty_tuple = ()
>>> empty_tuple
()
```
+
```py
# the comma is required to make a tuple
>>> one_marx = ('Groucho')
>>> one_marx
'Groucho'
>>> type(one_marx)
<class 'str'>
```
+
```py
# the parentheses is not required, but could make the tuple more visible
>>> one_marx = ('Groucho',)
>>> one_marx
('Groucho',)
>>> marx_tuple = ('Groucho', 'Chico', 'Harpo')
>>> marx_tuple
('Groucho', 'Chico', 'Harpo')
```
+
```py
# for cases in which commas might also have another use, the parentheses is needed
>>> type('Groucho',)
<class 'str'>
>>> type(('Groucho',))
<class 'tuple'>
```

* Create with `tuple()`, `zip()`, `+`, and `*`
+
```py
# if no argument is given, the tupe() returns an empty tuple.
>>> tuple()
()
# if iterable is specified, the tuple is initialized from iterable's items.
>>> tuple(range(10))
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
```
+
```py
# yield tuples until an input is exhausted.
>>> for x in zip([1, 2, 3, 4], [1, 4, 9, 16], ['foo', 'bar', 'buz']):
...     print(x)
...
(1, 1, 'foo')
(2, 4, 'bar')
(3, 9, 'buz')
```
+
```py
# similar to strings, combine tuples by using +
>>> ('Groucho',) + ('Chico', 'Harpo')
('Groucho', 'Chico', 'Harpo')
```
+
```py
# similar to strings, duplicate items with *
>>> ('yada',) * 3
('yada', 'yada', 'yada')
```

* Compare and iterate tuples
+
```py
# works much like list comparisons:
>>> a = (7, 2)
>>> b = (7, 2, 9)
>>> a == b
False
>>> a <= b
True
>>> a < b
True
```
+
```py
# like iteration of other types:
>>> words = ('fresh', 'out', 'of', 'ideas')
>>> for word in words:
...     print(word)
...
fresh
out
of
ideas
```

*Lists* are built-in mutable sequence structures.

* Create with `[]` or `list()`
+
```py
empty_list = []
weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
randomness = ["Punxsatawney", {"groundhog": "Phil"}, "Feb. 2"]
# make an empty list with the list()
another_empty_list = list()
# converts other iterable data types (such as tuples, strings, sets, and dictionaries) to lists.
list('cat')  # ['c', 'a', 't']
```

* Add an item to the end with `append()`
+
```py
>>> marxes = ['Groucho', 'Chico', 'Harpo']
>>> marxes.append('Zeppo')
>>> marxes
['Groucho', 'Chico', 'Harpo', 'Zeppo']
```

* Add an item by offset with `insert()`
+
```py
>>> marxes = ['Groucho', 'Chico', 'Harpo']
>>> marxes.insert(2, 'Gummo')
>>> marxes
['Groucho', 'Chico', 'Gummo', 'Harpo']
# an offset beyond the end of the list inserts at the end, like append(), without throwing an exception
>>> marxes.insert(10, 'Zeppo')
>>> marxes
['Groucho', 'Chico', 'Gummo', 'Harpo', 'Zeppo']
```

* Duplicate all items with `*`






[bibliography]
== References

* [[[IntroducingPython,1]]] Bill Lubanovic _Introducing Python: Modern Computing in Simple Packages_. second edition, O’Reilly Media, Inc., November 2019
* [[[wiki-Python,2]]]https://en.wikipedia.org/wiki/Python_(programming_language)
