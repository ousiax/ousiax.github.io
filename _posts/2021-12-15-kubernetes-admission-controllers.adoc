= Kubernetes Admission Controllers
:page-layout: post
:page-categories: ['kubernetes']
:page-tags: ['kubernetes']
:page-date: 2021-12-15 12:27:15 +0800
:page-revdate: 2021-12-15 12:27:15 +0800
:sectnums:
:toc:
:toclevels: 4

== What is an admission controller

:admission-controllers: https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/
:admission-webhooks: https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks

An {admission-controllers}[*admission controller*] is a piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object, but after the request is authenticated and authorized.

image::https://d33wubrfki0l68.cloudfront.net/673dbafd771491a080c02c6de3fdd41b09623c90/50100/images/docs/admin/access-control-overview.svg[,65%,65%]

The controllers are compiled into the *kube-apiserver* binary, and may only be configured by the cluster administrator. There are two special controllers: *MutatingAdmissionWebhook* and *ValidatingAdmissionWebhook*. These execute the mutating and validating (respectively) {admission-webhooks}[admission control webhooks] which are configured in the API.

Admission controllers *limit requests* to create, delete, modify objects or connect to proxy. They do *not limit requests* to read objects.

The admission control process proceeds in two phases. In the first phase, *mutating* admission controllers are run. In the second phase, *validating* admission controllers are run. Note again that some of the controllers are both.

If any of the controllers in either phase reject the request, the entire request is rejected immediately and an error is returned to the end-user.

=== Turn on/off an admission controller

The Kubernetes API server flag `enable-admission-plugins` takes a comma-delimited list of admission control plugins to invoke prior to modifying objects in the cluster.

[source,sh]
kube-apiserver --enable-admission-plugins=NamespaceLifecycle,LimitRanger ...

The Kubernetes API server flag `disable-admission-plugins` takes a comma-delimited list of admission control plugins to be disabled, even if they are in the list of plugins enabled by default.

[source,sh]
kube-apiserver --disable-admission-plugins=PodNodeSelector,AlwaysDeny ...

To see which admission plugins are enabled by default:

[source,sh]
kube-apiserver -h | grep enable-admission-plugins

[source,console]
----
$ docker run --rm -it k8s.gcr.io/kube-apiserver:v1.22.3 kube-apiserver -h | grep enable-admission-plugins
      --enable-admission-plugins strings       admission plugins that should be enabled in addition to default enabled ones (NamespaceLifecycle, LimitRanger, ServiceAccount, TaintNodesByCondition, PodSecurity, Priority, DefaultTolerationSeconds, DefaultStorageClass, StorageObjectInUseProtection, PersistentVolumeClaimResize, RuntimeClass, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, MutatingAdmissionWebhook, ValidatingAdmissionWebhook, ResourceQuota). Comma-delimited list of admission plugins: AlwaysAdmit, AlwaysDeny, AlwaysPullImages, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, DenyServiceExternalIPs, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodSecurity, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, RuntimeClass, SecurityContextDeny, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook. The order of plugins in this flag does not matter.
----

=== Dynamic Admission Control

:validatingadmissionwebhook: https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook
:mutatingadmissionwebhook: https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook
:validatingwebhookconfiguration-v1-admissionregistration-k8s-io: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io
:mutatingwebhookconfiguration-v1-admissionregistration-k8s-io: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#mutatingwebhookconfiguration-v1-admissionregistration-k8s-io

In addition to *compiled-in admission plugins*, admission plugins can be developed as extensions and run as *webhooks* configured at runtime. 

Admission webhooks are HTTP callbacks that receive admission requests and do something with them. You can define both {validatingadmissionwebhook}[*validating admission webhook*] and {mutatingadmissionwebhook}[*mutating admission webhook*] admission webhooks.

The webhook handles the `AdmissionReview` request sent by the apiservers, and sends back its decision as an `AdmissionReview` object in the same version it received.

Mutating admission webhooks are invoked first, and can modify objects sent to the API server to enforce custom defaults. After all object modifications are complete, and after the incoming object is validated by the API server, validating admission webhooks are invoked and can reject requests to enforce custom policies.

You can dynamically configure what resources are subject to what admission webhooks via {validatingwebhookconfiguration-v1-admissionregistration-k8s-io}[ValidatingWebhookConfiguration] or {mutatingwebhookconfiguration-v1-admissionregistration-k8s-io}[MutatingWebhookConfiguration].

You can use the follow commands to inspect details about each config field:

[source,sh]
----
$ kubectl explain mutatingwebhookconfigurations
$ kubectl explain validatingwebhookconfigurations
----

The following is an example `ValidatingWebhookConfiguration`, a mutating webhook configuration is similar. 

[source,yaml]
----
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: "pod-policy.kube-admission.io"
webhooks:
- name: "pod-policy.kube-admission.io"
  rules:
    - apiGroups:   [""]
      apiVersions: ["v1"]
      operations:  ["CREATE"]
      resources:   ["pods"]
      scope:       "Namespaced"
  clientConfig:
    caBundle: LS0....
    service:
      namespace: "default"
      name: "kube-admission"
      path: /always-allow-delay-5s
  admissionReviewVersions: ["v1"]
  sideEffects: None
  timeoutSeconds: 10
----

NOTE: Note: When using `clientConfig.service`, the server cert must be valid for `<svc_name>.<svc_namespace>.svc`. 

Besides, there's a sample of admission controller at GitHub: https://github.com/qqbuby/kube-admission.

=== What is a Pod Security Policy?

:pod-security-policy: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
:role-and-clusterrole: https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole
:kep-2579: https://github.com/kubernetes/enhancements/issues/2579
:pod-security-standards: https://kubernetes.io/docs/concepts/security/pod-security-standards/
:podsecurity: https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#podsecurity

[NOTE]
====
Kubernetes has officially https://kubernetes.io/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/[deprecated PodSecurityPolicy] in version 1.21. PodSecurityPolicy will be shut down in version 1.25.

*PodSecurityPolicy is being replaced by a new, simplified {podsecurity}[PodSecurity] admission controller.*
====

PodSecurityPolicy is a built-in admission controller that allows a cluster administrator to control security-sensitive aspects of the Pod specification.

A {pod-security-policy}[*PodSecurityPolicy*] is a built-in admission controller that allows a cluster administrator to control security-sensitive aspects of the Pod specification to create and update Pods on your cluster.

In most Kubernetes clusters, RBAC (Role-Based Access Control) {role-and-clusterrole}[rules] control access to these resources. `list`, `get`, `create`, `edit`, and `delete` are the sorts of API operations that RBAC cares about, but _RBAC does not consider what settings are being put into the resources it controls_.

To control what sorts of settings are allowed in the resources defined in your cluster, you need *Admission Control* in addition to RBAC. 

Kubernetes SIG Security, SIG Auth, and a diverse collection of other community members have been working together for months to ensure that what’s coming next is going to be awesome. We have developed a Kubernetes Enhancement Proposal ({kep-2579}[KEP 2579]) and a prototype for a new feature, currently being called by the temporary name "*PSP Replacement Policy*."

If your use of PSP is relatively simple, with a few policies and straightforward binding to service accounts in each namespace, you will likely find PSP Replacement Policy to be a good match for your needs. Evaluate your PSPs compared to the Kubernetes {pod-security-standards}[*Pod Security Standards*] to get a feel for where you’ll be able to use the Restricted, Baseline, and Privileged policies. Please follow along with or contribute to the KEP and subsequent development, and try out the Alpha release of PSP Replacement Policy when it becomes available.

In addition to restricting pod creation and update, pod security policies can also be used to provide default values for many of the fields that it controls. When multiple policies are available, the pod security policy controller selects policies according to the following criteria:

* PodSecurityPolicies which allow the pod as-is, without changing defaults or mutating the pod, are preferred. The order of these non-mutating PodSecurityPolicies doesn't matter.
* If the pod must be defaulted or mutated, the first PodSecurityPolicy (ordered by name) to allow the pod is selected.

NOTE: During update operations (during which mutations to pod specs are disallowed) only non-mutating PodSecurityPolicies are used to validate the pod. 

.# policy/privileged-psp.yaml
[source,yaml]
----
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: privileged
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
spec:
  privileged: true
  allowPrivilegeEscalation: true
  allowedCapabilities:
  - '*'
  volumes:
  - '*'
  hostNetwork: true
  hostPorts:
  - min: 0
    max: 65535
  hostIPC: true
  hostPID: true
  runAsUser:
    rule: 'RunAsAny'
  seLinux:
    rule: 'RunAsAny'
  supplementalGroups:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'RunAsAny'
----

.# policy/restricted-psp.yaml 
[source,yaml]
----
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: 'docker/default,runtime/default'
    apparmor.security.beta.kubernetes.io/allowedProfileNames: 'runtime/default'
    apparmor.security.beta.kubernetes.io/defaultProfileName:  'runtime/default'
spec:
  privileged: false
  # Required to prevent escalations to root.
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  # Allow core volume types.
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    # Assume that ephemeral CSI drivers & persistentVolumes set up by the cluster admin are safe to use.
    - 'csi'
    - 'persistentVolumeClaim'
    - 'ephemeral'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    # Require the container to run without root privileges.
    rule: 'MustRunAsNonRoot'
  seLinux:
    # This policy assumes the nodes are using AppArmor rather than SELinux.
    rule: 'RunAsAny'
  supplementalGroups:
    rule: 'MustRunAs'
    ranges:
      # Forbid adding the root group.
      - min: 1
        max: 65535
  fsGroup:
    rule: 'MustRunAs'
    ranges:
      # Forbid adding the root group.
      - min: 1
        max: 65535
  readOnlyRootFilesystem: false
----

==== Enabling Pod Security Policies

:podsecuritypolicy: https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#podsecuritypolicy
:how-do-i-turn-on-an-admission-control-plug-in: https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#how-do-i-turn-on-an-admission-control-plug-in

Pod security policy control is implemented as an optional {podsecuritypolicy}[admission controller]. PodSecurityPolicies are enforced by {how-do-i-turn-on-an-admission-control-plug-in}[enabling the admission controller], but doing so *without authorizing any policies will prevent any pods from being created in the cluster*.

[source,yaml,highlight=8]
----
  name: kube-apiserver
  namespace: kube-system
spec:
  containers:
  - command:
    - kube-apiserver
# ...
    - --enable-admission-plugins=NodeRestriction,PodSecurityPolicy
# ...
----

[source,console,highlight=17]
----
$ kubectl create ns psp-test
namespace/psp-test created

$ kubectl create rolebinding -n psp-test default:edit --clusterrole edit --serviceaccount psp-test:default
rolebinding.rbac.authorization.k8s.io/default:edit created

$ kubectl --as system:serviceaccount:psp-test:default create -n psp-test -f- <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: pause
spec:
  containers:
    - name: pause
      image: k8s.gcr.io/pause
EOF
Error from server (Forbidden): error when creating "STDIN": pods "pause" is forbidden: PodSecurityPolicy: unable to admit pod: []

$ kubectl delete ns psp-test 
namespace "psp-test" deleted
----

==== Authorizing Policies

:configure-service-account: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/

When a PodSecurityPolicy resource is created, it does nothing. In order to use it, the requesting user or target pod's {configure-service-account}[service account] must be authorized to use the policy, by allowing the `use` verb on the policy.

Most Kubernetes pods are not created directly by users. Instead, they are typically created indirectly as part of a _Deployment_, _ReplicaSet_, or other templated controller via the _controller manager_. Granting the controller access to the policy would grant access for all pods created by that controller, so the preferred method for authorizing policies is to grant access to the pod's service account.

RBAC is a standard Kubernetes authorization mode, and can easily be used to authorize use of policies.

First, a `Role` or `ClusterRole` needs to grant access to use the desired policies. The rules to grant access look like this:

[source,yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: <role name>
rules:
- apiGroups: ['policy']
  resources: ['podsecuritypolicies']
  verbs:     ['use']
  resourceNames:
  - <list of policies to authorize>
----

Then the `(Cluster)Role` is bound to the authorized user(s):

[source,yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: <binding name>
roleRef:
  kind: ClusterRole
  name: <role name>
  apiGroup: rbac.authorization.k8s.io
subjects:
# Authorize all service accounts in a namespace (recommended):
- kind: Group
  apiGroup: rbac.authorization.k8s.io
  name: system:serviceaccounts:<authorized namespace>
# Authorize specific service accounts (not recommended):
- kind: ServiceAccount
  name: <authorized service account name>
  namespace: <authorized pod namespace>
# Authorize specific users (not recommended):
- kind: User
  apiGroup: rbac.authorization.k8s.io
  name: <authorized user name>
----

If a `RoleBinding` (not a `ClusterRoleBinding`) is used, it will only grant usage for pods being run in the same namespace as the binding. This can be paired with system groups to grant access to all pods run in the namespace:

[source,yaml]
----
# Authorize all service accounts in a namespace:
- kind: Group
  apiGroup: rbac.authorization.k8s.io
  name: system:serviceaccounts
# Or equivalently, all authenticated users in a namespace:
- kind: Group
  apiGroup: rbac.authorization.k8s.io
  name: system:authenticated
----

==== kube-psp-advisor

:kube-psp-advisor: https://github.com/sysdiglabs/kube-psp-advisor

Kubernetes Pod Security Policy Advisor (a.k.a {kube-psp-advisor}[kube-psp-advisor]) is an opensource tool from Sysdig. kube-psp-advisor scans the existing security context from Kubernetes resources like deployments, daementsets, replicasets, etc taken as the reference model we want to enforce and then automatically generates the Pod Security Policy for all the resources in the entire cluster.

[source,console]
----
$ kubectl krew install advise-psp
Updated the local copy of plugin index.
Installing plugin: advise-psp
Installed plugin: advise-psp
\
 | Use this plugin:
 | 	kubectl advise-psp
 | Documentation:
 | 	https://github.com/sysdiglabs/kube-psp-advisor
/
WARNING: You installed plugin "advise-psp" from the krew-index plugin repository.
   These plugins are not audited for security by the Krew maintainers.
   Run them at your own risk.

$ kubectl advise-psp inspect --namespace default --report
{
  "podSecuritySpecs": {
    "hostIPC": [],
    "hostNetwork": [],
    "hostPID": []
  },
  "podVolumeTypes": {
...
----

==== Example

[source,console]
----
$ kubectl apply -f - <<EOF
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: psp-hostpath
spec:
  seLinux:
    rule: RunAsAny
  supplementalGroups:
    rule: RunAsAny
  runAsUser:
    rule: RunAsAny
  fsGroup:
    rule: RunAsAny
  volumes:
    - configMap
    - emptyDir
    - projected
    - secret
    - downwardAPI
EOF
Warning: policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+
podsecuritypolicy.policy/psp-hostpath created

$ kubectl apply -f - <<EOF
> apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: psp:hostpath
rules:
  - apiGroups: ['policy']
    resources: ['podsecuritypolicies']
    verbs:     ['use']
    resourceNames:
      - psp-hostpath
EOF
clusterrole.rbac.authorization.k8s.io/psp:hostpath unchanged

$ kubectl create ns psp-test
namespace/psp-test created

$ kubectl create rolebinding -n psp-test edit --clusterrole edit --serviceaccount psp-test:default
rolebinding.rbac.authorization.k8s.io/edit created

$ kubectl create rolebinding -n psp-test psp:hostpath --clusterrole psp:hostpath --serviceaccount psp-test:default
rolebinding.rbac.authorization.k8s.io/psp:hostpath created

$ kubectl apply -n psp-test --as system:serviceaccount:psp-test:default -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: pause
spec:
  containers:
    - name: pause
      image: k8s.gcr.io/pause:3.6
EOF
pod/pause created

$ kubectl apply -n psp-test --as system:serviceaccount:psp-test:default -f - <<EOF
> apiVersion: v1
kind: Pod
metadata:
  name: hostpath
spec:
  containers:
    - name: pause
      image: k8s.gcr.io/pause:3.6
  volumes:
    - name: hostpath
      hostPath:
        path: /tmp
EOF
Error from server (Forbidden): error when creating "STDIN": pods "hostpath" is forbidden: PodSecurityPolicy: unable to admit pod: [spec.volumes[0]: Invalid value: "hostPath": hostPath volumes are not allowed to be used]

$ kubectl delete ns psp-test 
namespace "psp-test" deleted

$ kubectl delete psp psp-hostpath 
Warning: policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+
podsecuritypolicy.policy "psp-hostpath" deleted

$ kubectl delete clusterrole psp:hostpath
clusterrole.rbac.authorization.k8s.io "psp:hostpath" deleted
----

== Pod Security Admission

== References

* https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/
* https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/
* https://kubernetes.io/docs/concepts/policy/pod-security-policy/
* https://kubernetes.io/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/
* https://kubernetes.io/docs/concepts/security/pod-security-admission/
* https://www.suse.com/c/rancher_blog/enhancing-kubernetes-security-with-pod-security-policies-part-2/
* https://sysdig.com/blog/psp-in-production/
* https://sysdig.com/blog/enable-kubernetes-pod-security-policy/
