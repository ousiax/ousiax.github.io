= Kubernetes Admission Controllers
:page-layout: post
:page-categories: ['kubernetes']
:page-tags: ['kubernetes']
:page-date: 2021-12-15 12:27:15 +0800
:page-revdate: 2021-12-15 12:27:15 +0800
:sectnums:
:toc:

== What is an admission controller

:admission-controllers: https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/
:admission-webhooks: https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks

An {admission-controllers}[*admission controller*] is a piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object, but after the request is authenticated and authorized.

image::https://d33wubrfki0l68.cloudfront.net/673dbafd771491a080c02c6de3fdd41b09623c90/50100/images/docs/admin/access-control-overview.svg[,65%,65%]

The controllers are compiled into the *kube-apiserver* binary, and may only be configured by the cluster administrator. There are two special controllers: *MutatingAdmissionWebhook* and *ValidatingAdmissionWebhook*. These execute the mutating and validating (respectively) {admission-webhooks}[admission control webhooks] which are configured in the API.

Admission controllers *limit requests* to create, delete, modify objects or connect to proxy. They do *not limit requests* to read objects.

The admission control process proceeds in two phases. In the first phase, *mutating* admission controllers are run. In the second phase, *validating* admission controllers are run. Note again that some of the controllers are both.

If any of the controllers in either phase reject the request, the entire request is rejected immediately and an error is returned to the end-user.

=== Turn on/off an admission controller

The Kubernetes API server flag `enable-admission-plugins` takes a comma-delimited list of admission control plugins to invoke prior to modifying objects in the cluster.

[source,sh]
kube-apiserver --enable-admission-plugins=NamespaceLifecycle,LimitRanger ...

The Kubernetes API server flag `disable-admission-plugins` takes a comma-delimited list of admission control plugins to be disabled, even if they are in the list of plugins enabled by default.

[source,sh]
kube-apiserver --disable-admission-plugins=PodNodeSelector,AlwaysDeny ...

To see which admission plugins are enabled by default:

[source,sh]
kube-apiserver -h | grep enable-admission-plugins

[source,console]
----
$ docker run --rm -it k8s.gcr.io/kube-apiserver:v1.22.3 kube-apiserver -h | grep enable-admission-plugins
      --enable-admission-plugins strings       admission plugins that should be enabled in addition to default enabled ones (NamespaceLifecycle, LimitRanger, ServiceAccount, TaintNodesByCondition, PodSecurity, Priority, DefaultTolerationSeconds, DefaultStorageClass, StorageObjectInUseProtection, PersistentVolumeClaimResize, RuntimeClass, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, MutatingAdmissionWebhook, ValidatingAdmissionWebhook, ResourceQuota). Comma-delimited list of admission plugins: AlwaysAdmit, AlwaysDeny, AlwaysPullImages, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, DenyServiceExternalIPs, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodSecurity, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, RuntimeClass, SecurityContextDeny, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook. The order of plugins in this flag does not matter.
----

=== Dynamic Admission Control

:validatingadmissionwebhook: https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook
:mutatingadmissionwebhook: https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook
:validatingwebhookconfiguration-v1-admissionregistration-k8s-io: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io
:mutatingwebhookconfiguration-v1-admissionregistration-k8s-io: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#mutatingwebhookconfiguration-v1-admissionregistration-k8s-io

In addition to *compiled-in admission plugins*, admission plugins can be developed as extensions and run as *webhooks* configured at runtime. 

Admission webhooks are HTTP callbacks that receive admission requests and do something with them. You can define both {validatingadmissionwebhook}[*validating admission webhook*] and {mutatingadmissionwebhook}[*mutating admission webhook*] admission webhooks.

The webhook handles the `AdmissionReview` request sent by the apiservers, and sends back its decision as an `AdmissionReview` object in the same version it received.

Mutating admission webhooks are invoked first, and can modify objects sent to the API server to enforce custom defaults. After all object modifications are complete, and after the incoming object is validated by the API server, validating admission webhooks are invoked and can reject requests to enforce custom policies.

You can dynamically configure what resources are subject to what admission webhooks via {validatingwebhookconfiguration-v1-admissionregistration-k8s-io}[ValidatingWebhookConfiguration] or {mutatingwebhookconfiguration-v1-admissionregistration-k8s-io}[MutatingWebhookConfiguration].

You can use the follow commands to inspect details about each config field:

[source,sh]
----
$ kubectl explain mutatingwebhookconfigurations
$ kubectl explain validatingwebhookconfigurations
----

The following is an example `ValidatingWebhookConfiguration`, a mutating webhook configuration is similar. 

[source,yaml]
----
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: "pod-policy.kube-admission.io"
webhooks:
- name: "pod-policy.kube-admission.io"
  rules:
    - apiGroups:   [""]
      apiVersions: ["v1"]
      operations:  ["CREATE"]
      resources:   ["pods"]
      scope:       "Namespaced"
  clientConfig:
    caBundle: LS0....
    service:
      namespace: "default"
      name: "kube-admission"
      path: /always-allow-delay-5s
  admissionReviewVersions: ["v1"]
  sideEffects: None
  timeoutSeconds: 10
----

NOTE: Note: When using `clientConfig.service`, the server cert must be valid for `<svc_name>.<svc_namespace>.svc`. 

Besides, there's a sample of admission controller at GitHub: https://github.com/qqbuby/kube-admission.

=== What is a Pod Security Policy?

:pod-security-policy: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
:role-and-clusterrole: https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole
:kep-2579: https://github.com/kubernetes/enhancements/issues/2579
:pod-security-standards: https://kubernetes.io/docs/concepts/security/pod-security-standards/
:podsecurity: https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#podsecurity

[NOTE]
====
Kubernetes has officially https://kubernetes.io/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/[deprecated PodSecurityPolicy] in version 1.21. PodSecurityPolicy will be shut down in version 1.25.

*PodSecurityPolicy is being replaced by a new, simplified {podsecurity}[PodSecurity] admission controller.*
====

Kubernetes has officially https://kubernetes.io/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/[deprecated PodSecurityPolicy] in version 1.21. PodSecurityPolicy will be shut down in version 1.25.

PodSecurityPolicy is a built-in admission controller that allows a cluster administrator to control security-sensitive aspects of the Pod specification.

A {pod-security-policy}[*PodSecurityPolicy*] is a built-in admission controller that allows a cluster administrator to control security-sensitive aspects of the Pod specification to create and update Pods on your cluster.

In most Kubernetes clusters, RBAC (Role-Based Access Control) {role-and-clusterrole}[rules] control access to these resources. `list`, `get`, `create`, `edit`, and `delete` are the sorts of API operations that RBAC cares about, but *_RBAC does not consider what settings are being put into the resources it controls_*.

To control what sorts of settings are allowed in the resources defined in your cluster, you need *Admission Control* in addition to RBAC. 

Kubernetes SIG Security, SIG Auth, and a diverse collection of other community members have been working together for months to ensure that what’s coming next is going to be awesome. We have developed a Kubernetes Enhancement Proposal ({kep-2579}[KEP 2579]) and a prototype for a new feature, currently being called by the temporary name "*PSP Replacement Policy*."

If your use of PSP is relatively simple, with a few policies and straightforward binding to service accounts in each namespace, you will likely find PSP Replacement Policy to be a good match for your needs. Evaluate your PSPs compared to the Kubernetes {pod-security-standards}[*Pod Security Standards*] to get a feel for where you’ll be able to use the Restricted, Baseline, and Privileged policies. Please follow along with or contribute to the KEP and subsequent development, and try out the Alpha release of PSP Replacement Policy when it becomes available.

== Pod Security Admission

== References

* https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/
* https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/
* https://kubernetes.io/docs/concepts/policy/pod-security-policy/
* https://kubernetes.io/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/
* https://kubernetes.io/docs/concepts/security/pod-security-admission/
