= Algorithms
:page-layout: post
:page-categories: ['algorithms']
:page-tags: ['algorithms']
:page-date: 2023-08-18 10:18:05 +0800
:page-revdate: 2023-08-18 10:18:05 +0800
:toc: preamble
:toclevels: 4
:sectnums:
:sectnumlevels: 4

An *algorithm* is any well-defined computational procedure for solving a well-specified *computational problem* that takes some value, or set of values, as *input* and produces some value, or set of values, as *output*.

For example, given the input sequence `[31 41 59 26 41 58]`, a sorting algorithm returns as output `[26 31 41 41 58 59]`. Such an input sequence is called an *instance* of the sorting problem.

In general, an *instance of a problem* consists of the input (satisfying whatever constraints are imposed in the problem statement) needed to compute a solution to the problem.

An algorithm is said to be *correct* if, for every input instance, it halts with the correct output. An incorrect algorithm might not halt at all on some input instances, or it might halt with an incorrect answer. Contrary to what you might expect, incorrect algorithms can sometimes be useful, if we can control their error rate. Ordinarily, however, we shall be concerned only with correct algorithms.

A *data structure* is a way to store and organize data in order to facilitate access and modifications. No single data structure works well for all purposes, and so it is important to know the strengths and limitations of several of them.

[source,txt]
----
INSERTION-SORT(A)
1    for j = 2 to A.length
2       key = A[j] 
3       // Insert A[j]  into the sorted sequence A[1:j-1].
4       i = j - 1
5       while i > 0 and A[i] > key
6           A[i+1] = A[i]
7           i = i - 1
8       A[i+1] = key
----

At the start of each iteration of the for loop of lines 1–8, the subarray `A[1:j-1]` consists of the elements originally in `A[1:j-1]`, but in sorted order, formally called as a *loop invariant*.

* Initialization: It is true prior to the first iteration of the loop.

* Maintenance: If it is true before an iteration of the loop, it remains true before the next iteration.

* Termination: When the loop terminates, the invariant gives us a useful property that helps show that the algorithm is correct.

Note the similarity to mathematical induction, where to prove that a property holds, you prove a base case and an inductive step until the loop terminates instead of infinitely.

== Analyzing algorithms

Analyzing an algorithm has come to mean predicting the resources that the algorithm requires, such as memory, communication bandwidth, or computer hardware are of primary concern, but most often it is computational time to be measured.

The time taken by the INSERTION-SORT procedure depends on the size of the input, and how nearly already sorted about two input sequences of the same size: sorting a thousand numbers takes longer than sorting three numbers.

image::/assets/algorithms/insert-sort-run-time.jpg[,50%,50%]

For each `j = 2,3, ... ,n`, where `n = A.length`, we let `t~j~` denote the number of times the *while* loop test in line 5 is executed for that value of `j`. When a *for* or *while* loop exits in the usual way (i.e., due to the test in the loop header), the test is executed one time more than the loop body. The running time of INSERTION-SORT `T(n)` on an input of n values is the sum of the products of the _cost_ and _times_ columns.

// Even for inputs of a given size, an algorithm’s running time may depend on which input of that size is given.
// 
// For example, in INSERTION-SORT, the best case occurs if the array is already sorted.








[appendix]
== Pseudocode conventions

* Indentation indicates block structure.
+
Using indentation instead of conventional indicators of block structure, such as `begin` and `end` statements, greatly reduces clutter while preserving, or even enhancing, clarity.

* The looping constructs `while`, `for`, and `repeat-until` and the `if-else` conditional construct have interpretations similar to those in C, C++, Java, Python, and Pascal.

** After a for loop immediately, the loop counter’s value is the value that first exceeded the for loop bound.

** We use the keyword *to* when a for loop increments its loop counter in each iteration, and we use the keyword *downto* when a for loop decrements its loop counter.

** When the loop counter changes by an amount greater than 1, the amount of change follows the optional keyword *by*.

* The symbol `//` indicates that the remainder of the line is a comment.

* A multiple assignment of the form `i = j = e` assigns to both variables `i` and `j` the value of expression `e`; it should be treated as equivalent to the assignment `j = e` followed by the assignment `i = j`.

* Variables (such as `i` , `j`, and `key`) are local to the given procedure. We shall not use global variables without explicit indication.

* Array elements are accessed by specifying the array name followed by the index (based one instead of zero) in square brackets.
+
The notation `:` is used to indicate a range of values within an array, thus, `A[1:j]` indicates the subarray of `A` consisting of the `j` elements `A[1]`,`A[2]`,...,`A[j]`.

* Compound data typically is organized into *objects*, which are composed of *attributes*.

** A particular attribute is accessed using the syntax found in many object-oriented programming languages: the object name, followed by a dot, followed by the attribute name.

** A variable representing an array or object is treated as a pointer to the data representing the array or object.

** Sometimes, a pointer gived it the special value `NIL` will refer to no object at all.

* Parameters are passed to a procedure *by value*: the called procedure receives its own copy of the parameters, and if it assigns a value to a parameter, the change is not seen by the calling procedure.
+
When objects are passed, the pointer to the data representing the object is copied, but the object’s attributes are not.

* A *return* statement immediately transfers control back to the point of call in the calling procedure.
+
Most return statements also take a value to pass back to the caller, and multiple values are allowed to be returned in a single return statement.

* The boolean operators “and” and “or” are *short circuiting*.

* The keyword *error* indicates that an error occurred because conditions were wrong for the procedure to have been called.
