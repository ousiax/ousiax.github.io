= TCP/IP: TCP Connection Management
:page-layout: post
:page-categories: ['networking']
:page-tags: ['networking', 'tcp']
:page-date: 2023-01-10 10:14:59 +0800
:page-revdate: 2023-01-10 10:14:59 +0800
:toc: preamble
:toclevels: 4
:sectnums:
:sectnumlevels: 4

TCP is a unicast *connection-oriented* protocol.

* Before either end can send data to the other, a connection must be established between them.

* During connection establishment, several options can be exchanged between the two endpoints regarding the parameters of the connection.

* Some options are allowed to be sent only when the connection is established, and others can be sent later.

* Because of its management of *connection state* (information about the connection kept by both endpoints), TCP is a considerably more complicated protocol than UDP.
+
UDP is a *connectionless* protocol that involves no connection establishment or termination.
+
One of the major differences between the two is the amount of detail required to handle the various TCP states properly: when connections are created, terminated normally, and reset without warning.

Recall that TCP's service model is a byte stream. TCP detects and repairs essentially all the data transfer problems that may be introduced by packet loss, duplication, or errors at the IP layer (or below).

== TCP Connection Establishment and Termination

A TCP *_connection_* is defined to be a 4-tuple consisting of two IP addresses and two port numbers. More precisely, it is a pair of _endpoints_ or _sockets_ where each endpoint is identified by an (IP address, port number) pair.

A connection typically goes through three phases: setup, data transfer (called _established_), and teardown (closing).

.A normal TCP connection establishment and termination (without any data transfer). Usually, the client initiates a three-way handshake to exchange initial sequence numbers carried on SYN segments for the client and server (ISN(c) and ISN(s), respectively). The connection terminates after each side has sent a FIN and received an acknowledgment for it.
image::/assets/tcp-ip/tcp-connection-management/tcp-connection-establishment-and-termination.png[A normal TCP connection establishment and termination,55%,55%]

To establish a TCP connection, the following events usually take place:

. The *_active opener_* (normally called the client) sends a SYN segment (i.e., a TCP/IP packet with the _SYN_ bit field turned on in the TCP header) specifying the port number of the peer to which it wants to connect and the client's initial sequence number or ISN(c).
+
It typically sends one or more options at this point.
+
This is segment 1.

. The server responds with its own SYN segment containing its initial sequence number (ISN(s)).
+
This is segment 2.
+
The server also acknowledges the client's SYN by ACKing ISN(c) plus 1.
+
A SYN consumes one sequence number and is retransmitted if lost.

. The client must acknowledge this SYN from the server by ACKing ISN(s) plus 1.
+
This is segment 3.

These three segments complete the connection establishment. This is often called the *_three-way handshake_*.

* Its main purposes are to let each end of the connection know that a connection is starting and the special details that are carried as options, and to exchange the ISNs.

* The side that sends the first SYN is said to perform an *active open*. As mentioned, this is typically a client.
* The other side, which receives this SYN and sends the next SYN, performs a *passive open*. It is most commonly called the server.
* There is a supported but unusual *simultaneous open* when both sides can do an active open at the same time and become both clients and servers.

Either end can initiate a close operation, and simultaneous closes are also supported but are rare.

* Traditionally, it was most common for the client to initiate a close.
* However, other servers (e.g., Web servers) initiate a close after they have completed a request.
* Usually a close operation starts with an application indicating its desire to terminate its connection (e.g., using the `close()` system call).
* The closing TCP initiates the close operation by sending a FIN segment (i.e., a TCP segment with the _FIN_ bit field set).

The complete close operation occurs after both sides have completed the close:

. The *active closer* sends a FIN segment specifying the current sequence number the receiver expects to see (_K_).
+
The FIN also includes an ACK for the last data sent in the other direction (labeled _L_).

. The *passive closer* responds by ACKing value _K + 1_ to indicate its successful receipt of the active closer's FIN.
+
At this point, the application is notified that the other end of its connection has performed a close.
+
Typically this results in the application initiating its own close operation.
+
The passive closer then effectively becomes another active closer and sends its own FIN. The sequence number is equal to _L_.

. To complete the close, the final segment contains an ACK for the last FIN.
+
Note that if a FIN is lost, it is retransmitted until an ACK for it is received.

While it takes three segments to establish a connection, it takes four to terminate one.

It is also possible for the connection to be in a _half-open_ state, although this is not common. This reason is that TCP's data communications model is bidirectional, meaning it is possible to have only one of the two directions operating.

The _half-close_ operation in TCP closes only a single direction of the data flow. Two half-close operations together close the entire connection. The rule is that either end can send a FIN when it is done sending data.

When a TCP receives a FIN, it must notify the application that the other end has terminated that direction of data flow. The sending of a FIN is normally the result of the application issuing a close operation, which typically causes both directions to close.

The seven segments we have seen are baseline overheads for any TCP connection that is established and cleared gracefully.

* When a small amount of data needs to be exchanged, it is now apparent why some applications prefer to use UDP because of its ability to send and receive data without establishing connections.

* However, such applications are then faced with handling their own error repair features, congestion management, and flow control.

=== TCP Half-Close

TCP supports a half-close operation. Few applications require this capability, so it is not common.

To use this feature, the API must provide a way for the application to say, essentially, "I am done sending data, so send a FIN to the other end, but I still want to receive data from the other end, until it sends me a FIN".

The Berkeley sockets API supports half-close, if the application calls the `shutdown()` function instead of calling the more typical `close()` function. Most applications, however, terminate both directions of the connection by calling `close`.

.With the TCP half-close operation, one direction of the connection can terminate while the other continues until it is closed. Few applications use this feature.
image::/assets/tcp-ip/tcp-connection-management/tcp-half-close-operation.png[TCP half close,45%,45%]

=== Simultaneous Open and Close

It is possible, although highly improbable unless specifically arranged, for two applications to perform an active open to each other at the same time. If this happens, it is called a *simultaneous open*.

* Each end must have transmitted a SYN before receiving a SYN from the other side; the SYNs must pass each other on the network.
* This scenario also requires each end to have an IP address and port number that are known to the other end, which is rare (except for the firewall _hole-punching_ techniques).
* A simultaneous open requires the exchange of four segments, one more than the normal three-way handshake.
* Also note that we do not call either end a client or a server, because both ends act as client and server.

.Segments exchanged during simultaneous open. One additional segment is required compared to the ordinary connection establishment procedure. The SYN bit field is on in each segment until an ACK for it is received.
image::/assets/tcp-ip/tcp-connection-management/tcp-simultaneous-open.png[TCP simultaneous open,55%,55%]

With a *simultaneous close* the same number of segments are exchanged as in the normal close. The only real difference is that the segment sequence is interleaved instead of sequential.

.Segments exchanged during simultaneous close work like a conventional close, but the segment ordering is interleaved.
image::/assets/tcp-ip/tcp-connection-management/tcp-simultaneous-close.png[TCP simultaneous close,55%,55%]

=== Initial Sequence Number (ISN)

When a connection is open, any segment with the appropriate two IP addresses and port numbers is accepted as valid provided the sequence number is valid (i.e., within the window) and the checksum is OK.

Before each end sends its SYN to establish the connection, it chooses an ISN for that connection.

* The ISN should change over time, so that each connection has a different one.
+
[RFC0793] specifies that the ISN should be viewed as a 32-bit counter that increments by 1 every 4μs.

* The purpose of doing this is to arrange for the sequence numbers for segments on one connection to not overlap with sequence numbers on a another (new) identical connection.

* In particular, new sequence numbers must not be allowed to overlap between different _instantiations_ (or _incarnations_) of the _same_ connection.

* In modern systems, the ISN is typically selected in a semirandom way.

If a connection had one of its segments delayed for a long period of time and closed, but then opened again with the same 4-tuple, it is conceivable that the delayed segment could reenter the new connection's data stream as valid data.

* By taking steps to avoid overlap in sequence numbers between connection instantiations, we can try to minimize this risk.

* It does suggest, however, that an application with a very great need for data integrity should employ its own CRCs or checksums at the application layer to ensure that its own data has been transferred without error.
+
This is generally good practice in any case, and it is commonly done for large files.

The connection 4-tuple as well as the currently active window of sequence numbers is all that is required to form a TCP segment that is considered valid to a communicating TCP endpoint, which represents a form of vulnerability for TCP:

* anyone can forge a TCP segment and, if the sequence numbers, IP addresses, and port numbers are chosen appropriately, can interrupt a TCP connection [RFC5961].
* One way of repelling this is to make the initial sequence number (or ephemeral port number [RFC6056]) relatively hard to guess. Another is encryption.

=== Example

[source,console]
----
x@node-0:~$ telnet github.io 80
Trying 185.199.108.153...
Connected to github.io.
Escape character is '^]'.
^]
telnet> q
Connection closed.
----

[source,console]
----
x@node-0:~$ sudo tcpdump -ntSv host github.io

IP (tos 0x10, ttl 64, id 29406, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.128.51610 > 185.199.108.153.80: Flags [S], cksum 0x42b8 (incorrect -> 0xd5cf), seq 2440985640, win 64240, options [mss 1460,sackOK,TS val 1617951924 ecr 0,nop,wscale 7], length 0
IP (tos 0x0, ttl 128, id 44533, offset 0, flags [none], proto TCP (6), length 44)
    185.199.108.153.80 > 192.168.91.128.51610: Flags [S.], cksum 0x11dd (correct), seq 1194142207, ack 2440985641, win 64240, options [mss 1460], length 0
IP (tos 0x10, ttl 64, id 29407, offset 0, flags [DF], proto TCP (6), length 40)
    192.168.91.128.51610 > 185.199.108.153.80: Flags [.], cksum 0x42a4 (incorrect -> 0x299a), ack 1194142208, win 64240, length 0
IP (tos 0x10, ttl 64, id 29408, offset 0, flags [DF], proto TCP (6), length 40)
    192.168.91.128.51610 > 185.199.108.153.80: Flags [F.], cksum 0x42a4 (incorrect -> 0x2999), seq 2440985641, ack 1194142208, win 64240, length 0
IP (tos 0x0, ttl 128, id 44534, offset 0, flags [none], proto TCP (6), length 40)
    185.199.108.153.80 > 192.168.91.128.51610: Flags [.], cksum 0x299a (correct), ack 2440985642, win 64239, length 0
IP (tos 0x0, ttl 128, id 44535, offset 0, flags [none], proto TCP (6), length 40)
    185.199.108.153.80 > 192.168.91.128.51610: Flags [FP.], cksum 0x2991 (correct), seq 1194142208, ack 2440985642, win 64239, length 0
IP (tos 0x10, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40)
    192.168.91.128.51610 > 185.199.108.153.80: Flags [.], cksum 0x2998 (correct), ack 1194142209, win 64240, length 0
^C
7 packets captured
12 packets received by filter
0 packets dropped by kernel
----

=== Timeout of Connection Establishment

There are several circumstances in which a connection cannot be established. One obvious case is when the server host is down.

To simulate this scenario, we issue our telnet command to a nonexistent host in the same subnet.

* If we do this without modifying the ARP table, the client exits with a "No route to host" error message, generated because no ARP reply is ever returned for the ARP request.
* If, however, we place an ARP entry for a nonexistent host in the ARP table first, the ARP request is not sent, and the system immediately attempts to contact the nonexistent host with TCP/IP. First, the commands:
+
[source,console]
----
x@node-0:~$ sudo ip neigh add 192.168.91.120 lladdr 00:00:1a:1b:1c:1d dev ens32
----
+
Here the MAC address `00:00:1a:1b:1c:1d` was chosen simply as a MAC address not being used on the LAN; it is of no special consequence.

* The timeout occurs about 2 minutes after the initial command.
+
[source,console]
----
x@node-0:~$ time telnet 192.168.91.120 80
Trying 192.168.91.120...
telnet: Unable to connect to remote host: Connection timed out

real	2m11.038s
user	0m0.002s
sys	0m0.001s
----

* Because there is no host to respond, all of the segments generated are from the client.
+
[source,console]
----
x@node-0:~$ sudo tcpdump -ntttSvv host 192.168.91.120
tcpdump: listening on ens32, link-type EN10MB (Ethernet), snapshot length 262144 bytes
 00:00:00.000000 IP (tos 0x10, ttl 64, id 28344, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.128.47586 > 192.168.91.120.80: Flags [S], cksum 0x3878 (incorrect -> 0xb088), seq 54668487, win 64240, options [mss 1460,sackOK,TS val 1492721928 ecr 0,nop,wscale 7], length 0
 00:00:01.018720 IP (tos 0x10, ttl 64, id 28345, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.128.47586 > 192.168.91.120.80: Flags [S], cksum 0x3878 (incorrect -> 0xac8d), seq 54668487, win 64240, options [mss 1460,sackOK,TS val 1492722947 ecr 0,nop,wscale 7], length 0
 00:00:02.016512 IP (tos 0x10, ttl 64, id 28346, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.128.47586 > 192.168.91.120.80: Flags [S], cksum 0x3878 (incorrect -> 0xa4ad), seq 54668487, win 64240, options [mss 1460,sackOK,TS val 1492724963 ecr 0,nop,wscale 7], length 0
 00:00:04.096269 IP (tos 0x10, ttl 64, id 28347, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.128.47586 > 192.168.91.120.80: Flags [S], cksum 0x3878 (incorrect -> 0x94ad), seq 54668487, win 64240, options [mss 1460,sackOK,TS val 1492729059 ecr 0,nop,wscale 7], length 0
 00:00:08.191479 IP (tos 0x10, ttl 64, id 28348, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.128.47586 > 192.168.91.120.80: Flags [S], cksum 0x3878 (incorrect -> 0x74ad), seq 54668487, win 64240, options [mss 1460,sackOK,TS val 1492737251 ecr 0,nop,wscale 7], length 0
 00:00:16.128796 IP (tos 0x10, ttl 64, id 28349, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.128.47586 > 192.168.91.120.80: Flags [S], cksum 0x3878 (incorrect -> 0x35ac), seq 54668487, win 64240, options [mss 1460,sackOK,TS val 1492753380 ecr 0,nop,wscale 7], length 0
 00:00:34.047254 IP (tos 0x10, ttl 64, id 28350, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.128.47586 > 192.168.91.120.80: Flags [S], cksum 0x3878 (incorrect -> 0xb0ac), seq 54668487, win 64240, options [mss 1460,sackOK,TS val 1492787427 ecr 0,nop,wscale 7], length 0
^C
7 packets captured
7 packets received by filter
0 packets dropped by kernel
----

The number of times to retry an initial SYN can be configured on some systems. In Linux,

* the system configuration variable `net.ipv4.tcp_syn_retries` gives the maximum number of times to attempt to resend a SYN segment during an active open.

* A corresponding value called `net.ipv4.tcp_synack_retries` gives the maximum number of times to attempt to resend a SYN + ACK segment when responding to a peer's active open request.

* It can also be used on an individual connection basis by setting the Linux-specific TCP_SYNCNT socket option.
+
[source,console]
----
x@node-0:~$ sudo sysctl net.ipv4.tcp_syn_retries net.ipv4.tcp_synack_retries
net.ipv4.tcp_syn_retries = 6
net.ipv4.tcp_synack_retries = 5

x@node-0:~$ man 7 tcp
...
TCP_SYNCNT (since Linux 2.4)
       Set the number of SYN retransmits that TCP should send before aborting the attempt to connect.  It cannot exceed 255.  This option should not be used
       in code intended to be portable.
----

== TCP Options

The only options defined in the original TCP specification are the _End of Option List_ (EOL), the _No Operation_ (NOP), and the _Maximum Segment Size_ (MSS) options.

.The TCP option values. Up to 40 bytes are available to hold options.
[%header,cols="1,1,2,1,5"]
|===
|Kind
|Length
|Name
|Reference
|Description and Purpose

|0
|1
|EOL
|[RFC0793]
|End of Option List

|1
|1
|NOP
|[RFC0793]
|No Operation (used for padding)

|2
|4
|MSS
|[RFC0793]
|Maximum Segment Size

|3
|3
|WSOPT
|[RFC1323]
|Window Scaling Factor (left-shift amount on window)

|4
|2
|SACK-Permitted
|[RFC2018]
|Sender supports SACK options

|5
|Var.
|SACK
|[RFC2018]
|SACK block (out-of-order data received)

|8
|10
|TSOPT
|[RFC1323]
|Timestamps option

|28
|4
|UTO
|[RFC5482]
|User Timeout (abort after idle time)

|29
|Var.
|TCP-AO
|[RFC5925]
|Authentication option (using various algorithms)

|253
|Var.
|Experimental
|[RFC4727]
|Reserved for experimental use

|254
|Var.
|Experimental
|[RFC4727]
|Reserved for experimental use

|===

* Every option begins with a 1-byte _kind_ that specifies the type of option.

* Options that are not understood are simply ignored, according to [RFC1122].

* The options with a _kind_ value of 0 and 1 occupy a single byte.

* The other options have a _len_ byte that follows the _kind_ byte. The length is the total length, including the _kind_ and _len_ bytes.

* The reason for the NOP option is to allow the sender to pad fields to a multiple of 4 bytes, if it needs to.
+
Remember that the TCP header's length is always required to be a multiple of 32 bits because the TCP _Header Length_ field uses that unit.

* The EOL option indicates the end of the list and that no further processing of the options list is to be performed.

=== Maximum Segment Size (MSS) Option

The maximum segment size (MSS) is the largest segment that a TCP is willing to receive from its peer and, consequently, the largest size its peer should ever use when sending.

* The MSS value counts only TCP data bytes and does not include the sizes of any associated TCP or IP header [RFC0879].

* When a connection is established, each end usually announces its MSS in an MSS option carried with its SYN segment.

* The option allows for 16 bits to be used to specify the MSS value.

* If no MSS option is provided, a default value of 536 bytes is used.
+
Recall the rule that requires any host to be capable of processing IPv4 datagrams at least as large as 576.
+
With minimum-size IPv4 and TCP headers, a TCP using a sending MSS size of 536 bytes produces an IPv4 datagram of size 20 + 20 + 536 = 576 bytes.

* The MSS value 1460 is typical for IPv4.
+
The resulting IPv4 datagram is normally 40 bytes larger (1500 bytes total, the typical MTU size for Ethernet and path MTU for the Internet): 20 bytes for the TCP header and 20 bytes for the IPv4 header.

* When IPv6 is used, the MSS is usually 1440, 20 bytes less because of the larger IPv6 header.
+
The special MSS value of 65535 can be used with IPv6 jumbograms to indicate an effective MSS of infinity [RFC2675].
+
In this case the SMSS will be determined as the PMTU minus 60 bytes (40 bytes for the IPv6 header and 20 bytes for the TCP header).

* Note that the MSS option is not a negotiation between one TCP and its peer; it is a limit.
+
When one TCP gives its MSS option to the other, it is indicating its unwillingness to accept any segments larger than that size for the duration of the connection.

=== Selective Acknowledgment (SACK) Options

Because it uses cumulative ACKs, TCP with a sliding window is never able to acknowledge data it has received correctly but that is not contiguous, in terms of sequence numbers, with data it has received previously.

* In such cases, the TCP receiver is said to have _holes_ in its received data queue.
* A receiving TCP prevents applications from consuming data beyond a hole because of the byte stream abstraction it provides.

If a TCP sender were able to learn of the existence of holes (and out-of-sequence data blocks beyond holes in the sequence space) at the receiver, it could better select which particular TCP segments to retransmit when segments are lost or otherwise missing at the receiver.

* The TCP selective acknowledgment (SACK) options [RFC2018][RFC2883] provide this capability.
* The scheme works effectively, however, only if the TCP sender logic is able to make effective use of the SACK information it receives from a SACK-capable receiver.
* A TCP learns that its peer is capable of advertising SACK information by receiving the _SACK-Permitted_ option in a SYN (or SYN + ACK) segment.
* Once this has taken place, the TCP receiving out-of-sequence data may provide a _SACK_ option that describes the out-of-sequence data to help its peer perform retransmissions more efficiently.

SACK information contained in a SACK option consists of a range of sequence numbers representing data blocks the receiver has successfully received.

* Each range is called a SACK _block_ and is represented by a pair of 32-bit sequence numbers.

* Thus, a _SACK_ option containing _n_ SACK blocks is (_8n + 2_) bytes long. Two bytes are used to hold the kind and length of the _SACK_ option.

* Because of the limited amount of space available in the option space of a TCP header, the maximum number of SACK blocks available to be sent in a single segment is three (assuming the _Timestamps_ option is also used, which is typical for modern TCP implementations).

* Although the _SACK-Permitted_ option is only ever sent in a SYN segment, the SACK blocks themselves may be sent in any segment once the sender has sent the _SACK-Permitted_ option.

* The operation of SACK is most easily (and importantly) related to the error and congestion control operations of TCP.

=== Window Scale (WSCALE or WSOPT) Option

The _Window Scale_ option (denoted _WSCALE_ or _WSOPT_) [RFC1323] effectively increases the capacity of the TCP _Window Advertisement_ field from 16 to about 30 bits.

Instead of changing the field size, however, the header still holds a 16-bit value, and an option is defined that applies a scaling factor to the 16-bit value.

* This factor effectively left-shifts the window field value by the scale factor.
+
This, in effect, multiplies the window value by the value 2^s^, where _s_ is the scale factor.

* The 1-byte shift count is between 0 and 14 (inclusive).

** A shift count of 0 indicates no scaling.
** The maximum scale value of 14 provides for a maximum window of 1,073,725,440 bytes (65,535 × 2^14^), close to 1,073,741,823 (2^30^ −1), effectively 1GB.
+
TCP then maintains the _real_ window size internally as a 32-bit value.

This option can appear only in a SYN segment, so the scale factor is fixed in each direction when the connection is established.

* To enable window scaling, both ends must send the option in their SYN segments.
* The end doing the active open sends the option in its SYN, but the end doing the passive open can send the option only if the received SYN specifies the option.
* The scale factor can be different in each direction.
+
If the end doing the active open sends a nonzero scale factor but does not receive a _Window Scale_ option from the other end, it sets its send and receive scale values to 0.
+
This lets systems that do not understand the option interoperate with systems that do.

Assume we are using the _Window Scale_ option, with a shift count of _S_ for sending and a shift count of _R_ for receiving.

* Then every 16-bit advertised window that we receive from the other end is left-shifted by _R_ bits to obtain the real advertised window size.
* Every time we send a window advertisement to the other end, we take our real 32-bit window size and right-shift it _S_ bits, placing the resulting 16-bit value in the TCP header.

The shift count is automatically chosen by TCP, based on the size of the receive buffer. The size of this buffer is set by the system, but the capability is normally provided for the application to change it.

The _Window Scale_ option is most relevant when TCP is used to provide bulk data transfer over networks with large-bandwidth-delay products (i.e., those with a product of round-trip time and bandwidth being relatively large).

[source,console]
----
IP (tos 0xc0, ttl 200, id 64132, offset 0, flags [DF], proto TCP (6), length 52, bad cksum 0 (->f66f)!)
    10.170.109.10.50979 > 175.24.154.66.443: Flags [S], cksum 0xc135 (incorrect -> 0x82a4), seq 3917970949, win 64240, options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0
IP (tos 0x20, ttl 52, id 0, offset 0, flags [DF], proto TCP (6), length 52)
    175.24.154.66.443 > 10.170.109.10.50979: Flags [S.], cksum 0xdacf (correct), seq 2258807318, ack 3917970950, win 29200, options [mss 1440,nop,nop,sackOK,nop,wscale 7], length 0
IP (tos 0xc0, ttl 200, id 64133, offset 0, flags [DF], proto TCP (6), length 40, bad cksum 0 (->f67a)!)
    10.170.109.10.50979 > 175.24.154.66.443: Flags [.], cksum 0xc129 (incorrect -> 0x8b99), ack 2258807319, win 517, length 0
----

=== Timestamps Option and Protection against Wrapped Sequence Numbers (PAWS)

The _Timestamps_ option (sometimes called the _Timestamp_ option and written as _TSOPT_ or _TSopt_) lets the sender place two 4-byte timestamp values in every segment.

The receiver reflects these values in the acknowledgment, allowing the sender to calculate an estimate of the connection's RTT for each ACK received.

* We must say "each ACK received" and not "each segment" because TCP often acknowledges multiple segments per ACK.

* When using the _Timestamps_ option,

** the sender places a 32-bit value in the _Timestamp Value_ field (called _TSV_ or _TSval_) in the first part of the _TSOPT_,
** and the receiver echoes this back unchanged in the second _Timestamp Echo Retry_ field (called _TSER_ or _TSecr_).

* TCP headers containing this option increase by 10 bytes (8 bytes for the two timestamp values and 2 to indicate the option value and length).

* The timestamp is a monotonically increasing value.

** Because the receiver simply echoes what it receives, it does not care what the timestamp units or values actually are.
** This option does not require any form of clock synchronization between the two hosts.
** [RFC1323] recommends that the sender increment the timestamp value by at least 1 every second.

The main reason for wishing to calculate a good estimate of the connection's RTT is to set the retransmission timeout, which tells TCP when it should try resending a segment that is likely lost.

* With the _Timestamps_ option, we can get relatively fine-grain measurements of the RTT.
* Prior to the creation of the _Timestamps_ option, most TCPs would perform just one RTT sample per window of data.
* With the _Timestamps_ option, more samples can be taken, leading to the potential of a better RTT estimate (see [RFC1323] and [RFC6298]).

The _Timestamps_ option allows for more frequent RTT samples, but it also provides a way for the receiver to avoid receiving old segments and considering them as valid, which is called _Protection Against Wrapped Sequence Numbers_ (PAWS), and it is described in [RFC1323] along with the _Timestamps_ option.

=== User Timeout (UTO) Option

The _User Timeout_ (UTO) option is a relatively new TCP capability described in [RFC5482]. The UTO value (also called _USER_TIMEOUT_) specifies the amount of time a TCP sender is willing to wait for an ACK of outstanding data before concluding that the remote end has failed.

_USER_TIMEOUT_ has traditionally been a local configuration parameter for TCP [RFC0793]. The UTO option allows one TCP to signal its _USER_TIMEOUT_ value to its connection peer. This allows the receiving TCP to adjust its behavior (e.g., to tolerate a longer period of disrupted connectivity prior to aborting a connection). NAT devices could also interpret such information to help set their connection activity timers.

UTO option values are advisory; just because one end of a connection might wish to use a large or small UTO value does not mean that the other end needs to comply.

UTO options are included on SYN segments when a connection is established, on the first non-SYN segments, and whenever the _USER_TIMEOUT_ value is changed. The option value is expressed as a 15-bit value in units of seconds or minutes following a bit field (_granularity_) that indicates that the value is in minutes (_1_) or seconds (_0_). As a relatively new option, it is not yet widely deployed.

=== Authentication Option (TCP-AO)

There is an option used to enhance the security of TCP connections. It is designed to enhance and replace an earlier mechanism called _TCP-MD5_ [RFC2385]. Called the _TCP Authentication Option_ (TCP-AO) [RFC5925], it uses a cryptographic hash algorithm, in combination with a secret value known to each end of a TCP connection, to authenticate each segment.

TCP-AO improves upon TCP-MD5 by supporting a variety of cryptographic algorithms and identifying changing of keys using in-band signaling. It does not provide a comprehensive key management solution, however. That is, each end still has to have a way to establish a shared set of keys prior to operation.

However, because it requires creation and distribution of a shared key (and is a relatively new option), it is not yet widely deployed.

== Path MTU Discovery with TCP

The path MTU is the minimum MTU on any network segment that is currently in the path between two hosts.

* Knowing the path MTU can help protocols such as TCP avoid fragmentation.

* The discovering of the path MTU (PMTUD) is accomplished based on ICMP messages.
+
We shall use the ICMPv6 Packet Too Big (PTB) terminology to refer to either ICMPv4 Destination Unreachable (Fragmentation Required) or ICMPv6 Packet Too Big messages.
+
A method that avoids the use of ICMP, called _Packetization Layer Path MTU Discovery_ (PLPMTUD), can also be used by TCP [RFC4821] or by other transport protocols.

* UDP is not usually able to adapt its datagram size because the application specifies the size (i.e., not the transport protocol).
+
TCP, in providing the byte stream abstraction it implements, determines what segment size to use and as a result has a much greater degree of control over the size of IP datagrams that are ultimately generated.

TCP's regular PMTUD process operates as follows:

* When a connection is established, TCP uses the minimum of the MTU of the outgoing interface, or the MSS announced by the other end, as the basis for selecting its _send maximum segment size_ (SMSS).

* PMTUD does not allow TCP to exceed the MSS announced by the other end.

* If the other end does not specify an MSS, the sender assumes a default of 536 bytes, but this situation is now rare.

* It is also possible for an implementation to save path MTU information on a per-destination basis to help in selecting its segment size.

* Note that the path MTU in each direction of a connection could be different.

* Once the initial SMSS is chosen, all IPv4 datagrams sent by TCP on that connection have the IPv4 _DF_ bit field set.
+
For TCP/IPv6, this is not necessary because there is no DF bit field; all datagrams are assumed to have it set implicitly.

* If a PTB is received, TCP decreases the segment size and retransmits using a different segment size.
+
If the PTB contains the suggested next-hop MTU, the segment size can be set to the next-hop MTU minus the sizes of the IPv4 (or IPv6) and TCP headers.
+
If the next-hop MTU value is not present (e.g., an older ICMP error was returned that lacks this information), the sender may try a variety of values (e.g., binary-search for a usable value).
+
This also affects TCP's congestion control management.

* For PLPMTUD the situation is similar, except PTB messages are not used.
+
Instead, the protocol performing PMTUD must be able to detect message discards quickly and perform its own datagram size adjustments.

* Because routes can change dynamically, when some time has passed since the last decrease of the segment size, a larger value (up to the initial SMSS) can be tried.
+
Guidance in [RFC1191] and [RFC1981] recommends that this time interval be about 10 minutes.

There are a number of problems with PMTUD when it operates in an Internet environment with firewalls that block PTB messages [RFC2923].

Of the various operational problems with PMTUD, *_black holes_* have been the most problematic, although the situation is improving (in [LS10], 80% of systems studied were able to properly process PTB messages).

PMTUD _black holes_ arise when a TCP implementation that depends on the delivery of ICMP messages to adjust its segment size never receives them.

* This could be for several reasons, including a firewall or NAT configuration that prohibits such ICMP messages from being forwarded.

* The consequence is a TCP connection that cannot proceed once it starts to use larger packets.

* It can be difficult to diagnose because only large packets cannot be forwarded.
+
The smaller ones (such as SYN and SYN + ACK packets used to establish the connection) generally succeed.

Some TCP implementations have _black hole detection_, which amounts to trying a smaller segment size when a segment is retransmitted several times.

\# a router (`node-1`, a Linux host with local address `192.168.91.137`)

[source,console]
----
x@node-1:~$ sudo sysctl net.ipv4.conf.all.send_redirects=0
net.ipv4.conf.all.send_redirects = 0
x@node-1:~$ sudo sysctl net.ipv4.conf.ens32.send_redirects=0
net.ipv4.conf.ens32.send_redirects = 0
x@node-1:~$ sudo sysctl net.ipv4.ip_forward=1
net.ipv4.ip_forward = 1

x@node-1:~$ ip r
default via 192.168.91.2 dev ens32 
192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.137 

x@node-1:~$ sudo ip link set ens32 mtu 288
x@node-1:~$ ip a show ens32 
2: ens32: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 288 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:85:26:07 brd ff:ff:ff:ff:ff:ff
    inet 192.168.91.137/24 brd 192.168.91.255 scope global ens32
       valid_lft forever preferred_lft forever
----

\# the client system (`node-0`) that small segments are allowed:

[source,console]
----
x@node-0:~$ sudo sysctl net.ipv4.route.min_pmtu 
net.ipv4.route.min_pmtu = 552
x@node-0:~$ sudo sysctl net.ipv4.route.min_pmtu=68
net.ipv4.route.min_pmtu = 68

x@node-0:~$ sudo sysctl net.ipv4.conf.all.accept_redirects=0
net.ipv4.conf.all.accept_redirects = 0
x@node-0:~$ sudo sysctl net.ipv4.conf.ens32.accept_redirects=0
net.ipv4.conf.ens32.accept_redirects = 0

x@node-0:~$ ip r
default via 192.168.91.2 dev ens32 
192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128 
x@node-0:~$ sudo ip r del default 
x@node-0:~$ sudo ip r add default via 192.168.91.137 dev ens32 
x@node-0:~$ ip r
default via 192.168.91.137 dev ens32 
192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128 
----
