= WebSocket and Server-sent events
:page-layout: post
:page-categories: ['networking']
:page-tags: ['networking', 'http', 'websocket']
:page-date: 2024-05-15 15:00:40 +0800
:page-revdate: 2024-05-15 15:00:40 +0800
:toc:
:toclevels: 4
:sectnums:
:sectnumlevels: 4

== WebSocket protocol

:rfc6455: https://www.rfc-editor.org/rfc/rfc6455

https://en.wikipedia.org/wiki/WebSocket[WebSocket], standardized by the IETF as {rfc6455}[RFC 6455] in 2011, is a computer communications protocol, providing a simultaneous two-way communication channel over a single Transmission Control Protocol (TCP) connection. <<wiki-WebSocket>>

The WebSocket is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries on the existing HTTP infrastructure, and could also use a simpler handshake over a dedicated port without reinventing the entire protocol. <<rfc6455>>

WebSocket, conceptually, is really just a layer on top of TCP that does the following: <<rfc6455>>

* adds a web origin-based security model for browsers

* adds an addressing and protocol naming mechanism to support
      multiple services on one port and multiple host names on one IP
      address

* layers a framing mechanism on top of TCP to get back to the IP
      packet mechanism that TCP is built on, but without length limits

* includes an additional closing handshake in-band that is designed
      to work in the presence of proxies and other intermediaries

The protocol has two parts: a handshake and the data transfer. After a successful handshake, clients and servers transfer _messages_ back and forth. <<rfc6455>>

* On the wire, a message is composed of one or more _fragmented_ frames.

* A frame has an associated type and broadly speaking, there are types for _textual data_, _binary data_, and _control frames_.

WebSocket specification defines two URI schemes: <<rfc6455>>

* `ws-URI = "ws:" "//" host [ ":" port ] path [ "?" query ]`

* `wss-URI = "wss:" "//" host [ ":" port ] path [ "?" query ]`

:MDN-Upgrade: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade
:rfc7230: https://www.rfc-editor.org/rfc/rfc7230
The protocol uses the HTTP/1.1 {MDN-Upgrade}[Upgrade] mechanism (Section 6.7 of {RFC7230}#section-6.7[RFC7230]) to transition a TCP connection from HTTP into a WebSocket connection, and uses the extended CONNECT method to initiate a WebSocket connection on an HTTP/2 stream. <<rfc8441>>

=== Date framing

A high-level overview of the framing is given in the following figure. <<rfc6455>>

```txt
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+

FIN:  1 bit

   Indicates that this is the final fragment in a message.  The first
   fragment MAY also be the final fragment.

Opcode:  4 bits

   Defines the interpretation of the "Payload data".  If an unknown
   opcode is received, the receiving endpoint MUST _Fail the
   WebSocket Connection_.  The following values are defined.

   *  %x0 denotes a continuation frame

   *  %x1 denotes a text frame

   *  %x2 denotes a binary frame

   *  %x3-7 are reserved for further non-control frames

   *  %x8 denotes a connection close

   *  %x9 denotes a ping

   *  %xA denotes a pong

   *  %xB-F are reserved for further control frames
```

* _Control frames_ are identified by opcodes where the most significant bit of the opcode is `1`.

** Currently defined opcodes for control frames include `0x8` (Close), `0x9` (Ping), and `0xA` (Pong).

** Control frames are used to communicate state about the WebSocket.

* _Data frames_ (e.g., non-control frames) are identified by opcodes where the most significant bit of the opcode is `0`.

** Currently defined opcodes for data frames include `0x1` (Text), `0x2` (Binary).

** Data frames carry application-layer and/or extension-layer data.

=== Opening handshake in HTTP/1.1

The opening handshake is intended to be compatible with HTTP-based server-side software and intermediaries, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. <<rfc6455>>

* The WebSocket client's handshake is an HTTP Upgrade request with the Request-Line <<rfc2616>> format: <<rfc6455>>
+
```txt
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat <1>
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== <2>
Sec-WebSocket-Version: 13
```
+
--
<1> The `Sec-WebSocket-Protocol` request-header field can be used to indicate what subprotocols (application-level protocols layered over the WebSocket Protocol) are acceptable to the client.

<2> The server takes the `Sec-WebSocket-Key` header field and echo the `Sec-WebSocket-Accept` header field to prove the received handshake.
--

* The handshake from the server is much simpler than the client handshake, and looks as follows with the Status-Line <<rfc2616>> format:
+
```txt
HTTP/1.1 101 Switching Protocols <1>
Upgrade: websocket <2>
Connection: Upgrade <2>
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= <3>
Sec-WebSocket-Protocol: chat <4>
```
+
--
<1> Any status code other than 101 indicates that the WebSocket handshake has not completed and that the semantics of HTTP still apply. 

<2> The `Connection` and `Upgrade` header fields complete the HTTP Upgrade.

<3> The `Sec-WebSocket-Accept` header field indicates whether the server is willing to accept the connection.  
<4> The `Sec-WebSocket-Protocol` is an option field, which indicates the subprotocol that the server has selected.
--

Either peer can send a _control frame_ with data containing a specified control sequence to begin the closing handshake.

=== WebSocket vs. HTTP Protocol [Gemini]

While WebSockets leverage the initial HTTP connection for the handshake, proxy servers do typically handle WebSocket traffic and normal HTTP traffic distinctly.

*WebSocket vs. HTTP Protocol Differences:*

* *Purpose*: HTTP is designed for request-response interactions, while WebSocket establishes a full-duplex communication channel for real-time data exchange.

* *Data Format*: HTTP uses a text-based request-response format with headers and payloads. WebSocket uses a binary frame format for efficient data transfer.

* *Connection State*: HTTP connections are typically short-lived, closing after the response is sent. WebSockets maintain persistent connections for bi-directional communication.

*Proxy Handling:*

* *Initial Handshake*: For both HTTP and WebSocket traffic, the proxy first establishes a standard HTTP connection with the target server.

* *Handshake Differentiation*: The proxy can identify WebSocket traffic by recognizing the specific handshake headers used in the initial HTTP request.

* *Separate Handling*: Once a WebSocket handshake is detected, the proxy switches to handling the subsequent frames using the WebSocket protocol. It might involve unmasking/remasking data and forwarding it appropriately.

* *HTTP Traffic Handling*: Normal HTTP requests and responses continue to be handled using the standard HTTP protocol by the proxy.


*Benefits of Separate Handling:*

* *Performance*: By handling WebSocket traffic differently, the proxy can optimize processing for the specific needs of each protocol. This can improve performance for both WebSocket and HTTP traffic.

* *Security*: Some proxies might have specific security mechanisms tailored for HTTP traffic (e.g., content filtering). These wouldn't be applicable to the binary data format of WebSockets. Separate handling allows for targeted security measures.

* *Complexity Management*: Separating the handling logic simplifies the proxy implementation as it deals with each protocol according to its unique characteristics.

*In summary:*

* A single proxy server can manage both HTTP and WebSocket traffic.
* However, it differentiates between the two protocols during the initial handshake and then employs separate handling mechanisms for each to ensure optimal performance and proper data flow.

=== WebSockets in .NET

WebSocket (RFC 6455) is a protocol that enables two-way persistent communication channels over TCP connections. It's used in apps that benefit from fast, real-time communication, such as chat, dashboard, and game apps. <<aspnet-websockets>>

Using WebSockets over HTTP/2 takes advantage of new features such as:

* Header compression.

* Multiplexing, which reduces the time and resources needed when making multiple requests to the server.

These supported features are available in Kestrel on all HTTP/2 enabled platforms. The version negotiation is automatic in browsers and Kestrel, so no new APIs are needed.

NOTE: HTTP/2 WebSockets use `CONNECT` requests rather than `GET`.

WebSockets were originally designed for HTTP/1.1 but have since been adapted to work over HTTP/2. (https://www.rfc-editor.org/rfc/rfc8441[RFC 8441])

* Add the WebSockets middleware in `Program.cs`:
+
```cs
var webSocketOptions = new WebSocketOptions
{
    KeepAliveInterval = TimeSpan.FromMinutes(2)
};

webSocketOptions.AllowedOrigins.Add("https://client.com");
webSocketOptions.AllowedOrigins.Add("https://www.client.com");

app.UseWebSockets(webSocketOptions);
```

* Accept WebSocket requests
+
```cs
app.Use(async (context, next) =>
{
    if (context.Request.Path == "/ws")
    {
        if (context.WebSockets.IsWebSocketRequest)
        {
            using var webSocket = await context.WebSockets.AcceptWebSocketAsync();
            await Echo(webSocket);
        }
        else
        {
            context.Response.StatusCode = StatusCodes.Status400BadRequest;
        }
    }
    else
    {
        await next(context);
    }

});
```
+
A similar approach can be taken in a controller method:
+
```cs
public class WebSocketController : ControllerBase
{
    [Route("/ws")] // HTTP/2 WebSockets use CONNECT requests rather than GET. 
    public async Task Get()
    {
        if (HttpContext.WebSockets.IsWebSocketRequest)
        {
            using var webSocket = await HttpContext.WebSockets.AcceptWebSocketAsync();
            await Echo(webSocket);
        }
        else
        {
            HttpContext.Response.StatusCode = StatusCodes.Status400BadRequest;
        }
    }
```

* Send and receive messages
+
```cs
private static async Task Echo(WebSocket webSocket)
{
    var buffer = new byte[1024 * 4];
    var receiveResult = await webSocket.ReceiveAsync(
        new ArraySegment<byte>(buffer), CancellationToken.None);

    while (!receiveResult.CloseStatus.HasValue)
    {
        await webSocket.SendAsync(
            new ArraySegment<byte>(buffer, 0, receiveResult.Count),
            receiveResult.MessageType,
            receiveResult.EndOfMessage,
            CancellationToken.None);

        receiveResult = await webSocket.ReceiveAsync(
            new ArraySegment<byte>(buffer), CancellationToken.None);
    }

    await webSocket.CloseAsync(
        receiveResult.CloseStatus.Value,
        receiveResult.CloseStatusDescription,
        CancellationToken.None);
}
```

[bibliography]
== References

* [[[wiki-WebSocket,1]]] https://en.wikipedia.org/wiki/WebSocket
* [[[rfc6455,2]]] https://www.rfc-editor.org/rfc/rfc6455
* [[[rfc8441,3]]] https://www.rfc-editor.org/rfc/rfc8441
* [[[rfc2616,4]]] https://www.rfc-editor.org/rfc/rfc2616
* [[[aspnet-websockets,4]]] https://learn.microsoft.com/en-us/aspnet/core/fundamentals/websockets
* [[[dotnet-websockets,5]]] https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/websockets
