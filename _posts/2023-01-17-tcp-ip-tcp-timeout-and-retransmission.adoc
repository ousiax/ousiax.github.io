= TCP/IP: TCP Timeout and Retransmission
:page-layout: post
:page-categories: ['networking']
:page-tags: ['networking', 'tcp']
:page-date: 2023-01-17 14:45:16 +0800
:page-revdate: 2023-01-17 14:45:16 +0800
:toc: preamble
:toclevels: 4
:sectnums:
:sectnumlevels: 4

To decide what data it needs to resend, TCP depends on a continuous flow of acknowledgments from receiver to sender.

When data segments or acknowledgments are lost, TCP initiates a *retransmission* of the data that has not been acknowledged.

TCP has two separate mechanisms for accomplishing retransmission, one based on time and one based on the structure of the acknowledgments.

* TCP sets a timer when it sends data, and if the data is not acknowledged when the timer expires, a *_timeout_* or *_timer-based retransmission_* of data occurs. The timeout occurs after an interval called the *_retransmission timeout_* (RTO).

* It has another way of initiating a retransmission called *_fast retransmission_* or *_fast retransmit_*, which usually happens without any delay.
+
Fast retransmit is based on inferring losses by noticing

** when TCP's cumulative acknowledgment fails to advance in the ACKs received over time,
** or when ACKs carrying selective acknowledgment information (SACKs) indicate that out-of-order segments are present at the receiver.

== Simple Timeout and Retransmission (Time-based) Example

We will establish a connection, send some data to verify that everything is OK, isolate one end of the connection, send some more data, and watch what TCP does.

[source,console]
----
x@node-1:~$ nc -kl 6666
----

[source,console]
----
x@node-0:~$ telnet node-1 6666
Trying 192.168.91.135...
Connected to node-1.localdomain.
Escape character is '^]'.
hello
Connection closed by foreign host.
----

[source,console]
----
x@node-1:~$ sudo ip link set ens32 down
----

[source,console]
----
x@node-0:~$ ss -nta dst *:6666
State     Recv-Q     Send-Q            Local Address:Port              Peer Address:Port     Process     
ESTAB     0          7                192.168.91.128:36824           192.168.91.137:6666                 
x@node-0:~$ netstat -nta4
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      7 192.168.91.128:36824    192.168.91.137:6666     ESTABLISHED
----

[source,console]
----
x@node-0:~$ sudo tcpdump -tttttSnv -i any icmp or port 6666
 00:00:00.000000 ens32 Out IP (tos 0x10, ttl 64, id 26731, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [S], cksum 0x3889 (incorrect -> 0xc8d2), seq 1476981540, win 64240, options [mss 1460,sackOK,TS val 3360184417 ecr 0,nop,wscale 7], length 0
 00:00:00.000396 ens32 In  IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.137.6666 > 192.168.91.128.50688: Flags [S.], cksum 0x34e8 (correct), seq 2021627494, ack 1476981541, win 65160, options [mss 1460,sackOK,TS val 1682840845 ecr 3360184417,nop,wscale 7], length 0
 00:00:00.000462 ens32 Out IP (tos 0x10, ttl 64, id 26732, offset 0, flags [DF], proto TCP (6), length 52)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [.], cksum 0x3881 (incorrect -> 0x6046), ack 2021627495, win 502, options [nop,nop,TS val 3360184418 ecr 1682840845], length 0
 00:00:33.520679 ens32 Out IP (tos 0x10, ttl 64, id 26733, offset 0, flags [DF], proto TCP (6), length 59)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [P.], cksum 0x3888 (incorrect -> 0x8f67), seq 1476981541:1476981548, ack 2021627495, win 502, options [nop,nop,TS val 3360217938 ecr 1682840845], length 7
...
 00:00:40.385007 ens32 Out IP (tos 0x10, ttl 64, id 26739, offset 0, flags [DF], proto TCP (6), length 59)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [P.], cksum 0x3888 (incorrect -> 0x7497), seq 1476981541:1476981548, ack 2021627495, win 502, options [nop,nop,TS val 3360224802 ecr 1682840845], length 7
 00:00:50.113908 lo    In  IP (tos 0xd0, ttl 64, id 25299, offset 0, flags [none], proto ICMP (1), length 87)
    192.168.91.128 > 192.168.91.128: ICMP host 192.168.91.137 unreachable, length 67
	IP (tos 0x10, ttl 64, id 26740, offset 0, flags [DF], proto TCP (6), length 59)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [P.], cksum 0x3888 (incorrect -> 0x5a96), seq 1476981541:1476981548, ack 2021627495, win 502, options [nop,nop,TS val 3360231459 ecr 1682840845], length 7
...
 00:15:55.330154 lo    In  IP (tos 0xd0, ttl 64, id 7913, offset 0, flags [none], proto ICMP (1), length 87)
    192.168.91.128 > 192.168.91.128: ICMP host 192.168.91.137 unreachable, length 67
	IP (tos 0x10, ttl 64, id 26876, offset 0, flags [DF], proto TCP (6), length 59)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [P.], cksum 0x3888 (incorrect -> 0x8a89), seq 1476981541:1476981548, ack 2021627495, win 502, options [nop,nop,TS val 3361136674 ecr 1682840845], length 7
----

Logically, TCP has two thresholds to determine how persistently it will attempt to resend the same segment [RFC1122].

* Threshold `R1` indicates the number of tries TCP will make (or the amount of time it will wait) to resend a segment before passing _negative advice_ to the IP layer (e.g., causing it to reevaluate the IP route it is using).

* Threshold `R2` (larger than `R1`) dictates the point at which TCP should abandon the connection.

These thresholds are suggested to be at least three retransmissions and 100s, respectively.

* For connection establishment (sending SYN segments), these values may be different from those for data segments, and the `R2` value for SYN segments is required to be at least 3 minutes.

In Linux, the `R1` and `R2` values for regular data segments are available to be changed by applications or can be changed using the system-wide configuration variables `net.ipv4.tcp_retries1` and `net.ipv4.tcp_retries2`, respectively.

* These are measured in the number of retransmissions, and not in units of time.

* The default value for `net.ipv4.tcp_retries2` is 15, which corresponds roughly to 13–30 minutes, depending on the connection's RTO.

* The default value for `net.ipv4.tcp_retries1` is 3.

* For SYN segments, `net.ipv4.tcp_syn_retries` and `net.ipv4.tcp_synack_retries` bounds the number of retransmissions of SYN segments; their default value is 5 (roughly 180s).

Windows also has a number of variables that affect the overall behavior of TCP, including values for `R1` and `R2`. These are all available by modifying values under the following registry keys [WINREG]:

[source,console]
----
HKLM\System\CurrentControlSet\Services\Tcpip\Parameters
HKLM\System\CurrentControlSet\Services\Tcpip6\Parameters
----

== Setting the Retransmission Timeout (RTO)

Fundamental to TCP's timeout and retransmission procedures is how to set the RTO based upon measurement of the RTT experienced on a given connection.

If TCP retransmits a segment earlier than the RTT, it may be injecting duplicate traffic into the network unnecessarily.

Conversely, if it delays sending until much longer than one RTT, the overall network utilization (and single-connection throughput) drops when traffic is lost.

Knowing the RTT is made more complicated because it can change over time, as routes and network usage vary.

TCP must track these changes and modify its timeout accordingly in order to maintain good performance.

Because TCP sends acknowledgments when it receives data, it is possible to send a byte with a particular sequence number and measure the time required to receive an acknowledgment that covers that sequence number. Each such measurement is called an _RTT_ *_sample_*.

The challenge for TCP is

* to establish a good estimate for the range of RTT values given a set of samples that vary over time.

* The second step is how to set the RTO based on these values.

The RTT is estimated for each TCP connection separately, and one retransmission timer is pending whenever any data is in flight that consumes a sequence number (including SYN and FIN segments).

== Timer-Based Retransmission

Once a sending TCP has established its RTO based upon measurements of the time-varying values of effective RTT, whenever it sends a segment it ensures that a retransmission timer is set appropriately.

* When setting a retransmission timer, the sequence number of the so-called timed segment is recorded, and if an ACK is received in time, the retransmission timer is canceled.

* The next time the sender emits a packet with data in it, a new retransmission timer is set, the old one is canceled, and the new sequence number is recorded.

* The sending TCP therefore continuously sets and cancels one retransmission timer per connection; if no data is ever lost, no retransmission timer ever expires.

When TCP fails to receive an ACK for a segment it has timed on a connection within the RTO, it performs a timer-based retransmission.

TCP considers a timer-based retransmission as a fairly major event; it reacts very cautiously when it happens by quickly reducing the rate at which it sends data into the network. It does this in two ways.

* The first way is to reduce its sending window size based on congestion control procedures.
* The other way is to keep increasing a multiplicative backoff factor applied to the RTO each time a retransmitted segment is again retransmitted.
+
In particular, the RTO value is (temporarily) multiplied by the value `γ` to form the backed-off timeout when multiple retransmissions of the same segment occur:
+
[source,text]
RTO = γRTO
+
--
** In ordinary circumstances, `γ` has the value 1.
+
** On subsequent retransmissions, `γ` is doubled: 2, 4, 8, and so forth.
+
There is typically a maximum backoff factor that `γ` is not allowed to exceed (Linux ensures that the used RTO never exceeds the value `TCP_RTO_MAX`, which defaults to 120s).
+
[source,sh]
----
x@node-0:~$ uname -a; uname -r
Linux node-0 5.10.0-19-amd64 #1 SMP Debian 5.10.149-2 (2022-10-21) x86_64 GNU/Linux
5.10.0-19-amd64
x@node-0:~$ grep "#define HZ" /usr/include/asm-generic/param.h 
#define HZ 100
x@node-0:~$ grep "#define TCP_RTO_" /usr/src/linux-headers-5.10.0-19-common/include/net/tcp.h 
#define TCP_RTO_MAX	((unsigned)(120*HZ))
#define TCP_RTO_MIN	((unsigned)(HZ/5))
----
+
** Once an acceptable ACK is received, `γ` is reset to 1.
--
+
[source,console]
----
x@node-0:~$ while ss -itn dst *:6666; do sleep 1; done
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      0      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:204 rtt:1.86/0.93 cwnd:10
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:204 rtt:1.86/0.93 cwnd:10
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:816 backoff:2 rtt:1.86/0.93 cwnd:1
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:1632 backoff:3 rtt:1.86/0.93 cwnd:1
...
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:6528 backoff:5 rtt:1.86/0.93 cwnd:1
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      0      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:204 rtt:1.752/0.912 cwnd:2
----

== Fast Retransmit

*Fast retransmit* [RFC5681] is a TCP procedure that can induce a packet retransmission based on feedback from the receiver instead of requiring a retransmission timer to expire.

A typical TCP implements both fast retransmit and timer-based retransmission.

TCP generates an immediate acknowledgment (a _duplicate ACK_) when an *_out-of-order segment_* is received, and that the loss of a segment implies out-of-order arrivals at the receiver when subsequent data arrives.

* When this happens, a *_hole_* is created at the receiver.

* The sender's job then becomes filling the receiver's holes as quickly and efficiently as possible.

* The duplicate ACKs sent immediately when out-of-order data arrives are not delayed.
+
The reason is to let the sender know that a segment was received out of order, and to indicate what sequence number is expected (i.e., where the hole is).

* When SACK is used, these duplicate ACKs typically contain SACK blocks as well, which can provide information about more than one hole.

A duplicate ACK (with or without SACK blocks) arriving at a sender is a potential indicator that a packet sent earlier has been lost. It can also appear when there is *_packet reordering_* in the network.

TCP waits for a small number of duplicate ACKs (called the _duplicate ACK threshold_ or _dupthresh_) to be received before concluding that a packet has been lost and initiating a fast retransmit.

Packet loss inferred by the presence of duplicate ACKs is assumed to be related to _network congestion_, and congestion control procedures are invoked along with _fast retransmit_.

Without SACK, no more than one segment is typically retransmitted until an acceptable ACK is received.

With SACK, ACKs contain additional information allowing the sender to fill more than one hole in the receiver per RTT.

[source,console,highlight="14"]
----
x@node-1:~$ ip a show ens32 
2: ens32: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:85:26:07 brd ff:ff:ff:ff:ff:ff
    inet 192.168.91.137/24 brd 192.168.91.255 scope global ens32
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe85:2607/64 scope link 
       valid_lft forever preferred_lft forever
x@node-1:~$ sudo sysctl net.ipv4.ip_forward=1
net.ipv4.ip_forward = 1
x@node-1:~$ sudo sysctl net.ipv4.conf.all.send_redirects=0
net.ipv4.conf.all.send_redirects = 0
x@node-1:~$ sudo sysctl net.ipv4.conf.ens32.send_redirects=0
net.ipv4.conf.ens32.send_redirects = 0
x@node-1:~$ sudo tc qdisc replace dev ens32 root netem loss 50%
x@node-1:~$ sudo tc qdisc show dev ens32 
qdisc netem 8001: root refcnt 2 limit 1000 loss 50%
----

[source,console]
----
x@node-0:~$ sudo ip r replace default via 192.168.91.137
x@node-0:~$ ip r
default via 192.168.91.137 dev ens32 
192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128 
----

[source,console,highlight="7"]
----
x@node-0:~$ ping -c 4 windows.home 
PING windows.home (10.170.109.10) 56(84) bytes of data.
64 bytes from http-proxy (10.170.109.10): icmp_seq=1 ttl=128 time=5.61 ms
64 bytes from http-proxy (10.170.109.10): icmp_seq=2 ttl=128 time=1.28 ms

--- windows.home ping statistics ---
4 packets transmitted, 2 received, 50% packet loss, time 3021ms
rtt min/avg/max/mdev = 1.275/3.441/5.608/2.166 ms
x@node-0:~$ telnet windows.home 6666
Trying 10.170.109.10...
Connected to windows.home.
Escape character is '^]'.
HELLO
^]
telnet> q
Connection closed.
----

[source,console,highlight="3-6,9-15,17,20,24"]
----
x@node-0:~$ sudo tcpdump -tttttSn port 6666
 00:00:00.000000 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [S], seq 1089778284, win 64240, options [mss 1460,sackOK,TS val 1131499270 ecr 0,nop,wscale 7], length 0
 00:00:01.030663 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [S], seq 1089778284, win 64240, options [mss 1460,sackOK,TS val 1131500300 ecr 0,nop,wscale 7], length 0
 00:00:03.045839 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [S], seq 1089778284, win 64240, options [mss 1460,sackOK,TS val 1131502315 ecr 0,nop,wscale 7], length 0
 00:00:07.237567 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [S], seq 1089778284, win 64240, options [mss 1460,sackOK,TS val 1131506507 ecr 0,nop,wscale 7], length 0
 00:00:07.238040 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [S], seq 1089778284, win 64240, options [mss 1460,sackOK,TS val 1131506507 ecr 0,nop,wscale 7], length 0
 00:00:07.238577 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [S.], seq 462033365, ack 1089778285, win 64240, options [mss 1460], length 0
 00:00:07.238627 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [.], ack 462033366, win 64240, length 0
 00:00:07.343502 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [S.], seq 462033365, ack 1089778285, win 64240, options [mss 1460], length 0
 00:00:07.343531 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [.], ack 462033366, win 64240, length 0
 00:00:07.454848 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [S.], seq 462033365, ack 1089778285, win 64240, options [mss 1460], length 0
 00:00:07.562429 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [S.], seq 462033365, ack 1089778285, win 64240, options [mss 1460], length 0
 00:00:08.573351 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [S.], seq 462033365, ack 1089778285, win 64240, options [mss 1460], length 0
 00:00:08.573365 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [.], ack 462033366, win 64240, length 0
 00:00:08.573829 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [.], ack 462033366, win 64240, length 0
 00:00:13.085400 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [P.], seq 1089778285:1089778292, ack 462033366, win 64240, length 7
 00:00:13.087022 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [P.], seq 1089778285:1089778292, ack 462033366, win 64240, length 7
 00:00:13.087029 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [.], ack 1089778292, win 64240, length 0
 00:00:27.525036 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [F.], seq 1089778292, ack 462033366, win 64240, length 0
 00:00:27.525294 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [F.], seq 1089778292, ack 462033366, win 64240, length 0
 00:00:27.525532 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [.], ack 1089778293, win 64239, length 0
 00:00:27.525533 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [FP.], seq 462033366, ack 1089778293, win 64239, length 0
 00:00:27.525570 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [.], ack 462033367, win 64240, length 0
 00:00:27.526226 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [.], ack 462033367, win 64240, length 0
----

image::/assets/tcp-ip/tcp-timeout-and-retransmission/fast-retransmit-wireshark.png[,100%,100%]

[bibliography]
== References

* [[[tcp_ip_vol_1,1]]] Kevin Fall, W. Stevens, TCP/IP Illustrated: The Protocols, Volume 1 (Addison-Wesley Professional Computing Series) 2nd Edition
* [[[netem,2]]] https://wiki.linuxfoundation.org/networking/netem
* [[[emulating-bad-networks,3]]] https://samwho.dev/blog/emulating-bad-networks/
