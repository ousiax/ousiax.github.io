= TCP/IP: TCP Timeout and Retransmission
:page-layout: post
:page-categories: ['networking']
:page-tags: ['networking', 'tcp']
:page-date: 2023-01-17 14:45:16 +0800
:page-revdate: 2023-01-17 14:45:16 +0800
:toc: preamble
:toclevels: 4
:sectnums:
:sectnumlevels: 4

To decide what data it needs to resend, TCP depends on a continuous flow of acknowledgments from receiver to sender.

When data segments or acknowledgments are lost, TCP initiates a *retransmission* of the data that has not been acknowledged.

TCP has two separate mechanisms for accomplishing retransmission, one based on time and one based on the structure of the acknowledgments.

* TCP sets a timer when it sends data, and if the data is not acknowledged when the timer expires, a *_timeout_* or *_timer-based retransmission_* of data occurs. The timeout occurs after an interval called the *_retransmission timeout_* (RTO).

* It has another way of initiating a retransmission called *_fast retransmission_* or *_fast retransmit_*, which usually happens without any delay.
+
Fast retransmit is based on inferring losses by noticing

** when TCP's cumulative acknowledgment fails to advance in the ACKs received over time,
** or when ACKs carrying selective acknowledgment information (SACKs) indicate that out-of-order segments are present at the receiver.

== Simple Timeout and Retransmission (Time-based) Example

We will establish a connection, send some data to verify that everything is OK, isolate one end of the connection, send some more data, and watch what TCP does.

[source,console]
----
x@node-1:~$ nc -kl 6666
----

[source,console]
----
x@node-0:~$ telnet node-1 6666
Trying 192.168.91.135...
Connected to node-1.localdomain.
Escape character is '^]'.
hello
Connection closed by foreign host.
----

[source,console]
----
x@node-1:~$ sudo ip link set ens32 down
----

[source,console]
----
x@node-0:~$ ss -nta dst *:6666
State     Recv-Q     Send-Q            Local Address:Port              Peer Address:Port     Process     
ESTAB     0          7                192.168.91.128:36824           192.168.91.137:6666                 
x@node-0:~$ netstat -nta4
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      7 192.168.91.128:36824    192.168.91.137:6666     ESTABLISHED
----

[source,console]
----
x@node-0:~$ sudo tcpdump -tttttSnv -i any icmp or port 6666
 00:00:00.000000 ens32 Out IP (tos 0x10, ttl 64, id 26731, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [S], cksum 0x3889 (incorrect -> 0xc8d2), seq 1476981540, win 64240, options [mss 1460,sackOK,TS val 3360184417 ecr 0,nop,wscale 7], length 0
 00:00:00.000396 ens32 In  IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.137.6666 > 192.168.91.128.50688: Flags [S.], cksum 0x34e8 (correct), seq 2021627494, ack 1476981541, win 65160, options [mss 1460,sackOK,TS val 1682840845 ecr 3360184417,nop,wscale 7], length 0
 00:00:00.000462 ens32 Out IP (tos 0x10, ttl 64, id 26732, offset 0, flags [DF], proto TCP (6), length 52)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [.], cksum 0x3881 (incorrect -> 0x6046), ack 2021627495, win 502, options [nop,nop,TS val 3360184418 ecr 1682840845], length 0
 00:00:33.520679 ens32 Out IP (tos 0x10, ttl 64, id 26733, offset 0, flags [DF], proto TCP (6), length 59)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [P.], cksum 0x3888 (incorrect -> 0x8f67), seq 1476981541:1476981548, ack 2021627495, win 502, options [nop,nop,TS val 3360217938 ecr 1682840845], length 7
...
 00:00:40.385007 ens32 Out IP (tos 0x10, ttl 64, id 26739, offset 0, flags [DF], proto TCP (6), length 59)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [P.], cksum 0x3888 (incorrect -> 0x7497), seq 1476981541:1476981548, ack 2021627495, win 502, options [nop,nop,TS val 3360224802 ecr 1682840845], length 7
 00:00:50.113908 lo    In  IP (tos 0xd0, ttl 64, id 25299, offset 0, flags [none], proto ICMP (1), length 87)
    192.168.91.128 > 192.168.91.128: ICMP host 192.168.91.137 unreachable, length 67
	IP (tos 0x10, ttl 64, id 26740, offset 0, flags [DF], proto TCP (6), length 59)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [P.], cksum 0x3888 (incorrect -> 0x5a96), seq 1476981541:1476981548, ack 2021627495, win 502, options [nop,nop,TS val 3360231459 ecr 1682840845], length 7
...
 00:15:55.330154 lo    In  IP (tos 0xd0, ttl 64, id 7913, offset 0, flags [none], proto ICMP (1), length 87)
    192.168.91.128 > 192.168.91.128: ICMP host 192.168.91.137 unreachable, length 67
	IP (tos 0x10, ttl 64, id 26876, offset 0, flags [DF], proto TCP (6), length 59)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [P.], cksum 0x3888 (incorrect -> 0x8a89), seq 1476981541:1476981548, ack 2021627495, win 502, options [nop,nop,TS val 3361136674 ecr 1682840845], length 7
----

Logically, TCP has two thresholds to determine how persistently it will attempt to resend the same segment [RFC1122].

* Threshold `R1` indicates the number of tries TCP will make (or the amount of time it will wait) to resend a segment before passing _negative advice_ to the IP layer (e.g., causing it to reevaluate the IP route it is using).

* Threshold `R2` (larger than `R1`) dictates the point at which TCP should abandon the connection.

These thresholds are suggested to be at least three retransmissions and 100s, respectively.

* For connection establishment (sending SYN segments), these values may be different from those for data segments, and the `R2` value for SYN segments is required to be at least 3 minutes.

In Linux, the `R1` and `R2` values for regular data segments are available to be changed by applications or can be changed using the system-wide configuration variables `net.ipv4.tcp_retries1` and `net.ipv4.tcp_retries2`, respectively.

* These are measured in the number of retransmissions, and not in units of time.

* The default value for `net.ipv4.tcp_retries2` is 15, which corresponds roughly to 13–30 minutes, depending on the connection's RTO.

* The default value for `net.ipv4.tcp_retries1` is 3.

* For SYN segments, `net.ipv4.tcp_syn_retries` and `net.ipv4.tcp_synack_retries` bounds the number of retransmissions of SYN segments; their default value is 5 (roughly 180s).

Windows also has a number of variables that affect the overall behavior of TCP, including values for `R1` and `R2`. These are all available by modifying values under the following registry keys [WINREG]:

[source,console]
----
HKLM\System\CurrentControlSet\Services\Tcpip\Parameters
HKLM\System\CurrentControlSet\Services\Tcpip6\Parameters
----

== Setting the Retransmission Timeout (RTO)

Fundamental to TCP's timeout and retransmission procedures is how to set the RTO based upon measurement of the RTT experienced on a given connection.

If TCP retransmits a segment earlier than the RTT, it may be injecting duplicate traffic into the network unnecessarily.

Conversely, if it delays sending until much longer than one RTT, the overall network utilization (and single-connection throughput) drops when traffic is lost.

Knowing the RTT is made more complicated because it can change over time, as routes and network usage vary.

TCP must track these changes and modify its timeout accordingly in order to maintain good performance.

Because TCP sends acknowledgments when it receives data, it is possible to send a byte with a particular sequence number and measure the time required to receive an acknowledgment that covers that sequence number. Each such measurement is called an _RTT_ *_sample_*.

The challenge for TCP is

* to establish a good estimate for the range of RTT values given a set of samples that vary over time.

* The second step is how to set the RTO based on these values.

The RTT is estimated for each TCP connection separately, and one retransmission timer is pending whenever any data is in flight that consumes a sequence number (including SYN and FIN segments).

== Timer-Based Retransmission

Once a sending TCP has established its RTO based upon measurements of the time-varying values of effective RTT, whenever it sends a segment it ensures that a retransmission timer is set appropriately.

* When setting a retransmission timer, the sequence number of the so-called timed segment is recorded, and if an ACK is received in time, the retransmission timer is canceled.

* The next time the sender emits a packet with data in it, a new retransmission timer is set, the old one is canceled, and the new sequence number is recorded.

* The sending TCP therefore continuously sets and cancels one retransmission timer per connection; if no data is ever lost, no retransmission timer ever expires.

When TCP fails to receive an ACK for a segment it has timed on a connection within the RTO, it performs a timer-based retransmission.

TCP considers a timer-based retransmission as a fairly major event; it reacts very cautiously when it happens by quickly reducing the rate at which it sends data into the network. It does this in two ways.

* The first way is to reduce its sending window size based on congestion control procedures.
* The other way is to keep increasing a multiplicative backoff factor applied to the RTO each time a retransmitted segment is again retransmitted.
+
In particular, the RTO value is (temporarily) multiplied by the value `γ` to form the backed-off timeout when multiple retransmissions of the same segment occur:
+
[source,text]
RTO = γRTO
+
--
** In ordinary circumstances, `γ` has the value 1.
+
** On subsequent retransmissions, `γ` is doubled: 2, 4, 8, and so forth.
+
There is typically a maximum backoff factor that `γ` is not allowed to exceed (Linux ensures that the used RTO never exceeds the value `TCP_RTO_MAX`, which defaults to 120s).
+
[source,sh]
----
x@node-0:~$ uname -a; uname -r
Linux node-0 5.10.0-19-amd64 #1 SMP Debian 5.10.149-2 (2022-10-21) x86_64 GNU/Linux
5.10.0-19-amd64
x@node-0:~$ grep "#define HZ" /usr/include/asm-generic/param.h 
#define HZ 100
x@node-0:~$ grep "#define TCP_RTO_" /usr/src/linux-headers-5.10.0-19-common/include/net/tcp.h 
#define TCP_RTO_MAX	((unsigned)(120*HZ))
#define TCP_RTO_MIN	((unsigned)(HZ/5))
----
+
** Once an acceptable ACK is received, `γ` is reset to 1.
--
+
[source,console]
----
x@node-0:~$ while ss -itn dst *:6666; do sleep 1; done
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      0      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:204 rtt:1.86/0.93 cwnd:10
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:204 rtt:1.86/0.93 cwnd:10
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:816 backoff:2 rtt:1.86/0.93 cwnd:1
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:1632 backoff:3 rtt:1.86/0.93 cwnd:1
...
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:6528 backoff:5 rtt:1.86/0.93 cwnd:1
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      0      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:204 rtt:1.752/0.912 cwnd:2
----

== Fast Retransmit

*Fast retransmit* [RFC5681] is a TCP procedure that can induce a packet retransmission based on feedback from the receiver instead of requiring a retransmission timer to expire.

A typical TCP implements both fast retransmit and timer-based retransmission.

TCP generates an immediate acknowledgment (a _duplicate ACK_) when an *_out-of-order segment_* is received, and that the loss of a segment implies out-of-order arrivals at the receiver when subsequent data arrives.

* When this happens, a *_hole_* is created at the receiver.

* The sender's job then becomes filling the receiver's holes as quickly and efficiently as possible.

* The duplicate ACKs sent immediately when out-of-order data arrives are not delayed.
+
The reason is to let the sender know that a segment was received out of order, and to indicate what sequence number is expected (i.e., where the hole is).

* When SACK is used, these duplicate ACKs typically contain SACK blocks as well, which can provide information about more than one hole.

A duplicate ACK (with or without SACK blocks) arriving at a sender is a potential indicator that a packet sent earlier has been lost. It can also appear when there is *_packet reordering_* in the network.

TCP waits for a small number of duplicate ACKs (called the _duplicate ACK threshold_ or _dupthresh_) to be received before concluding that a packet has been lost and initiating a fast retransmit.

Packet loss inferred by the presence of duplicate ACKs is assumed to be related to _network congestion_, and congestion control procedures are invoked along with _fast retransmit_.

Without SACK, no more than one segment is typically retransmitted until an acceptable ACK is received.

With SACK, ACKs contain additional information allowing the sender to fill more than one hole in the receiver per RTT.

[source,console]
----
x@node-1:~$ sudo sysctl net.ipv4.tcp_sack=0
net.ipv4.tcp_sack = 0
x@node-1:~$ sudo iptables -A INPUT -p tcp --dport 6666 -m statistic --mode nth --every 2 --packet 0 -j DROP
x@node-1:~$ sudo iptables -L INPUT
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
DROP       tcp  --  anywhere             anywhere             tcp dpt:6666 statistic mode nth every 2
----

[source,console]
----
x@node-0:~$ sudo ethtool -K ens32 tx on tso off
Actual changes:
tx-checksum-ipv4: off [requested on]
tx-checksum-ipv6: off [requested on]
tx-tcp-segmentation: off
tx-checksum-fcoe-crc: off [requested on]
tx-checksum-sctp: off [requested on]
x@node-0:~$ sudo sysctl net.ipv4.tcp_sack=0
net.ipv4.tcp_sack = 0
x@node-0:~$ head -c 10000 /dev/random | nc -v node-1 6666
Ncat: Version 7.80 ( https://nmap.org/ncat )
Ncat: Connected to 192.168.91.137:6666.
Ncat: 10000 bytes sent, 0 bytes received in 2.50 seconds.
----

image::/assets/tcp-ip/tcp-timeout-and-retransmission/fast-retransmit-wireshark.png[,100%,100%]

* The packets 23 and 28 are window update ACKs with a duplicate sequence number (because no data is being carried) but contains a change to the TCP flow control window. The window changes from 65,160 bytes to 63,488 bytes. Thus, it is not counted toward the three-duplicate-ACK threshold required to initiate a fast retransmit. Window updates merely provide a copy of the window advertisement.
* The packets 14 and 15 are all duplicate ACKs for sequence number 1449. The arrival of the second of these duplicate ACKs triggers the fast retransmit of segment 1449 by packets 16 and 17.
* The retransmissions from packet 19 to 22 are somewhat different from the first two. When the first two retransmissions takes place, the sending TCP notes the highest sequence number it had sent just before it performed the retransmission (9641 + 360 = 10001). This is called the *recovery point*.
+
TCP is considered to be recovering from loss after a retransmission until it receives an ACK that matches or exceeds the sequence number of the recovery point.
+
In this example, the ACKs at packet 18 are not for 10001, but instead for 5793. This number is larger than the previous highest ACK value seen (1449), but not enough to meet or exceed the recovery point (10001). This type of ACK is called a *partial ACK* for this reason.
+
When partial ACKs arrive, the sending TCP immediately sends the segments that appears to be missing (5793 to 9641 in this case) and continues this way until the recovery point is matched or exceeded by an arriving ACK.
+
If permitted by congestion control procedures, it may also send new data it has not yet sent.
* Because no SACKs are being used, the sender can learn of at most one receiver hole per round-trip time, indicated by the increase in the ACK number of returning packets, which can only occur once a retransmission filling the receiver’s lowest-numbered hole has been received and ACKed.

[source,console,linenums]
----
 00:00:00.000000 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [S], seq 2395807434, win 64240, options [mss 1460,nop,nop,TS val 3245551521 ecr 0,nop,wscale 7], length 0
 00:00:01.013807 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [S], seq 2395807434, win 64240, options [mss 1460,nop,nop,TS val 3245552536 ecr 0,nop,wscale 7], length 0
 00:00:01.014094 IP 192.168.91.137.6666 > 192.168.91.128.58368: Flags [S.], seq 3105090969, ack 2395807435, win 65160, options [mss 1460,nop,nop,TS val 939993754 ecr 3245552536,nop,wscale 7], length 0
 00:00:01.014138 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [.], ack 1, win 502, options [nop,nop,TS val 3245552536 ecr 939993754], length 0
 00:00:01.014253 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [.], seq 1:1449, ack 1, win 502, options [nop,nop,TS val 3245552536 ecr 939993754], length 1448
 00:00:01.014303 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [P.], seq 1449:2897, ack 1, win 502, options [nop,nop,TS val 3245552536 ecr 939993754], length 1448
 00:00:01.014329 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [.], seq 2897:4345, ack 1, win 502, options [nop,nop,TS val 3245552536 ecr 939993754], length 1448
 00:00:01.014330 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [P.], seq 4345:5793, ack 1, win 502, options [nop,nop,TS val 3245552536 ecr 939993754], length 1448
 00:00:01.014331 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [.], seq 5793:7241, ack 1, win 502, options [nop,nop,TS val 3245552536 ecr 939993754], length 1448
 00:00:01.014367 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [P.], seq 7241:8193, ack 1, win 502, options [nop,nop,TS val 3245552536 ecr 939993754], length 952
 00:00:01.014392 IP 192.168.91.137.6666 > 192.168.91.128.58368: Flags [.], ack 1449, win 501, options [nop,nop,TS val 939993754 ecr 3245552536], length 0
 00:00:01.014401 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [.], seq 8193:9641, ack 1, win 502, options [nop,nop,TS val 3245552536 ecr 939993754], length 1448
 00:00:01.014419 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [FP.], seq 9641:10001, ack 1, win 502, options [nop,nop,TS val 3245552536 ecr 939993754], length 360
 00:00:01.014498 IP 192.168.91.137.6666 > 192.168.91.128.58368: Flags [.], ack 1449, win 501, options [nop,nop,TS val 939993754 ecr 3245552536], length 0
 00:00:01.014498 IP 192.168.91.137.6666 > 192.168.91.128.58368: Flags [.], ack 1449, win 501, options [nop,nop,TS val 939993754 ecr 3245552536], length 0
 00:00:01.221646 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [.], seq 1449:2897, ack 1, win 502, options [nop,nop,TS val 3245552743 ecr 939993754], length 1448
 00:00:01.653752 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [.], seq 1449:2897, ack 1, win 502, options [nop,nop,TS val 3245553175 ecr 939993754], length 1448
 00:00:01.654191 IP 192.168.91.137.6666 > 192.168.91.128.58368: Flags [.], ack 5793, win 473, options [nop,nop,TS val 939994394 ecr 3245553175], length 0
 00:00:01.654217 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [.], seq 5793:7241, ack 1, win 502, options [nop,nop,TS val 3245553176 ecr 939994394], length 1448
 00:00:01.654221 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [P.], seq 7241:8193, ack 1, win 502, options [nop,nop,TS val 3245553176 ecr 939994394], length 952
 00:00:01.654278 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [.], seq 8193:9641, ack 1, win 502, options [nop,nop,TS val 3245553176 ecr 939994394], length 1448
 00:00:01.654303 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [FP.], seq 9641:10001, ack 1, win 502, options [nop,nop,TS val 3245553176 ecr 939994394], length 360
 00:00:01.654539 IP 192.168.91.137.6666 > 192.168.91.128.58368: Flags [.], ack 5793, win 496, options [nop,nop,TS val 939994394 ecr 3245553175], length 0
 00:00:01.862139 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [.], seq 5793:7241, ack 1, win 502, options [nop,nop,TS val 3245553384 ecr 939994394], length 1448
 00:00:01.862428 IP 192.168.91.137.6666 > 192.168.91.128.58368: Flags [.], ack 7241, win 488, options [nop,nop,TS val 939994602 ecr 3245553384], length 0
 00:00:01.862444 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [P.], seq 7241:8193, ack 1, win 502, options [nop,nop,TS val 3245553384 ecr 939994602], length 952
 00:00:01.862475 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [.], seq 8193:9641, ack 1, win 502, options [nop,nop,TS val 3245553384 ecr 939994602], length 1448
 00:00:01.862675 IP 192.168.91.137.6666 > 192.168.91.128.58368: Flags [.], ack 7241, win 496, options [nop,nop,TS val 939994602 ecr 3245553384], length 0
 00:00:02.070061 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [P.], seq 7241:8193, ack 1, win 502, options [nop,nop,TS val 3245553592 ecr 939994602], length 952
 00:00:02.486074 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [P.], seq 7241:8193, ack 1, win 502, options [nop,nop,TS val 3245554008 ecr 939994602], length 952
 00:00:02.486555 IP 192.168.91.137.6666 > 192.168.91.128.58368: Flags [.], ack 10002, win 489, options [nop,nop,TS val 939995226 ecr 3245554008], length 0
 00:00:02.486557 IP 192.168.91.137.6666 > 192.168.91.128.58368: Flags [F.], seq 1, ack 10002, win 501, options [nop,nop,TS val 939995226 ecr 3245554008], length 0
 00:00:02.486636 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [.], ack 2, win 502, options [nop,nop,TS val 3245554008 ecr 939995226], length 0
 00:00:02.717525 IP 192.168.91.137.6666 > 192.168.91.128.58368: Flags [F.], seq 1, ack 10002, win 501, options [nop,nop,TS val 939995457 ecr 3245554008], length 0
 00:00:02.717540 IP 192.168.91.128.58368 > 192.168.91.137.6666: Flags [.], ack 2, win 502, options [nop,nop,TS val 3245554239 ecr 939995226], length 0
----

== Retransmission with Selective Acknowledgments

With the standardization of the Selective Acknowledgment options in [RFC2018], a SACK-capable TCP receiver is able to describe data it has received with sequence numbers beyond the cumulative _ACK Number_ field it sends in the primary portion of the TCP header.

* The gaps between the ACK number and other in-window data cached at the receiver are called *holes*.

* Data with sequence numbers beyond the holes are called *out-of-sequence* data because that data is not contiguous, in terms of its sequence numbers, with the other data the receiver has already received.

The job of a sending TCP is to fill the holes in the receiver by retransmitting any data the receiver is missing, yet to be as efficient as possible by not resending data the receiver already has.

In many circumstances, the properly operating SACK sender is able to fill these holes more quickly and with fewer unnecessary retransmissions than a comparable non-SACK sender because it does not have to wait an entire RTT to learn about additional holes.

When the SACK option is being used, an ACK can be augmented with up to three or four SACK blocks that contain information about out-of-sequence data at the receiver.

* Each *SACK block* contains two 32-bit sequence numbers representing the first and last sequence numbers (plus 1) of a continuous block of out-of-sequence data being held at the receiver.

* A SACK option that specifies _n_ blocks has a length of 8n + 2 bytes (8n bytes for the sequence numbers and 2 to indicate the option kind and length), so the 40 bytes available to hold TCP options can specify a maximum of four blocks.

* It is expected that SACK will often be used in conjunction with the TSOPT, which takes an additional 10 bytes (plus 2 bytes of padding), meaning that SACK is typically able to include only three blocks per ACK.

* With three distinct blocks, up to three holes can be reported to the sender.

* If not limited by congestion control, all three could be filled within one round-trip time using a SACK-capable sender.

* An ACK packet containing one or more SACK blocks is sometimes called simply a *SACK*.

[source,console]
----
=> [.], seq 1:1449, ack 1, [TS val 3251433112 ecr 945874299], length 1448
=> [P.], seq 1449:2897, ack 1, [TS val 3251433112 ecr 945874299], length 1448
=> [.], seq 2897:4345, ack 1, [TS val 3251433112 ecr 945874299], length 1448
=> [P.], seq 4345:5793, ack 1, [TS val 3251433112 ecr 945874299], length 1448
=> [.], seq 5793:7241, ack 1, [TS val 3251433112 ecr 945874299], length 1448
=> [P.], seq 7241:8193, ack 1, [TS val 3251433112 ecr 945874299], length 952
<= [.], ack 1449, [TS val 945874300 ecr 3251433112], length 0
=> [.], seq 8193:9641, ack 1, [TS val 3251433113 ecr 945874300], length 1448
=> [FP.], seq 9641:10001, ack 1, [TS val 3251433113 ecr 945874300], length 360

<= [.], ack 1449, [TS val 945874300 ecr 3251433112,sack 1 {2897:5793}], length 0
<= [.], ack 1449, [TS val 945874300 ecr 3251433112,sack 2 {8193:10002}{2897:5793}], length 0

=> [.], seq 1449:2897, ack 1, [TS val 3251433113 ecr 945874300], length 1448
=> [.], seq 5793:7241, ack 1, [TS val 3251433113 ecr 945874300], length 1448
----

=== SACK Receiver Behavior

A SACK-capable receiver is allowed to generate SACKs if it has received the SACK-Permitted option during the TCP connection establishment.

[source,console]
----
// The SACK-Permitted option is exchanged in SYN segments to indicate the capability to generate and process SACK information.
// Most modern TCPs support the MSS, Timestamps, Window Scale, and SACK-Permitted options during connection establishment.
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [S], seq 3680115076, win 64240, options [mss 1460,sackOK,TS val 3251433112 ecr 0,nop,wscale 7], length 0
IP 192.168.91.137.6666 > 192.168.91.128.56276: Flags [S.], seq 2651302134, ack 3680115077, win 65160, options [mss 1460,sackOK,TS val 945874299 ecr 3251433112,nop,wscale 7], length 0
----

Generally speaking, a receiver generates SACKs whenever there is any out-of-order data in its buffer. This can happen either:

* because data was _lost_ in transit, or
* because it has been reordered and newer data has arrived at the receiver before older data.

The receiver places in the first SACK block the sequence number range contained in the segment it has _most recently received_.

* Because the space in a SACK option is limited, it is best to ensure that the most recent information is always provided to the sending TCP, if possible.

* Other SACK blocks are listed in the order in which they appeared as first blocks in previous SACK options.
+
That is, they are filled in by repeating the most recently sent SACK blocks (in other segments) that are not subsets of another block about to be placed in the option being constructed.
+
[source,console]
----
<= [.], ack 1449, [TS val 945874300 ecr 3251433112], length 0
<= [.], ack 1449, [TS val 945874300 ecr 3251433112,sack 1 {2897:5793}], length 0
<= [.], ack 1449, [TS val 945874300 ecr 3251433112,sack 2 {8193:10002}{2897:5793}], length 0
----
+
The purpose of including more than one SACK block in a SACK option and repeating these blocks across multiple SACKs is to provide some redundancy in the case where SACKs are lost.

** If SACKs were never lost, [RFC2018] points out that only one SACK block would be required per SACK for full SACK functionality.

** Unfortunately, SACKs and regular ACKs are sometimes lost and are not retransmitted by TCP unless they contain data (or the _SYN_ or _FIN_ control bit fields are turned on).

=== SACK Sender Behavior

A SACK-capable sender must be used that treats the SACK blocks appropriately and performs *selective retransmission* by sending only those segments missing at the receiver, a process also called *selective repeat*.

The SACK sender keeps track of any cumulative ACK information it receives (like any TCP sender), plus any SACK information it receives.

When a SACK-capable sender has the opportunity to perform a retransmission, usually because it has received a SACK or seen multiple duplicate ACKs, it has the choice of whether it sends new data or retransmits old data.

* The SACK information provides the sequence number ranges present at the receiver, so the sender can infer what segments likely need to be retransmitted to fill the receiver's holes.

* The simplest approach is to have the sender first fill the holes at the receiver and then move on to send more new data [RFC3517] if the congestion control procedures allow. This is the most common approach.

=== Example

To understand how the use of SACK alters the sender and receiver behaviors, we repeat the preceding fast retransmit experiment, but this time the sender and receiver are using SACK.

image::/assets/tcp-ip/tcp-timeout-and-retransmission/fast-retransmit-with-sack-wireshark.png[,100%,100%]

* The SYN packet from the sender, the first packet of the trace, also contains an identical option.
+
These options are present only at connection setup, and thus they only ever appear in segments with the _SYN_ bit field set. Once the connection is permitted to use SACKs, packet loss generally causes the receiver to start producing SACKs.

* The ACK at packet 14 for 1449 contains a SACK block of [2897:5793], indicating a hole at the receiver.
+
The receiver is missing the sequence number range [1449,2896], which corresponds to the single 1448-byte packet starting with sequence number 1449.

* The SACK arriving at packet 15 contains two SACK blocks: [8193:10002] and [2897:5793].
+
Recall that the first SACK blocks from previous SACKs are repeated in later positions in subsequent SACKs for robustness against ACK loss.
+
This SACK is a duplicate ACK for sequence number 1449 and suggests that the receiver now requires the missing segments starting with sequence numbers 1449 and 5793.
// +
// The sender reacts immediately by initiating fast retransmit, but because of congestion control procedures, the sender sends only one retransmission, for segment 1449.
// +
// With the arrival of two additional ACKs, the sender is permitted to send its second retransmission, for segment 5793.

* The SACK sender has not had to wait an RTT to retransmit lost segment 5793 after retransmitting segment 1449.

[source,console,linenums]
----
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [S], seq 3680115076, win 64240, options [mss 1460,sackOK,TS val 3251432089 ecr 0,nop,wscale 7], length 0
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [S], seq 3680115076, win 64240, options [mss 1460,sackOK,TS val 3251433112 ecr 0,nop,wscale 7], length 0
IP 192.168.91.137.6666 > 192.168.91.128.56276: Flags [S.], seq 2651302134, ack 3680115077, win 65160, options [mss 1460,sackOK,TS val 945874299 ecr 3251433112,nop,wscale 7], length 0
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [.], ack 1, win 502, options [nop,nop,TS val 3251433112 ecr 945874299], length 0
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [.], seq 1:1449, ack 1, win 502, options [nop,nop,TS val 3251433112 ecr 945874299], length 1448
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [P.], seq 1449:2897, ack 1, win 502, options [nop,nop,TS val 3251433112 ecr 945874299], length 1448
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [.], seq 2897:4345, ack 1, win 502, options [nop,nop,TS val 3251433112 ecr 945874299], length 1448
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [P.], seq 4345:5793, ack 1, win 502, options [nop,nop,TS val 3251433112 ecr 945874299], length 1448
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [.], seq 5793:7241, ack 1, win 502, options [nop,nop,TS val 3251433112 ecr 945874299], length 1448
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [P.], seq 7241:8193, ack 1, win 502, options [nop,nop,TS val 3251433112 ecr 945874299], length 952
IP 192.168.91.137.6666 > 192.168.91.128.56276: Flags [.], ack 1449, win 501, options [nop,nop,TS val 945874300 ecr 3251433112], length 0
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [.], seq 8193:9641, ack 1, win 502, options [nop,nop,TS val 3251433113 ecr 945874300], length 1448
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [FP.], seq 9641:10001, ack 1, win 502, options [nop,nop,TS val 3251433113 ecr 945874300], length 360
IP 192.168.91.137.6666 > 192.168.91.128.56276: Flags [.], ack 1449, win 501, options [nop,nop,TS val 945874300 ecr 3251433112,nop,nop,sack 1 {2897:5793}], length 0
IP 192.168.91.137.6666 > 192.168.91.128.56276: Flags [.], ack 1449, win 501, options [nop,nop,TS val 945874300 ecr 3251433112,nop,nop,sack 2 {8193:10002}{2897:5793}], length 0
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [.], seq 1449:2897, ack 1, win 502, options [nop,nop,TS val 3251433113 ecr 945874300], length 1448
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [.], seq 5793:7241, ack 1, win 502, options [nop,nop,TS val 3251433113 ecr 945874300], length 1448
IP 192.168.91.137.6666 > 192.168.91.128.56276: Flags [.], ack 1449, win 501, options [nop,nop,TS val 945874301 ecr 3251433112,nop,nop,sack 2 {2897:7241}{8193:10002}], length 0
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [.], seq 1449:2897, ack 1, win 502, options [nop,nop,TS val 3251433113 ecr 945874301], length 1448
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [.], seq 1449:2897, ack 1, win 502, options [nop,nop,TS val 3251433324 ecr 945874301], length 1448
IP 192.168.91.137.6666 > 192.168.91.128.56276: Flags [.], ack 7241, win 465, options [nop,nop,TS val 945874513 ecr 3251433324,nop,nop,sack 1 {8193:10002}], length 0
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [P.], seq 7241:8193, ack 1, win 502, options [nop,nop,TS val 3251433326 ecr 945874513], length 952
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [P.], seq 7241:8193, ack 1, win 502, options [nop,nop,TS val 3251433532 ecr 945874513], length 952
IP 192.168.91.137.6666 > 192.168.91.128.56276: Flags [.], ack 10002, win 489, options [nop,nop,TS val 945874720 ecr 3251433532], length 0
IP 192.168.91.137.6666 > 192.168.91.128.56276: Flags [F.], seq 1, ack 10002, win 501, options [nop,nop,TS val 945874720 ecr 3251433532], length 0
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [.], ack 2, win 502, options [nop,nop,TS val 3251433533 ecr 945874720], length 0
IP 192.168.91.137.6666 > 192.168.91.128.56276: Flags [F.], seq 1, ack 10002, win 501, options [nop,nop,TS val 945874926 ecr 3251433532], length 0
IP 192.168.91.128.56276 > 192.168.91.137.6666: Flags [.], ack 2, win 502, options [nop,nop,TS val 3251433739 ecr 945874720], length 0
----

== Spurious Timeouts and Retransmissions

Under a number of circumstances, TCP may initiate a retransmission even when no data has been lost. Such undesirable retransmissions are called *spurious retransmissions* and are caused by _spurious timeouts_ (timeouts firing too early) and other reasons such as _packet reordering_, _packet duplication_, or _lost ACKs_.

Spurious timeouts can occur when the real RTT has recently increased significantly, beyond the RTO. This happens more frequently in environments where lower-layer protocols have widely varying performance (e.g., wireless).

A number of approaches have been suggested to deal with spurious timeouts. They generally involve a *detection algorithm* and a *response algorithm*.

* The detection algorithm attempts to determine whether a timeout or timer-based retransmission was spurious.

* The response algorithm is invoked once a timeout or retransmission is deemed spurious.
+
Its purpose is to undo or mitigate some action that is otherwise normally performed by TCP when a retransmission timer expires.

.A delay spike occurs after the transmission of packet 8, causing a spurious retransmission timeout and retransmission of packet 5. After retransmission, an ACK for the first copy of 5 arrives. The retransmission for 5 creates a duplicate packet at the receiver, followed by an undesirable "go-back-N" behavior whereby packets 6, 7, and 8 are retransmitted even though they are already present at the receiver.
image::/assets/tcp-ip/tcp-timeout-and-retransmission/suprious-timeout-spike-delay.png[,25%,25%]

=== Duplicate SACK (DSACK) Extension

With a non-SACK TCP, an ACK can indicate only the highest in-sequence segment back to the sender. With SACK, it can signal other (out-of-order) segments as well.

_DSACK_ or _D-SACK_ (stands for _duplicate SACK_ [RFC2883]) is a rule, applied at the SACK receiver and interoperable with conventional SACK senders, that causes _the first SACK block to indicate the sequence numbers of a duplicate segment that has arrived at the receiver_, which is usually to determine when a retransmission was not necessary and to learn additional facts about the network.

The change to the SACK _receiver_ is to allow a SACK block to be included even if it covers sequence numbers below (or equal to) the cumulative _ACK Number_ field.

* It applies equally well in cases where the DSACK information is _above_ the cumulative _ACK Number_ field; this happens for duplicated out-of-order segments.

* DSACK information is included in only a single ACK, and such an ACK is called a *DSACK*.

* DSACK information is not repeated across multiple SACKs as conventional SACK information is.

Exactly what a _sender_ given DSACK information is supposed to do with it is not specified by [RFC2883].

=== The Eifel Detection Algorithm

The experimental _Eifel Detection Algorithm_ [RFC3522] deals with the retransmission ambiguity problem using the TCP TSOPT to detect spurious retransmissions.

* After a retransmission timeout occurs, Eifel awaits the next acceptable ACK.

* If the next acceptable ACK indicates that the first copy of a retransmitted packet (called the _original transmit_) was the cause for the ACK, the retransmission is considered to be spurious.

The Eifel Detection Algorithm is able to detect spurious behavior earlier than the approach using only DSACK because it relies on ACKs generated as a result of packets arriving before loss recovery is initiated. DSACKs, conversely, are able to be sent only after a duplicate segment has arrived at the receiver and able to be acted upon only after the DSACK is returned to the sender. Detecting spurious retransmissions early can offer advantages, because it allows the sender to avoid most of the _go-back-N_ behavior mentioned earlier.

The mechanics of the Eifel Detection Algorithm are simple. It requires the use of the TCP TSOPT.

* When a retransmission is sent (either a timer-based retransmission or a fast retransmit), the TSV value is stored.
* When the first acceptable ACK covering its sequence number is received, the incoming ACK's TSER is examined.
* If it is smaller than the stored value, the ACK corresponds to the original transmission of the packet and not the retransmission, implying that the retransmission must have been spurious.
* This approach is fairly robust to ACK loss as well.
** If an ACK is lost, any subsequent ACKs still have TSER values less than the stored TSV of the retransmitted segment.
** Thus, a retransmission can be deemed spurious as a result of any of the window's worth of ACKs arriving, so a loss of any single ACK is not likely to cause a problem.

The Eifel Detection Algorithm can be combined with DSACKs which can be beneficial when an entire window's worth of ACKs are lost but both the original transmit and retransmission have arrived at the receiver.

* In this particular case, the arriving retransmit causes a DSACK to be generated.
* The Eifel Detection Algorithm would by default conclude that the retransmission is spurious.
* It is thought, however, that if so many ACKs are being lost, allowing TCP to believe the retransmission was not spurious is useful (e.g., to induce it to start sending more slowly—a consequence of the congestion control procedures).
* Thus, arriving DSACKs cause the Eifel Detection Algorithm to conclude that the corresponding retransmission is not spurious.

=== Forward-RTO Recovery (F-RTO)

_Forward-RTO Recovery (F-RTO)_ [RFC5682] is a standard algorithm for detecting spurious retransmissions.

* It does not require any TCP options, so when it is implemented in a sender, it can be used effectively even with an older receiver that does not support the TCP TSOPT.

* It attempts to detect only spurious retransmissions caused by expiration of the retransmission timer; it does not deal with the other causes for spurious retransmissions or duplications mentioned before.

F-RTO makes a modification to the action TCP ordinarily takes after a timer-based retransmission.

* These retransmissions are for the smallest sequence number for which no ACK has yet been received.

* Ordinarily, TCP continues sending additional adjacent packets in order as additional ACKs arrive. This is the _go-back-N_ behavior.

F-RTO modifies the ordinary behavior of TCP by having TCP send new (so far unsent) data after the timeout-based retransmission when the first ACK arrives. It then inspects the second arriving ACK.

* If either of the first two ACKs arriving after the retransmission was sent are duplicate ACKs, the retransmission is deemed OK.

* If they are both acceptable ACKs that advance the sender's window, the retransmission is deemed to have been spurious.

* If the transmission of new data results in the arrival of acceptable ACKs, the arrival of the new data is moving the receiver's window forward.
+
--
** If such data is only causing duplicate ACKs, there must be one or more holes at the receiver.

** In either case, the reception of new data at the receiver does not harm the overall data transfer performance (provided there are sufficient buffers at the receiver).
--

=== The Eifel Response Algorithm

The _Eifel Response Algorithm_ [RFC4015] is a standard set of operations to be executed by a TCP once a retransmission has been deemed spurious.

// Because the response algorithm is logically decoupled from the Eifel Detection Algorithm, it can be used with any of the detection algorithms.
// 
// The Eifel Response Algorithm was originally intended to operate for both timer-based and fast retransmit spurious retransmissions but is currently specified only for timer-based retransmissions.
// 
// Although the Eifel Response Algorithm can be used with any of the detection algorithms, it behaves somewhat differently based on whether a spurious timeout was detected early (e.g., by the Eifel or F-RTO detection algorithms) or later (e.g., by DSACKs). The former cases are called spurious timeouts and operate
// by inspecting ACKs for original transmissions. The latter are called late spurious
// timeouts and are based on ACKs for retransmissions invoked as a result of (spurious)
// timeouts.




[bibliography]
== References

* [[[tcp_ip_vol_1,1]]] Kevin Fall, W. Stevens, TCP/IP Illustrated: The Protocols, Volume 1 (Addison-Wesley Professional Computing Series) 2nd Edition
* [[[netem,2]]] https://wiki.linuxfoundation.org/networking/netem
* [[[iptables,3]]] https://www.netfilter.org/documentation/HOWTO/packet-filtering-HOWTO-7.html
* [[[emulating-bad-networks,4]]] https://samwho.dev/blog/emulating-bad-networks/
* [[[dpltc,5]]] https://sandilands.info/sgordon/dropping-packets-in-ubuntu-linux-using-tc-and-iptables

[appendix]
== Dropping Packets in Linux using tc and iptables

There are two simple ways to randomly drop packets on a Linux computer: using `tc`, the program dedicated for controlling traffic; and using `iptables`, the built-in firewall. <<netem>><<iptables>><<emulating-bad-networks>><<dpltc>>

=== Dropping Packets with tc

*tc* controls the transmit queues of your kernel. Normally when applications on your computer generate data to send, the data is passed to your kernel (via TCP and IP) for transmission on the network interface. The packets are transmitted in a first-in-first-out (FIFO) order.

_tc_ allows you to change the queuing mechanisms (e.g. giving priority to specific type of packets), as well as emulate links by delaying and dropping packets.

Here we will use _tc_ to drop packets. Because _tc_ controls the transmit queues, we use it on a source computer (normally _tc_ doesn't impact on what is received by your computer, but there are exceptions). 

[source,console]
----
x@node-0:~$ sudo tc qdisc replace dev ens32 root netem loss 25%
----

_netem_ is a special type of queuing discipline used for emulating networks. The above command tells the Linux kernel to drop on average 25% of the packets in the transmit queue. You can use different values of loss (e.g. 10%).

When using _tc_ you can show the current queue disciplines using:

[source,console]
----
x@node-0:~$ sudo tc qdisc show dev ens32
qdisc netem 8001: root refcnt 2 limit 1000 loss 25%
----

To show that it works, lets run an PING test. On computer `node-1` (the computer where _tc_ is NOT used) run: 

[source,console]
----
x@node-1:~$ ping node-0 -c 4
PING node-0.localdomain (192.168.91.129) 56(84) bytes of data.
64 bytes from 192.168.91.129 (192.168.91.129): icmp_seq=1 ttl=64 time=0.424 ms
64 bytes from 192.168.91.129 (192.168.91.129): icmp_seq=3 ttl=64 time=3.14 ms
64 bytes from 192.168.91.129 (192.168.91.129): icmp_seq=4 ttl=64 time=0.643 ms

--- node-0.localdomain ping statistics ---
4 packets transmitted, 3 received, 25% packet loss, time 22ms
rtt min/avg/max/mdev = 0.424/1.400/3.135/1.230 ms
----

To delete the above queue discipline use the _delete_ command instead of _replace_: 

[source,console]
----
x@node-0:~$ sudo tc qdisc delete dev ens32 root netem loss 25%
x@node-0:~$ sudo tc qdisc show dev ens32
qdisc pfifo_fast 0: root refcnt 2 bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
----

[IMPORTANT]
====
When loss is used locally (not on a bridge or router), the loss is reported to the upper level protocols. This may cause TCP to resend and behave as if there was no loss. When testing protocol reponse to loss it is best to use a netem on a bridge or router. <<netem>>
====

=== Dropping Packets with iptables

`iptables` allows you to create rules that specify how packets coming into your computer and going out of your computer are treated (and for routers, also forwarded by the router). The rules for packets coming in are in the INPUT chain, packets going out are OUTPUT, and packets forwarded are in the FORWARD chain. We will only use the INPUT chain.

The rules can filter packets based on common packet identifiers (IP addresses, ports, protocol numbers) as well as other matching criteria. We will use a special _statistic_ matching module. For each packet that matches the filter, some action is applied (e.g. DROP the packet, ACCEPT the packet, or some more complex operation).

On computer `node-1` (the destination), to view the current set of rules: 

[source,console]
----
x@node-1:~$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
----

There are no rules in either of the three chains. Note that the default policy (if a packet does not match any rule) is to ACCEPT packets.

Now to add a rule to the INPUT chain to drop 25% of incoming packets on computer `node-1`:

[source,console]
----
x@node-1:~$ sudo iptables -A INPUT -m statistic --mode random --probability 0.25 -j DROP
x@node-1:~$ sudo iptables -L INPUT --line-numbers 
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    DROP       all  --  anywhere             anywhere             statistic mode random probability 0.25000000000
----

To demonstrate the packet dropping, run another PING test on the source `node-0`:

[source,console]
----
x@node-0:~$ ping node-1.local -c 4
PING node-1.local (192.168.91.135) 56(84) bytes of data.
64 bytes from 192.168.91.135 (192.168.91.135): icmp_seq=1 ttl=64 time=0.547 ms
64 bytes from 192.168.91.135 (192.168.91.135): icmp_seq=2 ttl=64 time=1.91 ms
64 bytes from 192.168.91.135 (192.168.91.135): icmp_seq=3 ttl=64 time=0.513 ms

--- node-1.local ping statistics ---
4 packets transmitted, 3 received, 25% packet loss, time 3007ms
rtt min/avg/max/mdev = 0.513/0.988/1.905/0.648 ms
----

Returning to computer `node-1`, to delete a rule you can use the `-D` option:

[source,console]
----
x@node-1:~$ sudo iptables -D INPUT -m statistic --mode random --probability 0.25 -j DROP
x@node-1:~$ sudo iptables -L INPUT
Chain INPUT (policy ACCEPT)
target     prot opt source               destination  
----

(or you can refer to rules by number, e.g. `iptables -D INPUT 1` to delete rule 1 from the INPUT chain). 

Alternatively we can specify to drop every _n_ packets, starting from packet _p_. And we can combine with the standard filtering mechanisms of firewalls to only drop packets belong to a particular source/destination pair or application. 

[source,console]
----
x@node-1:~$ sudo iptables -A INPUT -p udp --dport 6666 -m statistic --mode nth --every 4 --packet 3 -j DROP
----

This rule should drop packet 3, 7, 11, ... for only one of the connections (with destination port 6666). 

Here is the output of an `iperf3` test at the source `node-0`. There are 25% packets dropped by the destination (receiver). 

[source,console]
----
x@node-0:~$ iperf3 -c node-1 -p 6666 -t 10 -u
Connecting to host node-1, port 6666
[  5] local 192.168.91.128 port 52026 connected to 192.168.91.137 port 6666
....
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams
[  5]   0.00-10.00  sec  1.25 MBytes  1.05 Mbits/sec  0.000 ms  0/906 (0%)  sender
[  5]   0.00-10.04  sec   962 KBytes   784 Kbits/sec  0.337 ms  226/906 (25%)  receiver
----
