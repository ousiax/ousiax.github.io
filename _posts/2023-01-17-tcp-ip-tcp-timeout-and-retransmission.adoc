= TCP/IP: TCP Timeout and Retransmission
:page-layout: post
:page-categories: ['networking']
:page-tags: ['networking', 'tcp']
:page-date: 2023-01-17 14:45:16 +0800
:page-revdate: 2023-01-17 14:45:16 +0800
:toc: preamble
:toclevels: 4
:sectnums:
:sectnumlevels: 4

To decide what data it needs to resend, TCP depends on a continuous flow of acknowledgments from receiver to sender.

When data segments or acknowledgments are lost, TCP initiates a *retransmission* of the data that has not been acknowledged.

TCP has two separate mechanisms for accomplishing retransmission, one based on time and one based on the structure of the acknowledgments.

* TCP sets a timer when it sends data, and if the data is not acknowledged when the timer expires, a *_timeout_* or *_timer-based retransmission_* of data occurs. The timeout occurs after an interval called the *_retransmission timeout_* (RTO).

* It has another way of initiating a retransmission called *_fast retransmission_* or *_fast retransmit_*, which usually happens without any delay.
+
Fast retransmit is based on inferring losses by noticing

** when TCP's cumulative acknowledgment fails to advance in the ACKs received over time,
** or when ACKs carrying selective acknowledgment information (SACKs) indicate that out-of-order segments are present at the receiver.

== Simple Timeout and Retransmission (Time-based) Example

We will establish a connection, send some data to verify that everything is OK, isolate one end of the connection, send some more data, and watch what TCP does.

[source,console]
----
x@node-1:~$ nc -kl 6666
----

[source,console]
----
x@node-0:~$ telnet node-1 6666
Trying 192.168.91.135...
Connected to node-1.localdomain.
Escape character is '^]'.
hello
Connection closed by foreign host.
----

[source,console]
----
x@node-1:~$ sudo ip link set ens32 down
----

[source,console]
----
x@node-0:~$ ss -nta dst *:6666
State     Recv-Q     Send-Q            Local Address:Port              Peer Address:Port     Process     
ESTAB     0          7                192.168.91.128:36824           192.168.91.137:6666                 
x@node-0:~$ netstat -nta4
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      7 192.168.91.128:36824    192.168.91.137:6666     ESTABLISHED
----

[source,console]
----
x@node-0:~$ sudo tcpdump -tttttSnv -i any icmp or port 6666
 00:00:00.000000 ens32 Out IP (tos 0x10, ttl 64, id 26731, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [S], cksum 0x3889 (incorrect -> 0xc8d2), seq 1476981540, win 64240, options [mss 1460,sackOK,TS val 3360184417 ecr 0,nop,wscale 7], length 0
 00:00:00.000396 ens32 In  IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.91.137.6666 > 192.168.91.128.50688: Flags [S.], cksum 0x34e8 (correct), seq 2021627494, ack 1476981541, win 65160, options [mss 1460,sackOK,TS val 1682840845 ecr 3360184417,nop,wscale 7], length 0
 00:00:00.000462 ens32 Out IP (tos 0x10, ttl 64, id 26732, offset 0, flags [DF], proto TCP (6), length 52)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [.], cksum 0x3881 (incorrect -> 0x6046), ack 2021627495, win 502, options [nop,nop,TS val 3360184418 ecr 1682840845], length 0
 00:00:33.520679 ens32 Out IP (tos 0x10, ttl 64, id 26733, offset 0, flags [DF], proto TCP (6), length 59)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [P.], cksum 0x3888 (incorrect -> 0x8f67), seq 1476981541:1476981548, ack 2021627495, win 502, options [nop,nop,TS val 3360217938 ecr 1682840845], length 7
...
 00:00:40.385007 ens32 Out IP (tos 0x10, ttl 64, id 26739, offset 0, flags [DF], proto TCP (6), length 59)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [P.], cksum 0x3888 (incorrect -> 0x7497), seq 1476981541:1476981548, ack 2021627495, win 502, options [nop,nop,TS val 3360224802 ecr 1682840845], length 7
 00:00:50.113908 lo    In  IP (tos 0xd0, ttl 64, id 25299, offset 0, flags [none], proto ICMP (1), length 87)
    192.168.91.128 > 192.168.91.128: ICMP host 192.168.91.137 unreachable, length 67
	IP (tos 0x10, ttl 64, id 26740, offset 0, flags [DF], proto TCP (6), length 59)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [P.], cksum 0x3888 (incorrect -> 0x5a96), seq 1476981541:1476981548, ack 2021627495, win 502, options [nop,nop,TS val 3360231459 ecr 1682840845], length 7
...
 00:15:55.330154 lo    In  IP (tos 0xd0, ttl 64, id 7913, offset 0, flags [none], proto ICMP (1), length 87)
    192.168.91.128 > 192.168.91.128: ICMP host 192.168.91.137 unreachable, length 67
	IP (tos 0x10, ttl 64, id 26876, offset 0, flags [DF], proto TCP (6), length 59)
    192.168.91.128.50688 > 192.168.91.137.6666: Flags [P.], cksum 0x3888 (incorrect -> 0x8a89), seq 1476981541:1476981548, ack 2021627495, win 502, options [nop,nop,TS val 3361136674 ecr 1682840845], length 7
----

Logically, TCP has two thresholds to determine how persistently it will attempt to resend the same segment [RFC1122].

* Threshold `R1` indicates the number of tries TCP will make (or the amount of time it will wait) to resend a segment before passing _negative advice_ to the IP layer (e.g., causing it to reevaluate the IP route it is using).

* Threshold `R2` (larger than `R1`) dictates the point at which TCP should abandon the connection.

These thresholds are suggested to be at least three retransmissions and 100s, respectively.

* For connection establishment (sending SYN segments), these values may be different from those for data segments, and the `R2` value for SYN segments is required to be at least 3 minutes.

In Linux, the `R1` and `R2` values for regular data segments are available to be changed by applications or can be changed using the system-wide configuration variables `net.ipv4.tcp_retries1` and `net.ipv4.tcp_retries2`, respectively.

* These are measured in the number of retransmissions, and not in units of time.

* The default value for `net.ipv4.tcp_retries2` is 15, which corresponds roughly to 13–30 minutes, depending on the connection's RTO.

* The default value for `net.ipv4.tcp_retries1` is 3.

* For SYN segments, `net.ipv4.tcp_syn_retries` and `net.ipv4.tcp_synack_retries` bounds the number of retransmissions of SYN segments; their default value is 5 (roughly 180s).

Windows also has a number of variables that affect the overall behavior of TCP, including values for `R1` and `R2`. These are all available by modifying values under the following registry keys [WINREG]:

[source,console]
----
HKLM\System\CurrentControlSet\Services\Tcpip\Parameters
HKLM\System\CurrentControlSet\Services\Tcpip6\Parameters
----

== Setting the Retransmission Timeout (RTO)

Fundamental to TCP's timeout and retransmission procedures is how to set the RTO based upon measurement of the RTT experienced on a given connection.

If TCP retransmits a segment earlier than the RTT, it may be injecting duplicate traffic into the network unnecessarily.

Conversely, if it delays sending until much longer than one RTT, the overall network utilization (and single-connection throughput) drops when traffic is lost.

Knowing the RTT is made more complicated because it can change over time, as routes and network usage vary.

TCP must track these changes and modify its timeout accordingly in order to maintain good performance.

Because TCP sends acknowledgments when it receives data, it is possible to send a byte with a particular sequence number and measure the time required to receive an acknowledgment that covers that sequence number. Each such measurement is called an _RTT_ *_sample_*.

The challenge for TCP is

* to establish a good estimate for the range of RTT values given a set of samples that vary over time.

* The second step is how to set the RTO based on these values.

The RTT is estimated for each TCP connection separately, and one retransmission timer is pending whenever any data is in flight that consumes a sequence number (including SYN and FIN segments).

== Timer-Based Retransmission

Once a sending TCP has established its RTO based upon measurements of the time-varying values of effective RTT, whenever it sends a segment it ensures that a retransmission timer is set appropriately.

* When setting a retransmission timer, the sequence number of the so-called timed segment is recorded, and if an ACK is received in time, the retransmission timer is canceled.

* The next time the sender emits a packet with data in it, a new retransmission timer is set, the old one is canceled, and the new sequence number is recorded.

* The sending TCP therefore continuously sets and cancels one retransmission timer per connection; if no data is ever lost, no retransmission timer ever expires.

When TCP fails to receive an ACK for a segment it has timed on a connection within the RTO, it performs a timer-based retransmission.

TCP considers a timer-based retransmission as a fairly major event; it reacts very cautiously when it happens by quickly reducing the rate at which it sends data into the network. It does this in two ways.

* The first way is to reduce its sending window size based on congestion control procedures.
* The other way is to keep increasing a multiplicative backoff factor applied to the RTO each time a retransmitted segment is again retransmitted.
+
In particular, the RTO value is (temporarily) multiplied by the value `γ` to form the backed-off timeout when multiple retransmissions of the same segment occur:
+
[source,text]
RTO = γRTO
+
--
** In ordinary circumstances, `γ` has the value 1.
+
** On subsequent retransmissions, `γ` is doubled: 2, 4, 8, and so forth.
+
There is typically a maximum backoff factor that `γ` is not allowed to exceed (Linux ensures that the used RTO never exceeds the value `TCP_RTO_MAX`, which defaults to 120s).
+
[source,sh]
----
x@node-0:~$ uname -a; uname -r
Linux node-0 5.10.0-19-amd64 #1 SMP Debian 5.10.149-2 (2022-10-21) x86_64 GNU/Linux
5.10.0-19-amd64
x@node-0:~$ grep "#define HZ" /usr/include/asm-generic/param.h 
#define HZ 100
x@node-0:~$ grep "#define TCP_RTO_" /usr/src/linux-headers-5.10.0-19-common/include/net/tcp.h 
#define TCP_RTO_MAX	((unsigned)(120*HZ))
#define TCP_RTO_MIN	((unsigned)(HZ/5))
----
+
** Once an acceptable ACK is received, `γ` is reset to 1.
--
+
[source,console]
----
x@node-0:~$ while ss -itn dst *:6666; do sleep 1; done
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      0      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:204 rtt:1.86/0.93 cwnd:10
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:204 rtt:1.86/0.93 cwnd:10
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:816 backoff:2 rtt:1.86/0.93 cwnd:1
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:1632 backoff:3 rtt:1.86/0.93 cwnd:1
...
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:6528 backoff:5 rtt:1.86/0.93 cwnd:1
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      0      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:204 rtt:1.752/0.912 cwnd:2
----

== Fast Retransmit

*Fast retransmit* [RFC5681] is a TCP procedure that can induce a packet retransmission based on feedback from the receiver instead of requiring a retransmission timer to expire.

A typical TCP implements both fast retransmit and timer-based retransmission.

TCP generates an immediate acknowledgment (a _duplicate ACK_) when an *_out-of-order segment_* is received, and that the loss of a segment implies out-of-order arrivals at the receiver when subsequent data arrives.

* When this happens, a *_hole_* is created at the receiver.

* The sender's job then becomes filling the receiver's holes as quickly and efficiently as possible.

* The duplicate ACKs sent immediately when out-of-order data arrives are not delayed.
+
The reason is to let the sender know that a segment was received out of order, and to indicate what sequence number is expected (i.e., where the hole is).

* When SACK is used, these duplicate ACKs typically contain SACK blocks as well, which can provide information about more than one hole.

A duplicate ACK (with or without SACK blocks) arriving at a sender is a potential indicator that a packet sent earlier has been lost. It can also appear when there is *_packet reordering_* in the network.

TCP waits for a small number of duplicate ACKs (called the _duplicate ACK threshold_ or _dupthresh_) to be received before concluding that a packet has been lost and initiating a fast retransmit.

Packet loss inferred by the presence of duplicate ACKs is assumed to be related to _network congestion_, and congestion control procedures are invoked along with _fast retransmit_.

Without SACK, no more than one segment is typically retransmitted until an acceptable ACK is received.

With SACK, ACKs contain additional information allowing the sender to fill more than one hole in the receiver per RTT.

[source,console,highlight="14"]
----
x@node-1:~$ ip a show ens32 
2: ens32: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:85:26:07 brd ff:ff:ff:ff:ff:ff
    inet 192.168.91.137/24 brd 192.168.91.255 scope global ens32
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe85:2607/64 scope link 
       valid_lft forever preferred_lft forever
x@node-1:~$ sudo sysctl net.ipv4.ip_forward=1
net.ipv4.ip_forward = 1
x@node-1:~$ sudo sysctl net.ipv4.conf.all.send_redirects=0
net.ipv4.conf.all.send_redirects = 0
x@node-1:~$ sudo sysctl net.ipv4.conf.ens32.send_redirects=0
net.ipv4.conf.ens32.send_redirects = 0
x@node-1:~$ sudo tc qdisc replace dev ens32 root netem loss 50%
x@node-1:~$ sudo tc qdisc show dev ens32 
qdisc netem 8001: root refcnt 2 limit 1000 loss 50%
----

[source,console]
----
x@node-0:~$ sudo ip r replace default via 192.168.91.137
x@node-0:~$ ip r
default via 192.168.91.137 dev ens32 
192.168.91.0/24 dev ens32 proto kernel scope link src 192.168.91.128 
----

[source,console,highlight="7"]
----
x@node-0:~$ ping -c 4 windows.home 
PING windows.home (10.170.109.10) 56(84) bytes of data.
64 bytes from http-proxy (10.170.109.10): icmp_seq=1 ttl=128 time=5.61 ms
64 bytes from http-proxy (10.170.109.10): icmp_seq=2 ttl=128 time=1.28 ms

--- windows.home ping statistics ---
4 packets transmitted, 2 received, 50% packet loss, time 3021ms
rtt min/avg/max/mdev = 1.275/3.441/5.608/2.166 ms
x@node-0:~$ telnet windows.home 6666
Trying 10.170.109.10...
Connected to windows.home.
Escape character is '^]'.
HELLO
^]
telnet> q
Connection closed.
----

[source,console,highlight="3-6,9-15,17,20,24"]
----
x@node-0:~$ sudo tcpdump -tttttSn port 6666
 00:00:00.000000 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [S], seq 1089778284, win 64240, options [mss 1460,sackOK,TS val 1131499270 ecr 0,nop,wscale 7], length 0
 00:00:01.030663 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [S], seq 1089778284, win 64240, options [mss 1460,sackOK,TS val 1131500300 ecr 0,nop,wscale 7], length 0
 00:00:03.045839 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [S], seq 1089778284, win 64240, options [mss 1460,sackOK,TS val 1131502315 ecr 0,nop,wscale 7], length 0
 00:00:07.237567 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [S], seq 1089778284, win 64240, options [mss 1460,sackOK,TS val 1131506507 ecr 0,nop,wscale 7], length 0
 00:00:07.238040 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [S], seq 1089778284, win 64240, options [mss 1460,sackOK,TS val 1131506507 ecr 0,nop,wscale 7], length 0
 00:00:07.238577 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [S.], seq 462033365, ack 1089778285, win 64240, options [mss 1460], length 0
 00:00:07.238627 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [.], ack 462033366, win 64240, length 0
 00:00:07.343502 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [S.], seq 462033365, ack 1089778285, win 64240, options [mss 1460], length 0
 00:00:07.343531 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [.], ack 462033366, win 64240, length 0
 00:00:07.454848 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [S.], seq 462033365, ack 1089778285, win 64240, options [mss 1460], length 0
 00:00:07.562429 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [S.], seq 462033365, ack 1089778285, win 64240, options [mss 1460], length 0
 00:00:08.573351 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [S.], seq 462033365, ack 1089778285, win 64240, options [mss 1460], length 0
 00:00:08.573365 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [.], ack 462033366, win 64240, length 0
 00:00:08.573829 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [.], ack 462033366, win 64240, length 0
 00:00:13.085400 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [P.], seq 1089778285:1089778292, ack 462033366, win 64240, length 7
 00:00:13.087022 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [P.], seq 1089778285:1089778292, ack 462033366, win 64240, length 7
 00:00:13.087029 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [.], ack 1089778292, win 64240, length 0
 00:00:27.525036 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [F.], seq 1089778292, ack 462033366, win 64240, length 0
 00:00:27.525294 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [F.], seq 1089778292, ack 462033366, win 64240, length 0
 00:00:27.525532 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [.], ack 1089778293, win 64239, length 0
 00:00:27.525533 IP 10.170.109.10.6666 > 192.168.91.128.41716: Flags [FP.], seq 462033366, ack 1089778293, win 64239, length 0
 00:00:27.525570 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [.], ack 462033367, win 64240, length 0
 00:00:27.526226 IP 192.168.91.128.41716 > 10.170.109.10.6666: Flags [.], ack 462033367, win 64240, length 0
----

image::/assets/tcp-ip/tcp-timeout-and-retransmission/fast-retransmit-wireshark.png[,100%,100%]

[bibliography]
== References

* [[[tcp_ip_vol_1,1]]] Kevin Fall, W. Stevens, TCP/IP Illustrated: The Protocols, Volume 1 (Addison-Wesley Professional Computing Series) 2nd Edition
* [[[netem,2]]] https://wiki.linuxfoundation.org/networking/netem
* [[[iptables,3]]] https://www.netfilter.org/documentation/HOWTO/packet-filtering-HOWTO-7.html
* [[[emulating-bad-networks,4]]] https://samwho.dev/blog/emulating-bad-networks/
* [[[dpltc,5]]] https://sandilands.info/sgordon/dropping-packets-in-ubuntu-linux-using-tc-and-iptables

[appendix]
== Dropping Packets in Linux using tc and iptables

There are two simple ways to randomly drop packets on a Linux computer: using `tc`, the program dedicated for controlling traffic; and using `iptables`, the built-in firewall. <<netem>><<iptables>><<emulating-bad-networks>><<dpltc>>

=== Dropping Packets with tc

*tc* controls the transmit queues of your kernel. Normally when applications on your computer generate data to send, the data is passed to your kernel (via TCP and IP) for transmission on the network interface. The packets are transmitted in a first-in-first-out (FIFO) order.

_tc_ allows you to change the queuing mechanisms (e.g. giving priority to specific type of packets), as well as emulate links by delaying and dropping packets.

Here we will use _tc_ to drop packets. Because _tc_ controls the transmit queues, we use it on a source computer (normally _tc_ doesn't impact on what is received by your computer, but there are exceptions). 

[source,console]
----
x@node-0:~$ sudo tc qdisc replace dev ens32 root netem loss 25%
----

_netem_ is a special type of queuing discipline used for emulating networks. The above command tells the Linux kernel to drop on average 25% of the packets in the transmit queue. You can use different values of loss (e.g. 10%).

When using _tc_ you can show the current queue disciplines using:

[source,console]
----
x@node-0:~$ sudo tc qdisc show dev ens32
qdisc netem 8001: root refcnt 2 limit 1000 loss 25%
----

To show that it works, lets run an PING test. On computer `node-1` (the computer where _tc_ is NOT used) run: 

[source,console]
----
x@node-1:~$ ping node-0 -c 4
PING node-0.localdomain (192.168.91.129) 56(84) bytes of data.
64 bytes from 192.168.91.129 (192.168.91.129): icmp_seq=1 ttl=64 time=0.424 ms
64 bytes from 192.168.91.129 (192.168.91.129): icmp_seq=3 ttl=64 time=3.14 ms
64 bytes from 192.168.91.129 (192.168.91.129): icmp_seq=4 ttl=64 time=0.643 ms

--- node-0.localdomain ping statistics ---
4 packets transmitted, 3 received, 25% packet loss, time 22ms
rtt min/avg/max/mdev = 0.424/1.400/3.135/1.230 ms
----

To delete the above queue discipline use the _delete_ command instead of _replace_: 

[source,console]
----
x@node-0:~$ sudo tc qdisc delete dev ens32 root netem loss 25%
x@node-0:~$ sudo tc qdisc show dev ens32
qdisc pfifo_fast 0: root refcnt 2 bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
----

[IMPORTANT]
====
When loss is used locally (not on a bridge or router), the loss is reported to the upper level protocols. This may cause TCP to resend and behave as if there was no loss. When testing protocol reponse to loss it is best to use a netem on a bridge or router. <<netem>>
====

=== Dropping Packets with iptables

`iptables` allows you to create rules that specify how packets coming into your computer and going out of your computer are treated (and for routers, also forwarded by the router). The rules for packets coming in are in the _INPUT_ chain, packets going out are _OUTPUT_, and packets forwarded are in the _FORWARD_ chain. We will only use the _INPUT_ chain.

The rules can filter packets based on common packet identifiers (IP addresses, ports, protocol numbers) as well as other matching criteria. We will use a special _statistic_ matching module. For each packet that matches the filter, some action is applied (e.g. _DROP_ the packet, _ACCEPT_ the packet, or some more complex operation). We want to _DROP_ packets, in particular a specified percentage of packets.

On computer `node-1` (the destination), to view the current set of rules: 

[source,console]
----
x@node-1:~$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
----

There are no rules in either of the three chains. Note that the default policy (if a packet does not match any rule) is to ACCEPT packets.

Now to add a rule to the INPUT chain to drop 25% of incoming packets on computer `node-1`:

[source,console]
----
x@node-1:~$ sudo iptables -A INPUT -m statistic --mode random --probability 0.25 -j DROP
x@node-1:~$ sudo iptables -L INPUT --line-numbers 
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    DROP       all  --  anywhere             anywhere             statistic mode random probability 0.25000000000
----

To demonstrate the packet dropping, run another PING test on the source `node-0`:

[source,console]
----
x@node-0:~$ ping node-1.local -c 4
PING node-1.local (192.168.91.135) 56(84) bytes of data.
64 bytes from 192.168.91.135 (192.168.91.135): icmp_seq=1 ttl=64 time=0.547 ms
64 bytes from 192.168.91.135 (192.168.91.135): icmp_seq=2 ttl=64 time=1.91 ms
64 bytes from 192.168.91.135 (192.168.91.135): icmp_seq=3 ttl=64 time=0.513 ms

--- node-1.local ping statistics ---
4 packets transmitted, 3 received, 25% packet loss, time 3007ms
rtt min/avg/max/mdev = 0.513/0.988/1.905/0.648 ms
----

Returning to computer `node-1`, to delete a rule you can use the `-D` option:

[source,console]
----
x@node-1:~$ sudo iptables -D INPUT -m statistic --mode random --probability 0.25 -j DROP
x@node-1:~$ sudo iptables -L INPUT
Chain INPUT (policy ACCEPT)
target     prot opt source               destination  
----

(or you can refer to rules by number, e.g. `iptables -D INPUT 1` to delete rule 1 from the INPUT chain). 

Alternatively we can specify to drop every _n_ packets, starting from packet _p_. And we can combine with the standard filtering mechanisms of firewalls to only drop packets belong to a particular source/destination pair or application. 

[source,console]
----
x@node-1:~$ sudo iptables -A INPUT -p udp --dport 6666 -m statistic --mode nth --every 4 --packet 3 -j DROP
----

This rule should drop packet 3, 7, 11, ... for only one of the connections (with destination port 6666). 

Here is the output of an `iperf3` test at the source `node-0`. There are 25% packets dropped by the destination (receiver). 

[source,console]
----
x@node-0:~$ iperf3 -c node-1 -p 6666 -t 10 -u
Connecting to host node-1, port 6666
[  5] local 192.168.91.128 port 52026 connected to 192.168.91.137 port 6666
....
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams
[  5]   0.00-10.00  sec  1.25 MBytes  1.05 Mbits/sec  0.000 ms  0/906 (0%)  sender
[  5]   0.00-10.04  sec   962 KBytes   784 Kbits/sec  0.337 ms  226/906 (25%)  receiver
----
