= Firewall, netfilter & iptables
:page-layout: post
:page-categories: ['linux']
:page-tags: ['linux', 'iptables', 'netfilter']
:page-date: 2018-04-20 19:35:48 +0800
:page-revdate: 2021-12-11 08:20:16 +0800
:toc:
:sectnums:

== Concepts

*netfilter* is a set of hooks inside the Linux kernel that allows kernel modules to register callback functions with the network stack. A registered callback function is then called back for every packet that traverses the respective hook within the network stack.

*iptables* is a userspace command line utility for configuring Linux kernel *_firewall_* implemented within the https://netfilter.org/projects/iptables/[Netfilter] project. The term _iptables_ is also commonly used to refer to this kernel-level firewall. *_iptables_* is used for IPv4, and *_ip6tables_* is used for IPv6.

_iptables_ is used to inspect, modify, redirect, and/or drop IPv4 packets. The code for filtering IPv4 packets is already built into the kernel and is organized into a collection of `tables`, each with a specific purpose. The tables are made up of a set of predefined `chains`, and the chains `rules` which are traversed in order. Each rule consists of a predicate of potential matches and a corresponding action (called a `target`) which is executed if the predicate is true; i.e. the conditions are matched.

_iptables_ is the user utility which allows you to work with these chains/rules.

image::/assets/firewall-netfilter-iptables/tables_traverse.gif[,60%,60%]

The key to understanding how iptables works is the chart above. The _lowercase_ word on top is the table and the _uppercase_ word below is the chain. _Every IP packet that comes in on any network interface passes through this flow chart from top to bottom._

=== Tables

:network_address_translation: https://en.wikipedia.org/wiki/Network_address_translation
:mandatory_access_control: https://wiki.archlinux.org/index.php/Security#Mandatory_access_control
iptables contains five tables:

* `raw` is used only for configuring packets so that they are exempt from connection tracking.
* `filter` is the *_default table_*, and is where all the action typically associated with a firwall take place.
* `nat` is used for {network_address_translation}[network address translation] (e.g. port forwarding).
* `mangle` is used for specialized packet alterations.
* `security` is used for {mandatory_access_control}[Mandatory Access Control] networking rules. (e.g. SELinux -- see http://lwn.net/Articles/267140/[this article] for more details).

In most common use cases you will only use two of these: *`filter`* and *`nat`*.

[source,text]
----
                               XXXXXXXXXXXXXXXXXX
                             XXX     Network    XXX
                               XXXXXXXXXXXXXXXXXX
                                       +
                                       |
                                       v
 +-------------+              +------------------+
 |table: filter| <---+        | table: nat       |
 |chain: INPUT |     |        | chain: PREROUTING|
 +-----+-------+     |        +--------+---------+
       |             |                 |
       v             |                 v
 [local process]     |           ****************          +--------------+
       |             +---------+ Routing decision +------> |table: filter |
       v                         ****************          |chain: FORWARD|
****************                                           +------+-------+
Routing decision                                                  |
****************                                                  |
       |                                                          |
       v                        ****************                  |
+-------------+       +------>  Routing decision  <---------------+
|table: nat   |       |         ****************
|chain: OUTPUT|       |               +
+-----+-------+       |               |
      |               |               v
      v               |      +-------------------+
+--------------+      |      | table: nat        |
|table: filter | +----+      | chain: POSTROUTING|
|chain: OUTPUT |             +--------+----------+
+--------------+                      |
                                      v
                               XXXXXXXXXXXXXXXXXX
                             XXX    Network     XXX
                               XXXXXXXXXXXXXXXXXX
----

=== Chains

Tables consist of *chains*, which are lists of rules which are followed in order.

The default table, *filter*, contains three *_bultin-chain_*: `INPUT`, `OUTPUT` and `FORWARD` which are actived at different points of the packet filtering process, as illustrated in the flow chart.

* `INPUT` - This chain is used to control the behavior for incoming connections.
+
For example, if a user attempts to SSH into your PC/Server, iptables will attempt to match the IP address and port to a rule in the input chain.

* `FORWARD` - This chain is used for incoming connections that aren't actually being delivered locally.
+
Think of a *_router_* - data is always being sent to it but rarely actually destined for the router itself; the data is just forwarded to its target. Unless you're doing some kind of routing, NATing, or something else your system that rquires forwarding, you won't even use this chain.

* `OUTPUT` - This chain is used for outgoing connections.
+
For example, if you try to _ping blog.codefarm.me_, iptables will check output chain to see what the rules are regarding ping and blog.codefarm.me before making a decision to allow or deny the connection attempt.

The *nat* table incudes `PREROUTING`, `POSTROUTING`, and `OUTPUT` chains.

* `PREROUTING` - Alters packets before routing. i.e Packet translation happens immediately after the packet comes to the system and before routing.
+
This helps to translate the destination ip address of the packets to something that matches the routing on the local server. This is used for *_DNAT (destination NAT)_*.

* `POSTROUTING` - Alters packets after routing. i.e Packet translation happens when the packets are leaving the system.
+
This helps to translate the source ip address of the packets to something that might match the routing on the desintation server. This is used for *_SNAT (source NAT)_*.

* `OUTPUT` - NAT for locally generated packets on the firewall.

=== Rules

Packet fitlering is based on *rules*, which are specified by multiple _matches_ (condition the packet must satisfy so that the rule can be applied), and on *target* (action taken when the packet matches all conditions).

The typical things a rule might match on are what interface the packet came in on (e.g eth0 or eth1), what type of packet it is (ICMP, TCP, or UDP), or the desitination port of the packet.

Targets are specified using the `-j` or `--jump` option. Targets can be either _user-defined chains_, (i.e. if these conditions are matched, jump to the following user-defined chain and continue processing there), one of the special _built-in targets_, or a _target extension_.

* If the target is a built-in target, the fate of the packet is decided immediately and processing of the packet in current table is stopped.

* If the target is a user-defined chain and the fate of the packet is not decided by this second chain, it will be filtered against the remaining rules of the original chain.

* Target extensions can be either terminating (as built-in targets) or non-terminating (as user-defined chains).

=== Policy Chain Default Behavior

To see what the policy chains on the default table *filter* are currently configured to do with unmatched traffic, run the `iptables -L` command.

[source,console]
----
$ sudo iptables -L | grep policy
Chain INPUT (policy ACCEPT)
Chain FORWARD (policy ACCEPT)
Chain OUTPUT (policy ACCEPT)
----

As you can see, we also used the `grep` command to give use cleaner output. In that screenshot, our chains are currently figured to accpet traffic.

More times than not, you'll
want your system to accept connections by default. Unless you've changed the policy chain rules previously, this setting should already be configured. Either way, here's the command to accept connections by default:

[source,console]
----
$ sudo iptables -P INPUT ACCEPT
$ sudo iptables -P OUTPUT ACCEPT
$ sudo iptables -P FORWARD ACCEPT
----

By default to the ACCEPT rule, you can then use iptables to deny specific IP addresses or port numbers, while continuing to accept all other connections.

If you would rather deny all connections manually specify which ones you want to allow to connect, you should change the default policy of yur chains to DROP. Doing this probably only be useful for servers that contain sensitive information and only ever have the same IP addresses connect to them.

[source,console]
----
$ sudo iptables --policy INPUT DROP
$ sudo iptables --policy OUTPUT DROP
$ sudo iptables --policy FORWARD DROP
----

== Configuration and Usage

[source,man]
----
IPTABLES(8)                                                       iptables 1.4.21                                                       IPTABLES(8)



NAME
       iptables/ip6tables — administration tool for IPv4/IPv6 packet filtering and NAT

SYNOPSIS
       iptables [-t table] {-A|-C|-D} chain rule-specification

       ip6tables [-t table] {-A|-C|-D} chain rule-specification

       iptables [-t table] -I chain [rulenum] rule-specification

       iptables [-t table] -R chain rulenum rule-specification

       iptables [-t table] -D chain rulenum

       iptables [-t table] -S [chain [rulenum]]

       iptables [-t table] {-F|-L|-Z} [chain [rulenum]] [options...]

       iptables [-t table] -N chain

       iptables [-t table] -X [chain]

       iptables [-t table] -P chain target

       iptables [-t table] -E old-chain-name new-chain-name

       rule-specification = [matches...] [target]

       match = -m matchname [per-match-options]

       target = -j targetname [per-target-options]

DESCRIPTION
       Iptables  and ip6tables are used to set up, maintain, and inspect the tables of IPv4 and IPv6 packet filter rules in the Linux kernel.  Sev‐
       eral different tables may be defined.  Each table contains a number of built-in chains and may also contain user-defined chains.

       Each chain is a list of rules which can match a set of packets.  Each rule specifies what to do with a packet that matches.  This is  called
       a `target', which may be a jump to a user-defined chain in the same table.

TARGETS
       A  firewall  rule specifies criteria for a packet and a target.  If the packet does not match, the next rule in the chain is examined; if it
       does match, then the next rule is specified by the value of the target, which can be the name of a user-defined chain, one  of  the  targets
       described in iptables-extensions(8), or one of the special values ACCEPT, DROP or RETURN.

       ACCEPT  means to let the packet through.  DROP means to drop the packet on the floor.  RETURN means stop traversing this chain and resume at
       the next rule in the previous (calling) chain.  If the end of a built-in chain is reached or a rule in a built-in chain with  target  RETURN
       is matched, the target specified by the chain policy determines the fate of the packet.

TABLES
       There are currently five independent tables (which tables are present at any time depends on the kernel configuration options and which mod‐
       ules are present).

       -t, --table table
              This option specifies the packet matching table which the command should operate on.  If the kernel is configured with automatic mod‐
              ule loading, an attempt will be made to load the appropriate module for that table if it is not already there.

              The tables are as follows:

              filter:
                  This is the default table (if no -t option is passed). It contains the built-in chains INPUT (for packets destined to local sock‐
                  ets), FORWARD (for packets being routed through the box), and OUTPUT (for locally-generated packets).

              nat:
                  This table is consulted when a packet that creates a new connection is encountered.  It consists of three  built-ins:  PREROUTING
                  (for  altering  packets as soon as they come in), OUTPUT (for altering locally-generated packets before routing), and POSTROUTING
                  (for altering packets as they are about to go out).  IPv6 NAT support is available since kernel 3.7.

              mangle:
                  This table is used for specialized packet alteration.  Until kernel 2.4.17 it had two built-in chains: PREROUTING  (for  altering
                  incoming  packets before routing) and OUTPUT (for altering locally-generated packets before routing).  Since kernel 2.4.18, three
                  other built-in chains are also supported: INPUT (for packets coming into the box itself), FORWARD  (for  altering  packets  being
                  routed through the box), and POSTROUTING (for altering packets as they are about to go out).

              raw:
                  This  table is used mainly for configuring exemptions from connection tracking in combination with the NOTRACK target.  It regis‐
                  ters at the netfilter hooks with higher priority and is thus called before ip_conntrack, or any other IP tables.  It provides the
                  following  built-in  chains:  PREROUTING  (for packets arriving via any network interface) OUTPUT (for packets generated by local
                  processes)

              security:
                  This table is used for Mandatory Access Control (MAC) networking rules, such as those enabled by the SECMARK and CONNSECMARK tar‐
                  gets.  Mandatory Access Control is implemented by Linux Security Modules such as SELinux.  The security table is called after the
                  filter table, allowing any Discretionary Access Control (DAC) rules in the filter table to take effect before  MAC  rules.   This
                  table provides the following built-in chains: INPUT (for packets coming into the box itself), OUTPUT (for altering locally-gener‐
                  ated packets before routing), and FORWARD (for altering packets being routed through the box).

# ...

SEE ALSO
       iptables-apply(8), iptables-save(8), iptables-restore(8), iptables-extensions(8),

       The  packet-filtering-HOWTO  details  iptables usage for packet filtering, the NAT-HOWTO details NAT, the netfilter-extensions-HOWTO details
       the extensions that are not in the standard distribution, and the netfilter-hacking-HOWTO details the netfilter internals.
       See http://www.netfilter.org/.
----

=== Showing the Current Rules

[source,console]
----
$ sudo iptables -L # default table 'filter'
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)

$ sudo iptables -t nat -L
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination         

Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination         arget     prot opt source               destination    
----

[source,console]
----
$ sudo iptables -S # default table 'filter'
-P INPUT ACCEPT
-P FORWARD ACCEPT
-P OUTPUT ACCEPT

$ sudo iptables -t nat -S
-P PREROUTING ACCEPT
-P INPUT ACCEPT
-P OUTPUT ACCEPT
-P POSTROUTING ACCEPT
----

=== Resetting Rules

[source,sh]
----
# Flush your iptables all chains rules at filter table
$ sudo iptables -F

# Flush your iptables all chains rules at nat table
$ sudo iptables -t nat -F

$ sudo iptables -F INPUT    # Flush the INPUT chain only
$ sudo iptables -F OUTPUT   # Flush the OUTPUT chain only
$ sudo iptables -F FORWARD  # Flush the FORWARD chain only
----

=== Editing Rules

Rules can be edited by appending `-A` a rule to a chain, inserting `-I` it at a specific position on the chain, replacing `-R` an existing rule, or delete `-D` it.

==== Allowing Incomming Traffic on Specific Ports

You could start by blocking traffic, but you might be working over SSH, where you would need to allow SSH before blocking everything else.

To allow incomming traffic on the default SSH port (22), you could tell iptables to allow all TCP traffic on that port to come in.

[source,sh]
$ sudo iptables -A INPUT -p tcp --dport ssh -j ACCEPT

or

[source,sh]
$ sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT

Referring back to the list above, you can see that this tells iptables:

. append this rule to the input chain (`-A INPUT`) so we look at incomming traffic.
. check to see if it is TCP (`-p tcp`).
. if so, check to see if the input goes to the SSH port (`--dport ssh`).
. if so, accept the input (`-j ACCEPT`.

Lets check the rules: (only the first few lines shown, you will see more)

[source,console]
----
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh
----

Now, let's allow all incomming web traffic

```console
$ sudo iptables -A INPUT -p tcp --dport http -j ACCEPT
$ sudo iptables -A INPUT -p tcp --dport https -j ACCEPT
```
or

```console
$ sudo iptables -A INPUT -p tcp -m multiport --dports http,https -j ACCEPT
```

Checking our rules, we have

```console
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:http
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:https
```

Allow default port range for Kubernetes NodePort servies.

```console
$ sudo iptables -A INPUT -p tcp --dport 30000:32767 -j ACCEPT -m comment --comment "Allow default port range of kubernetes nodeport services"
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     tcp  --  anywhere             anywhere             tcp dpts:30000:32767 /* Allow default port range of kubernetes nodeport services */

Chain FORWARD (policy DROP)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination 
```

We have specifically allowed tcp traffic to the ssh and web ports, but as we have not blocked anything, all traffic can still come in.

==== Block Incomming Traffic

Once a decision is made to accept a packet, no more rules affect it. As our rules allowing ssh and web traffic come first, as long as our rule to block all traffic comes after them, we can still accept the traffic we want. All we need to do is put the rule to block all traffic at the end.

```console
$ sudo iptables -A INPUT -j DROP
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:http
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:https
DROP       all  --  anywhere             anywhere
```

#### Allow Incomming Traffic on Specific IP Addresses

- Here `-s 0/0` stand for any incomming source with any IP addresses.

    ```console
    $ sudo iptables -A INPUT -p tcp -s 0/0 --dport 22 -j ACCEPT
    $ sudo iptables -L
    Chain INPUT (policy ACCEPT)
    target     prot opt source               destination
    ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh
    ```

- `-s 192.168.66.128/24` using CIDR values, it stands for IP starting from 192.168.66.1 to 192.168.66.255.

    ```console
    $ sudo iptables -A INPUT -p tcp -s 192.168.66.128/24 --dport 22 -j ACCEPT
    $ sudo iptables -L
    Chain INPUT (policy ACCEPT)
    target     prot opt source               destination
    ACCEPT     tcp  --  192.168.66.0/24      anywhere             tcp dpt:ssh
    ```

    ```console
    $ sudo iptables -A INPUT -p tcp -s 192.168.66.128/32 --dport 22 -j ACCEPT
    $ sudo iptables -L
    Chain INPUT (policy ACCEPT)
    target     prot opt source               destination
    ACCEPT     tcp  --  192.168.66.128       anywhere             tcp dpt:ssh
    ```
    
    ```console
    $ sudo iptables -A INPUT -p tcp -s 192.168.66.128 --dport 22 -j ACCEPT
    $ sudo iptables -L
    Chain INPUT (policy ACCEPT)
    target     prot opt source               destination
    ACCEPT     tcp  --  192.168.66.128       anywhere             tcp dpt:ssh
    ```

#### Blocking ICMP

```console
$ sudo iptables -A OUTPUT -p icmp --icmp-type 8 -j DROP
$ sudo iptables -L
Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
DROP       icmp --  anywhere             anywhere             icmp echo-request
$ ping www.codefarm.me
PING www.codefarm.me (104.27.162.235) 56(84) bytes of data.
ping: sendmsg: Operation not permitted
```

#### Blocking MongoDB from outside attach

```console
$ sudo iptables -A INPUT -p tcp -s 192.168.66.0/24 --dport 27017 -j ACCEPT
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  192.168.66.0/24      anywhere             tcp dpt:27017
```
    
#### Blocking DDOS
    
```console
$ sudo iptables -A INPUT -p tcp --dport 80 -m limit --limit 20/minute --limit-burst 100 -j ACCEPT
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:http limit: avg 20/min burst 100
```

#### Insert a New Rule / Replace an Old Rule

```console
$ sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:http

$ sudo iptables -I INPUT 1 -p tcp --dport 22 -j ACCEPT
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:http

$ sudo iptables -R INPUT 1 -p tcp --dport 443 -j ACCEPT
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:https
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:http
```

#### Create User Defined Chain / Target

```console
$ sudo iptables -N CODE_FARM
$ sudo iptables -L | grep 'Chain'
Chain INPUT (policy ACCEPT)
Chain FORWARD (policy ACCEPT)
Chain OUTPUT (policy ACCEPT)
Chain CODE_FARM (0 references)

$ sudo iptables -A INPUT -p tcp --dport 22 -j CODE_FARM
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
CODE_FARM  tcp  --  anywhere             anywhere             tcp dpt:ssh

Chain CODE_FARM (1 references)
target     prot opt source               destination

$ sudo iptables -A CODE_FARM -p tcp -j ACCEPT
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
CODE_FARM  tcp  --  anywhere             anywhere             tcp dpt:ssh

Chain CODE_FARM (1 references)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             anywhere

$ sudo iptables -P INPUT DROP
$ sudo iptables -L
Chain INPUT (policy DROP)
target     prot opt source               destination
CODE_FARM  tcp  --  anywhere             anywhere             tcp dpt:ssh

Chain CODE_FARM (1 references)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             anywhere
```

### Saving and Restoring IPTables Rules

Changes to **iptables** are transitory; if the system is rebooted or if the **iptables** service is restarted, the rules are automatically flushed and reset. To save the rules so that they are loaded when the **iptables** service is started, use the following command: 

```console
$ sudo service iptables save
```

The rules are stored in the file **/etc/sysconfig/iptables** and are applied whenever the service is started or the machine is rebooted.

You can also save the current iptables into a file and restore it.

```console
$ sudo iptables -L
Chain INPUT (policy DROP)
target     prot opt source               destination         
ACCEPT     tcp  --  192.168.66.0/24      anywhere             tcp dpt:ssh
ACCEPT     tcp  --  anywhere             anywhere             multiport dports http,https
DROP       all  --  anywhere             anywhere            

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
$ sudo iptables-save | tee iptables.rules # save current iptables into iptables.rules and print to standard output
$ sudo Generated by iptables-save v1.6.0 on Fri Jan 18 16:43:19 2019
*filter
:INPUT DROP [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [278:30254]
-A INPUT -s 192.168.66.0/24 -p tcp -m tcp --dport 22 -j ACCEPT
-A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT
-A INPUT -j DROP
COMMIT
$ sudo Completed on Fri Jan 18 16:43:19 2019
$ sudo iptables -P INPUT ACCEPT # allow any incomming traffic before delete all rules
$ sudo iptables -F # delete all rules
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
$ sudo iptables-restore iptables.rules # restore iptables from iptables.rules
$ sudo iptables -L
Chain INPUT (policy DROP)
target     prot opt source               destination         
ACCEPT     tcp  --  192.168.66.0/24      anywhere             tcp dpt:ssh
ACCEPT     tcp  --  anywhere             anywhere             multiport dports http,https
DROP       all  --  anywhere             anywhere            

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
```

## References

1. The netfilter.org project, [https://netfilter.org/index.html](https://netfilter.org/index.html)
1. iptables - ArchWiki, [https://wiki.archlinux.org/index.php/iptables](https://wiki.archlinux.org/index.php/iptables)
1. IPTABLES VS FIREWALLD \| Unixmen, [https://www.unixmen.com/iptables-vs-firewalld/](https://www.unixmen.com/iptables-vs-firewalld/)
1. The Beginner's Guide to iptables, the Linux Firewall, [(https://www.howtogeek.com/177621/the-beginners-guide-to-iptables-the-linux-firewall/](https://www.howtogeek.com/177621/the-beginners-guide-to-iptables-the-linux-firewall/)
1. IptablesHowTo - Community Help Wiki, [https://help.ubuntu.com/community/IptablesHowTo](https://help.ubuntu.com/community/IptablesHowTo)
1. HowTos/Network/IPTables - CentOS Wiki, [https://wiki.centos.org/HowTos/Network/IPTables](https://wiki.centos.org/HowTos/Network/IPTables)
1. RETURN target, [https://www.frozentux.net/iptables-tutorial/chunkyhtml/x4625.html](https://www.frozentux.net/iptables-tutorial/chunkyhtml/x4625.html)
1. Linux Firewall Tutorial: IPTables Tables, Chains, Rules Fundamentals, [https://www.thegeekstuff.com/2011/01/iptables-fundamentals/](https://www.thegeekstuff.com/2011/01/iptables-fundamentals/)
1. Saving Iptables Firewall Rules Permanently, [https://www.thomas-krenn.com/en/wiki/Saving_Iptables_Firewall_Rules_Permanently](https://www.thomas-krenn.com/en/wiki/Saving_Iptables_Firewall_Rules_Permanently)
