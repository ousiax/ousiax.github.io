= JavaScript Learning Notes
:page-layout: post
:page-categories: ['javascript']
:page-tags: ['javascript', 'js']
:page-date: 2024-04-15 13:40:59 +0800
:page-revdate: 2024-04-15 13:40:59 +0800
:toc: preamble
:toclevels: 4
:sectnums:
:sectnumlevels: 4

JavaScript is a cross-platform, object-oriented scripting language. The core language of JavaScript is standardized by the ECMA TC39 committee as a language named ECMAScript.

TIP: "ECMAScript" is the term for the language standard, but "ECMAScript" and "JavaScript" can be used interchangeably.

TIP: The https://www.ecma-international.org/[ECMAScript specification] does not describe the Document Object Model (DOM), which is standardized by the https://www.w3.org/[World Wide Web Consortium (W3C)] and/or https://whatwg.org/[WHATWG (Web Hypertext Application Technology Working Group)].

Among other things, ECMAScript defines:

* Language syntax (parsing rules, keywords, control flow, object literal initialization, ...)
* Error handling mechanisms (`throw`, `try...catch`, ability to create user-defined `Error` types)
* Types (`boolean`, `number`, `string`, `function`, `object`, ...)
* A prototype-based inheritance mechanism
* Built-in objects and functions, including `JSON`, `Math`, `Array` methods, `parseInt`, `decodeURI`, etc.
* Strict mode
* A module system
* Basic memory model

== Grammar and types

JavaScript is *case-sensitive* and uses the *Unicode* character set.

```js
const Hello世界 = 'Hello World!';
console.log(Hello世界); // logs "Hello World!"
console.log(hello世界); // Uncaught ReferenceError: hello世界 is not defined
```

A semicolon (`;`) is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they MUST be separated by semicolons.

```js
const Hello世界 = 'Hello World!'; console.log(Hello世界) // logs "Hello World!"
```

The syntax of comments is the same as in C++ and in many other languages:

```js
// a one line comment

/* this is a longer,
 * multi-line comment
 */

```

JavaScript has three kinds of variable declarations.

* `var`
+
Declares both local and global variables, depending on the execution context, optionally initializing it to a value.

* `let`
+
Declares a block-scoped, local variable, optionally initializing it to a value.

* `const`
+
Declares a block-scoped, read-only named constant.

TIP: Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an *undeclared global* variable.

If a variable is declared without an initializer, it is assigned the value `undefined`.

```js
let x;
console.log(x); // logs "undefined"
```

A variable may belong to one of the following scopes:

* Global scope: The default scope for all code running in script mode.
* Module scope: The scope for code running in module mode.
* Function scope: The scope created with a function.
* Block scope: The scope created (`let`, `const`) with a pair of curly braces (a https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block[block]).

When you declare a variable outside of any function, it is called a *global variable*, because it is available to any other code in the current document. When you declare a variable within a function, it is called a *local variable*, because it is available only within that function.

* Global variables are in fact properties of the global object.

* In web pages, the global object is https://developer.mozilla.org/en-US/docs/Web/API/Window[window], so you can read and set global variables using the `window.variable` syntax.

* In all environments, the https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis[globalThis] variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.

Blocks only scope `let` and `const` declarations, but not `var` declarations.

```js
{
  var x = 1;
}
console.log(x); // 1
```

```js
{
  const x = 1;
}
console.log(x); // ReferenceError: x is not defined
```

`var`-declared variables are https://developer.mozilla.org/en-US/docs/Glossary/Hoisting[hoisted], meaning the variable can be referred anywhere in its scope, even if its declaration isn't reached yet.

```js
console.log(x === undefined); // true
var x = 3;
```

Same as:

```js
var x;
console.log(x === undefined); // true
x = 3;
```

The latest ECMAScript standard defines eight data types:

:Boolean: https://developer.mozilla.org/en-US/docs/Glossary/Boolean
:Null: https://developer.mozilla.org/en-US/docs/Glossary/Null
:Undefined: https://developer.mozilla.org/en-US/docs/Glossary/Undefined
:Number: https://developer.mozilla.org/en-US/docs/Glossary/Number
:BigInt: https://developer.mozilla.org/en-US/docs/Glossary/BigInt
:String: https://developer.mozilla.org/en-US/docs/Glossary/String
:Symbol: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol
:Object: https://developer.mozilla.org/en-US/docs/Glossary/Object

* Seven data types that are primitives:
 . {Boolean}[Boolean]. `true` and `false`.
 . {Null}[null]. A special keyword denoting a null value. (Because JavaScript is case-sensitive, `null` is not the same as `Null`, `NULL`, or any other variant.)
 . {Undefined}[undefined]. A top-level property whose value is not defined.
 . {Number}[Number]. An integer or floating point number. For example: `42` or `3.14159`.
 . {BigInt}[BigInt]. An integer with arbitrary precision. For example: `9007199254740992n`.
 . {String}[String]. A sequence of characters that represent a text value. For example: `"Howdy"`.
 . {Symbol}[Symbol]. A data type whose instances are unique and immutable.
* and {Object}[Object]

JavaScript is a *dynamically typed language*, which means that data types are automatically converted as-needed during script execution.

```js
let answer = 42;
answer = "Thanks for all the fish!";

x = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"

"37" - 7; // 30
"37" * 7; // 259

// An alternative method of retrieving a number from a string is with the `+` (unary plus) operator:
// Note: the parentheses are added for clarity, not required.
"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
```

An *array literal* is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets (`[]`).

```js
const coffees = ["French Roast", "Colombian", "Kona"];
```

* If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the fish array:
+
```js
const fish = ["Lion", /* empty */, "Angel"];
console.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]
```
+
Note that the second item is "empty", which is not exactly the same as the actual `undefined` value. When using array-traversing methods like `Array.prototype.map`, empty slots are skipped. However, index-accessing `fish[1]` still returns `undefined`.
+
```js
const fish = ["Lion", /* empty */, "Angel"];
fish.map(x => console.log(x));
// Lion
// Angel
```

* If you include a trailing comma at the end of the list of elements, the comma is ignored.
+
```js
// Only the last comma is ignored.
const myList = ["home", /* empty */, "school", /* empty */,];
```

*Integer and BigInt literals* can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

* A _decimal_ integer literal is a sequence of digits without a leading `0` (zero).

* A leading `0` (zero) on an integer literal, or a leading `0o` (or `0O`) indicates it is in _octal_.

* A leading `0x` (or `0X`) indicates a _hexadecimal_ integer literal.

* A leading `0b` (or `0B`) indicates a _binary_ integer literal.

* A trailing `n` suffix on an integer literal indicates a _BigInt_ literal. The BigInt literal can use any of the above bases. Note that leading-zero octal syntax like `0123n` is not allowed, but `0o123n` is fine.
+
```js
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)
```

A *floating-point literal* can have the following parts:

```js
[digits].[digits][(E|e)[(+|-)]digits]
```

* An unsigned decimal integer,
* A decimal point (`.`),
* A fraction (another decimal number),
* An exponent (`e` or `E`).
+
```js
3.1415926
.123456789
-.123456789 // -0.123456789
3.1E+12
.1e-23
```

NOTE: Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like `-123.4` are fine, being interpreted as a unary `-` operator applied to the numeric literal `123.4`.

An *object literal* is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`).

* Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript https://developer.mozilla.org/en-US/docs/Glossary/Identifier[identifier] or number, it must be enclosed in quotes.

* Property names that are not valid identifiers cannot be accessed as a dot (`.`) property.
+
```js
const unusualPropertyNames = {
  '': 'An empty string',
  '!': 'Bang!'
}
console.log(unusualPropertyNames.'');   // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!);    // SyntaxError: Unexpected token !
```

* Instead, they must be accessed with the bracket notation (`[]`).
+
```js
console.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!
```

* Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for `foo: foo` assignments, defining methods, making `super` calls, and computing property names with expressions.
+
```js
const obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return "d " + super.toString();
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
```

A https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions[*regex*] *literal* is a pattern enclosed between slashes: `/pattern/flags`.

```js
const re1 = /ab+c/; // new RegExp("ab+c");
const re2 = /\w+\s/g; // new RegExp("\\w+\\s", "g");
```

A *string literal* is zero or more characters enclosed in double (`"`) or single (`'`) quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).

```js
'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"
"He read \"The Cremation of Sam McGee\" by R.W. Service.";
```

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals[*Template literals*] are literals delimited with backtick (```) characters, allowing for _multi-line strings_, _string interpolation_ with embedded expressions, and special constructs called _tagged templates_.

```js
`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
```

== Control flow and error handling

The most basic statement is a *block statement*, which is used to group statements. The block is delimited by a pair of curly braces:

```js
{
  statement1;
  statement2;
  // …
  statementN;
}
```

A *conditional statement* is a set of commands that executes if a specified condition is true.

The following values evaluate to false (also known as https://developer.mozilla.org/en-US/docs/Glossary/Falsy[Falsy] values):

* `false`
* `undefined`
* `null`
* `0`
* `NaN`
* the empty string (`""`)

All other values—including all objects—evaluate to `true` when passed to a conditional statement.

[NOTE]
====
Note: Do not confuse the primitive boolean values `true` and `false` with the true and false values of the `Boolean` object!

For example:

```js
const b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}
```
====

JavaScript supports two conditional statements: `if...else` and `switch`.

* Use the `if` statement to execute a statement if a logical condition is `true`. Use the optional `else` clause to execute a statement if the condition is `false`. Use the optional `else if` to have multiple conditions tested in sequence. 
+
```js
if (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}
```

* A `switch` statement allows a program to evaluate an expression and attempt to match the expression's value to a `case` label. If a match is found, the program executes the associated statement. 
+
```js
switch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}
```

Use the `throw` statement to throw an exception. A throw statement specifies the value to be thrown:

```js
throw expression;
```

```js
throw "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
throw new Error("Whoops!");
```

While it is common to throw numbers or strings as https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error[errors], it is frequently more effective to use one of the exception types specifically created for this purpose: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#error_types[ECMAScript exceptions] and https://developer.mozilla.org/en-US/docs/Web/API/DOMException[DOMException].

The `try...catch` statement marks a block of statements to try, and specifies one or more responses should an exception be thrown. If an exception is thrown, the `try...catch` statement catches it. The `finally` block executes after the try and catch blocks execute but before the statements following the `try...catch` statement. 

* Throwing a generic error
+
```js
try {
  throw new Error("Whoops!");
} catch (e) {
  console.error(`${e.name}: ${e.message}`);
}
```

* Handling a specific error type
+
```js
try {
  foo.bar();
} catch (e) {
  if (e instanceof EvalError) {
    console.error(`${e.name}: ${e.message}`);
  } else if (e instanceof RangeError) {
    console.error(`${e.name}: ${e.message}`);
  }
  // etc.
  else {
    // If none of our cases matched leave the Error unhandled
    throw e;
  }
}
```

* Using `finally` ensures that the file is never left open, even if an error occurs. 
+
```js
openMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}
```

* If the `finally` block returns a value, this value becomes the return value of the entire `try…catch…finally` production, regardless of any `return` statements in the `try` and `catch` blocks: 
+
```js
function f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    console.log(4); // not reachable
  }
  // "return false" is executed now
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false
```

* Overwriting of return values by the `finally` block also applies to exceptions thrown or re-thrown inside of the `catch` block: 
+
```js
function f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
  }
  // "return false" is executed now
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false
```






== References

* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide
