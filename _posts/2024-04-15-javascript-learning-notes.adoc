= JavaScript Learning Notes
:page-layout: post
:page-categories: ['javascript']
:page-tags: ['javascript', 'js']
:page-date: 2024-04-15 13:40:59 +0800
:page-revdate: 2024-04-15 13:40:59 +0800
:toc: preamble
:toclevels: 4
:sectnums:
:sectnumlevels: 4

JavaScript is a cross-platform, object-oriented scripting language. The core language of JavaScript is standardized by the ECMA TC39 committee as a language named ECMAScript.

TIP: "ECMAScript" is the term for the language standard, but "ECMAScript" and "JavaScript" can be used interchangeably.

TIP: The https://www.ecma-international.org/[ECMAScript specification] does not describe the Document Object Model (DOM), which is standardized by the https://www.w3.org/[World Wide Web Consortium (W3C)] and/or https://whatwg.org/[WHATWG (Web Hypertext Application Technology Working Group)].

Among other things, ECMAScript defines:

* Language syntax (parsing rules, keywords, control flow, object literal initialization, ...)
* Error handling mechanisms (`throw`, `try...catch`, ability to create user-defined `Error` types)
* Types (`boolean`, `number`, `string`, `function`, `object`, ...)
* A prototype-based inheritance mechanism
* Built-in objects and functions, including `JSON`, `Math`, `Array` methods, `parseInt`, `decodeURI`, etc.
* Strict mode
* A module system
* Basic memory model

== Grammar and types

JavaScript is *case-sensitive* and uses the *Unicode* character set.

```js
const Hello世界 = 'Hello World!';
console.log(Hello世界); // logs "Hello World!"
console.log(hello世界); // Uncaught ReferenceError: hello世界 is not defined
```

A semicolon (`;`) is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they MUST be separated by semicolons.

```js
const Hello世界 = 'Hello World!'; console.log(Hello世界) // logs "Hello World!"
```

The syntax of comments is the same as in C++ and in many other languages:

```js
// a one line comment

/* this is a longer,
 * multi-line comment
 */

```

JavaScript has three kinds of variable declarations.

* `var`
+
Declares both local and global variables, depending on the execution context, optionally initializing it to a value.

* `let`
+
Declares a block-scoped, local variable, optionally initializing it to a value.

* `const`
+
Declares a block-scoped, read-only named constant.

TIP: Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an *undeclared global* variable.

If a variable is declared without an initializer, it is assigned the value `undefined`.

```js
let x;
console.log(x); // logs "undefined"
```

A variable may belong to one of the following scopes:

* Global scope: The default scope for all code running in script mode.
* Module scope: The scope for code running in module mode.
* Function scope: The scope created with a function.
* Block scope: The scope created (`let`, `const`) with a pair of curly braces (a https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block[block]).

When you declare a variable outside of any function, it is called a *global variable*, because it is available to any other code in the current document. When you declare a variable within a function, it is called a *local variable*, because it is available only within that function.

* Global variables are in fact properties of the global object.

* In web pages, the global object is https://developer.mozilla.org/en-US/docs/Web/API/Window[window], so you can read and set global variables using the `window.variable` syntax.

* In all environments, the https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis[globalThis] variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.

Blocks only scope `let` and `const` declarations, but not `var` declarations.

```js
{
  var x = 1;
}
console.log(x); // 1
```

```js
{
  const x = 1;
}
console.log(x); // ReferenceError: x is not defined
```

`var`-declared variables are https://developer.mozilla.org/en-US/docs/Glossary/Hoisting[hoisted], meaning the variable can be referred anywhere in its scope, even if its declaration isn't reached yet.

```js
console.log(x === undefined); // true
var x = 3;
```

Same as:

```js
var x;
console.log(x === undefined); // true
x = 3;
```

The latest ECMAScript standard defines eight data types:

:Boolean: https://developer.mozilla.org/en-US/docs/Glossary/Boolean
:Null: https://developer.mozilla.org/en-US/docs/Glossary/Null
:Undefined: https://developer.mozilla.org/en-US/docs/Glossary/Undefined
:Number: https://developer.mozilla.org/en-US/docs/Glossary/Number
:BigInt: https://developer.mozilla.org/en-US/docs/Glossary/BigInt
:String: https://developer.mozilla.org/en-US/docs/Glossary/String
:Symbol: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol
:Object: https://developer.mozilla.org/en-US/docs/Glossary/Object

* Seven data types that are primitives:
 . {Boolean}[Boolean]. `true` and `false`.
 . {Null}[null]. A special keyword denoting a null value. (Because JavaScript is case-sensitive, `null` is not the same as `Null`, `NULL`, or any other variant.)
 . {Undefined}[undefined]. A top-level property whose value is not defined.
 . {Number}[Number]. An integer or floating point number. For example: `42` or `3.14159`.
 . {BigInt}[BigInt]. An integer with arbitrary precision. For example: `9007199254740992n`.
 . {String}[String]. A sequence of characters that represent a text value. For example: `"Howdy"`.
 . {Symbol}[Symbol]. A data type whose instances are unique and immutable.
* and {Object}[Object]

JavaScript is a *dynamically typed language*, which means that data types are automatically converted as-needed during script execution.

```js
let answer = 42;
answer = "Thanks for all the fish!";

x = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"

"37" - 7; // 30
"37" * 7; // 259

// An alternative method of retrieving a number from a string is with the `+` (unary plus) operator:
// Note: the parentheses are added for clarity, not required.
"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
```

An *array literal* is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets (`[]`).

```js
const coffees = ["French Roast", "Colombian", "Kona"];
```

* If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the fish array:
+
```js
const fish = ["Lion", /* empty */, "Angel"];
console.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]
```
+
Note that the second item is "empty", which is not exactly the same as the actual `undefined` value. When using array-traversing methods like `Array.prototype.map`, empty slots are skipped. However, index-accessing `fish[1]` still returns `undefined`.
+
```js
const fish = ["Lion", /* empty */, "Angel"];
fish.map(x => console.log(x));
// Lion
// Angel
```

* If you include a trailing comma at the end of the list of elements, the comma is ignored.
+
```js
// Only the last comma is ignored.
const myList = ["home", /* empty */, "school", /* empty */,];
```

*Integer and BigInt literals* can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

* A _decimal_ integer literal is a sequence of digits without a leading `0` (zero).

* A leading `0` (zero) on an integer literal, or a leading `0o` (or `0O`) indicates it is in _octal_.

* A leading `0x` (or `0X`) indicates a _hexadecimal_ integer literal.

* A leading `0b` (or `0B`) indicates a _binary_ integer literal.

* A trailing `n` suffix on an integer literal indicates a _BigInt_ literal. The BigInt literal can use any of the above bases. Note that leading-zero octal syntax like `0123n` is not allowed, but `0o123n` is fine.
+
```js
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)
```

A *floating-point literal* can have the following parts:

```js
[digits].[digits][(E|e)[(+|-)]digits]
```

* An unsigned decimal integer,
* A decimal point (`.`),
* A fraction (another decimal number),
* An exponent (`e` or `E`).
+
```js
3.1415926
.123456789
-.123456789 // -0.123456789
3.1E+12
.1e-23
```

NOTE: Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like `-123.4` are fine, being interpreted as a unary `-` operator applied to the numeric literal `123.4`.

An *object literal* is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`).

* Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript https://developer.mozilla.org/en-US/docs/Glossary/Identifier[identifier] or number, it must be enclosed in quotes.

* Property names that are not valid identifiers cannot be accessed as a dot (`.`) property.
+
```js
const unusualPropertyNames = {
  '': 'An empty string',
  '!': 'Bang!'
}
console.log(unusualPropertyNames.'');   // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!);    // SyntaxError: Unexpected token !
```

* Instead, they must be accessed with the bracket notation (`[]`).
+
```js
console.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!
```

* Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for `foo: foo` assignments, defining methods, making `super` calls, and computing property names with expressions.
+
```js
const obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return "d " + super.toString();
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
```

A https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions[*regex*] *literal* is a pattern enclosed between slashes: `/pattern/flags`.

```js
const re1 = /ab+c/; // new RegExp("ab+c");
const re2 = /\w+\s/g; // new RegExp("\\w+\\s", "g");
```

A *string literal* is zero or more characters enclosed in double (`"`) or single (`'`) quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).

```js
'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"
"He read \"The Cremation of Sam McGee\" by R.W. Service.";
```

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals[*Template literals*] are literals delimited with backtick (```) characters, allowing for _multi-line strings_, _string interpolation_ with embedded expressions, and special constructs called _tagged templates_.

```js
`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
```

== Control flow and error handling

The most basic statement is a *block statement*, which is used to group statements. The block is delimited by a pair of curly braces:

```js
{
  statement1;
  statement2;
  // …
  statementN;
}
```

A *conditional statement* is a set of commands that executes if a specified condition is true.

The following values evaluate to false (also known as https://developer.mozilla.org/en-US/docs/Glossary/Falsy[Falsy] values):

* `false`
* `undefined`
* `null`
* `0`
* `NaN`
* the empty string (`""`)

All other values—including all objects—evaluate to `true` when passed to a conditional statement.

[NOTE]
====
Note: Do not confuse the primitive boolean values `true` and `false` with the true and false values of the `Boolean` object!

For example:

```js
const b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}
```
====

JavaScript supports two conditional statements: `if...else` and `switch`.

* Use the `if` statement to execute a statement if a logical condition is `true`. Use the optional `else` clause to execute a statement if the condition is `false`. Use the optional `else if` to have multiple conditions tested in sequence. 
+
```js
if (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}
```

* A `switch` statement allows a program to evaluate an expression and attempt to match the expression's value to a `case` label. If a match is found, the program executes the associated statement. 
+
```js
switch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}
```

Use the `throw` statement to throw an exception. A throw statement specifies the value to be thrown:

```js
throw expression;
```

```js
throw "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
throw new Error("Whoops!");
```

While it is common to throw numbers or strings as https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error[errors], it is frequently more effective to use one of the exception types specifically created for this purpose: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#error_types[ECMAScript exceptions] and https://developer.mozilla.org/en-US/docs/Web/API/DOMException[DOMException].

The `try...catch` statement marks a block of statements to try, and specifies one or more responses should an exception be thrown. If an exception is thrown, the `try...catch` statement catches it. The `finally` block executes after the try and catch blocks execute but before the statements following the `try...catch` statement. 

* Throwing a generic error
+
```js
try {
  throw new Error("Whoops!");
} catch (e) {
  console.error(`${e.name}: ${e.message}`);
}
```

* Handling a specific error type
+
```js
try {
  foo.bar();
} catch (e) {
  if (e instanceof EvalError) {
    console.error(`${e.name}: ${e.message}`);
  } else if (e instanceof RangeError) {
    console.error(`${e.name}: ${e.message}`);
  }
  // etc.
  else {
    // If none of our cases matched leave the Error unhandled
    throw e;
  }
}
```

* Using `finally` ensures that the file is never left open, even if an error occurs. 
+
```js
openMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}
```

* If the `finally` block returns a value, this value becomes the return value of the entire `try…catch…finally` production, regardless of any `return` statements in the `try` and `catch` blocks: 
+
```js
function f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    console.log(4); // not reachable
  }
  // "return false" is executed now
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false
```

* Overwriting of return values by the `finally` block also applies to exceptions thrown or re-thrown inside of the `catch` block: 
+
```js
function f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
  }
  // "return false" is executed now
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false
```

* Custom https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error[error] types
+
```js
class CustomError extends Error {
  constructor(foo = "bar", ...params) {
    // Pass remaining arguments (including vendor specific ones) to parent constructor
    super(...params);

    // Maintains proper stack trace for where our error was thrown (only available on V8)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CustomError);
    }

    this.name = "CustomError";
    // Custom debugging information
    this.foo = foo;
    this.date = new Date();
  }
}

try {
  throw new CustomError("baz", "bazMessage");
} catch (e) {
  console.error(e.name); // CustomError
  console.error(e.foo); // baz
  console.error(e.message); // bazMessage
  console.error(e.stack); // stacktrace
}
```

== Loops and iteration

=== For

* A `for` loop repeats until a specified condition evaluates to false. The JavaScript for loop is similar to the Java and C `for` loop.
+
```js
// similar to the Java and C for loop.
for (initialization; condition; afterthought)
  statement
```
+
```js
for (let i = 0; i < 3; i++) {
  console.log(i);
}
// 0
// 1
// 2
```

* The `for...in` statement iterates a specified variable over all the enumerable properties of an object. For each distinct property, JavaScript executes the specified statements.
+
```js
for (variable in object)
  statement
```
+
```js
const car = { make: "Ford", model: "Mustang" };
for (const p in car) {
  console.log(`car.${p} = ${car[p]}`);
}
// car.make = Ford
// car.model = Mustang
```
+
Although it may be tempting to use this as a way to iterate over Array elements, the `for...in` statement will return the name of the user-defined properties in addition to the numeric indexes.
+
```js
const nums = [3, 4, 5];
nums.foo = 'bar';
for (const idx in nums) {
  console.log(`nums[${idx}] = ${nums[idx]}`);
}
// nums[0] = 3
// nums[1] = 4
// nums[2] = 5
// nums[foo] = bar
```

* The `for...of` statement creates a loop Iterating over https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols[iterable objects] (including `Array`, `Map`, `Set`, `arguments` object and so on), invoking a custom iteration hook with statements to be executed for the value of each distinct property. 
+
```js
for (variable of object)
  statement
```
+
```js
const nums = [3, 4, 5];
nums.foo = 'bar';
for (const num of nums) {
  console.log(num);
}
// 3
// 4
// 5
```

* The `for...of` and `for...in` statements can also be used with https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment[destructuring].
+
```js
const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2
```

=== While

* The `while` statement executes its statements as long as a specified condition evaluates to `true`.
+
```js
while (condition)
  statement
```
+
```js
let i = 0;
while (i < 3) {
  console.log(i);
  i++;
}
// 0
// 1
// 2
```

* The `do...while` statement repeats until a specified condition evaluates to false. 
+
```js
do
  // statement is always executed once before the condition is checked.
  statement
while (condition);
```
+
```js
let i = 0;
do {
  console.log(i);
  i++;
} while(i < 3)
// 0
// 1
// 2
```

=== Label, break, continue

* A `label` provides a statement with an identifier that lets you refer to it elsewhere in your program. 
+
```js
label:
  statement
```

*  Use the `break` statement to terminate a loop, `switch`, or in conjunction with a labeled statement.
+
--
** When you use `break` without a label, it terminates the innermost enclosing `while`, `do-while`, `for`, or `switch` immediately and transfers control to the following statement.
** When you use `break` with a label, it terminates the specified labeled statement.
--
+
```js
break;
break label;
```
+
```js
let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

* The `continue` statement can be used to restart a `while`, `do-while`, `for`, or `label` statement.
+
--
** When you use `continue` without a label, it terminates the current iteration of the innermost enclosing `while`, `do-while`, or `for` statement and continues execution of the loop with the next iteration.
+
In contrast to the `break` statement, `continue` does not terminate the execution of the loop entirely.
+
In a `while` loop, it jumps back to the condition.
+
In a `for` loop, it jumps to the `increment-expression`.

** When you use `continue` with a label, it applies to the looping statement identified with that label.
--
+
```js
continue;
continue label;
```
+
```js
let i = 0;
let j = 10;
checkiandj: while (i < 4) {
  console.log(i);
  i += 1;
  checkj: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue checkj;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

== Functions

* A *function definition* (also called a *function declaration*, or *function statement*) consists of the `function` keyword, followed by:
+
--
** The name of the function.

** A list of parameters to the function, enclosed in parentheses and separated by commas.
+
*** Parameters are essentially passed to functions by value.
*** When pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function.

** The JavaScript statements that define the function, enclosed in curly braces, `{ /* … */ }`.
--
+
```js
function square(number) {
  return number * number;
}
```

* The `function` keyword can be used to define a function inside an https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function[expression].
+
--
** Such a function can be *anonymous*; it does not have to have a name.
+
```js
const square = function (number) {
  return number * number;
};

console.log(square(4)); // 16
```

** Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:
+
```js
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6
```

** Function expressions are convenient when passing a function as an argument to another function.
+
```js
const nums = [1, 3, 5];
const square = nums.map(function(num) { return num * num});
console.log(square.join()); // 1,9,25
```
--

* Use the https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function[Function] constructor to create functions from a string at runtime, much like `eval()`.
+
```js
const sum = new Function('a', 'b', 'console.log(a + b)');
sum(2, 6); // 8
```
+
[TIP]
====
The `call()` and `apply()` methods of the Function object can also be used to call functions.

```js
sum.call(null, 1, 1); // 2
sum.apply(null, [1, 1]); // 2
```
====

* A *method* is a function that is a property of an object.
+
```js
const car = {
  make: "Ford",
  model: "Mustang",
  greet() { console.log(`${this.make}, ${this.model}`) }
};
car.greet(); // Ford, Mustang
```

* JavaScript interpreter *hoists* the entire function _declaration_ — not with function _expressions_ to the top of the current scope.
+
```js
console.log(square(5)); // 25

function square(n) {
  return n * n;
}
```
+
```js
console.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
```

* A function that calls itself is called a *recursive function*. There are three ways for a function to refer to itself:
+
--
** The function's name
** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee[arguments.callee]
** An in-scope variable that refers to the function
--
+
```js
const foo = function bar() {
  // statements go here

  // bar()
  // arguments.callee()
  // foo()
};
```

* A function can be nested within another function, which forms a *closure*. The nested (inner) function is private to its containing (outer) function.
+
```js
function outside(x) {
  function inside(y) {
    return x + y;
  }
  return inside;
}

const fnInside = outside(3); // Think of it like: give me a function that adds 3 to whatever you give it
console.log(fnInside(5)); // 8
console.log(outside(3)(5)); // 8
```
+
TIP: A closure is an expression (most commonly, a function) that can have free variables together with an environment that binds those variables (that "closes" the expression).
+
TIP: A closure must preserve the arguments and variables in all scopes it references. Since each call provides potentially different arguments, a new closure is created for each call to `outside`. The memory can be freed only when the returned `inside` is no longer accessible.

* When two arguments or variables in the scopes (_scope chaning_) of a closure have the same name, the more nested scopes take precedence.
+
```js
function outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)
```

* Creating closures in loops: a common mistake
+
```js
const funcs = [];
for (var i = 0; i < 3; i++) { // var-based index
  funcs.push(function () { console.log(i); });
  // solution: using the scope chaining to override the outer variable.
  // funcs.push(function (i) { return function () { console.log(i); } }(i));
}
for(const func of funcs) {
  func();
}
// 3
// 3
// 3
```
+
```js
const funcs = [];
for (let i = 0; i < 3; i++) { // let-based index
  funcs.push(function () { console.log(i); });
}
for(const func of funcs) {
  func();
}
// 0
// 1
// 2
```

* The `arguments` of a function are maintained in an array-like object, but not an array.
+
It is array-like in that it has a numbered index and a `length` property. However, it does not possess all of the array-manipulation methods.
+
Using the `arguments` object, you can call a function with more arguments than it is formally declared to accept.
+
```js
function seq() {
  console.log(arguments.length);
  for (const arg of arguments) {
    console.log(arg);
  }
}
seq(0, 1, 2);
// 3
// 0
// 1
// 2
```

* In JavaScript, parameters of functions default to `undefined`. However, in some situations it might be useful to set a different default value. This is exactly what https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters[default parameters] do.
+
```js
// function multiply(a, b) {
//   b = typeof b !== "undefined" ? b : 1;
//   return a * b;
// }
// With default parameters, a manual check in the function body is no longer necessary. 
function multiply(a, b = 1) {
  return a * b;
}
console.log(multiply(5)); // 5
```

* The https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters[rest parameter] (i.e., https://en.wikipedia.org/wiki/Variadic_function[variadic]) syntax allows us to represent an indefinite number of arguments as an array.
+
```js
function multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}
const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
```

* An https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions[arrow function expression] (also called a _fat arrow_ to distinguish from a hypothetical `+++->+++` syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own `this`, `arguments`, `super`, or `new.target`.
+
--
** Arrow functions are always anonymous.
** Two factors influenced the introduction of arrow functions: _shorter functions_ and _non-binding_ of `this`.
--
+
```js
const a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length); // shorter functions

console.log(a3); // [8, 6, 7, 9]
```
+
** Until arrow functions, every new function defined its own `this` value (a new object in the case of a constructor, undefined in https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode[strict mode] function calls, the base object if the function is called as an "object method", etc.). 
+
```js
function Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}
```
+
** In ECMAScript 3/5, this issue was fixed by assigning the value in `this` to a variable that could be closed over.
+
```js
// ECMAScript 3/5 closures
function Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}
```
+
** Alternatively, a https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind[bound function] could be created so that the proper `this` value would be passed to the `growUp()` function.
+
```js
function Person() {
  this.age = 0;

  setInterval(function growUp() {
    this.age++;
  }.bind(this), 1000);
}
```
+
** An arrow function does not have its own `this`; the `this` value of the enclosing execution context is used.
+
```js
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}
```








== References

* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide
