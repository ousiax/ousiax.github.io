= JavaScript Learning Notes
:page-layout: post
:page-categories: ['javascript']
:page-tags: ['javascript', 'js']
:page-date: 2024-04-15 13:40:59 +0800
:page-revdate: 2024-04-15 13:40:59 +0800
:toc: preamble
:toclevels: 4
:sectnums:
:sectnumlevels: 4

JavaScript is a cross-platform, object-oriented scripting language. The core language of JavaScript is standardized by the ECMA TC39 committee as a language named ECMAScript.

TIP: "ECMAScript" is the term for the language standard, but "ECMAScript" and "JavaScript" can be used interchangeably.

TIP: The https://www.ecma-international.org/[ECMAScript specification] does not describe the Document Object Model (DOM), which is standardized by the https://www.w3.org/[World Wide Web Consortium (W3C)] and/or https://whatwg.org/[WHATWG (Web Hypertext Application Technology Working Group)].

Among other things, ECMAScript defines:

* Language syntax (parsing rules, keywords, control flow, object literal initialization, ...)
* Error handling mechanisms (`throw`, `try...catch`, ability to create user-defined `Error` types)
* Types (`boolean`, `number`, `string`, `function`, `object`, ...)
* A prototype-based inheritance mechanism
* Built-in objects and functions, including `JSON`, `Math`, `Array` methods, `parseInt`, `decodeURI`, etc.
* Strict mode
* A module system
* Basic memory model

== Grammar and types

JavaScript is *case-sensitive* and uses the *Unicode* character set.

```js
const Hello世界 = 'Hello World!';
console.log(Hello世界); // logs "Hello World!"
console.log(hello世界); // Uncaught ReferenceError: hello世界 is not defined
```

A semicolon (`;`) is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they MUST be separated by semicolons.

```js
const Hello世界 = 'Hello World!'; console.log(Hello世界) // logs "Hello World!"
```

The syntax of comments is the same as in C++ and in many other languages:

```js
// a one line comment

/* this is a longer,
 * multi-line comment
 */

```

JavaScript has three kinds of variable declarations.

* `var`
+
Declares both local and global variables, depending on the execution context, optionally initializing it to a value.

* `let`
+
Declares a block-scoped, local variable, optionally initializing it to a value.

* `const`
+
Declares a block-scoped, read-only named constant.

TIP: Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an *undeclared global* variable.

If a variable is declared without an initializer, it is assigned the value `undefined`.

```js
let x;
console.log(x); // logs "undefined"
```

A variable may belong to one of the following scopes:

* Global scope: The default scope for all code running in script mode.
* Module scope: The scope for code running in module mode.
* Function scope: The scope created with a function.
* Block scope: The scope created (`let`, `const`) with a pair of curly braces (a https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block[block]).

When you declare a variable outside of any function, it is called a *global variable*, because it is available to any other code in the current document. When you declare a variable within a function, it is called a *local variable*, because it is available only within that function.

* Global variables are in fact properties of the global object.

* In web pages, the global object is https://developer.mozilla.org/en-US/docs/Web/API/Window[window], so you can read and set global variables using the `window.variable` syntax.

* In all environments, the https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis[globalThis] variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.

Blocks only scope `let` and `const` declarations, but not `var` declarations.

```js
{
  var x = 1;
}
console.log(x); // 1
```

```js
{
  const x = 1;
}
console.log(x); // ReferenceError: x is not defined
```

`var`-declared variables are https://developer.mozilla.org/en-US/docs/Glossary/Hoisting[hoisted], meaning the variable can be referred anywhere in its scope, even if its declaration isn't reached yet.

```js
console.log(x === undefined); // true
var x = 3;
```

Same as:

```js
var x;
console.log(x === undefined); // true
x = 3;
```

The latest ECMAScript standard defines eight data types:

:Boolean: https://developer.mozilla.org/en-US/docs/Glossary/Boolean
:Null: https://developer.mozilla.org/en-US/docs/Glossary/Null
:Undefined: https://developer.mozilla.org/en-US/docs/Glossary/Undefined
:Number: https://developer.mozilla.org/en-US/docs/Glossary/Number
:BigInt: https://developer.mozilla.org/en-US/docs/Glossary/BigInt
:String: https://developer.mozilla.org/en-US/docs/Glossary/String
:Symbol: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol
:Object: https://developer.mozilla.org/en-US/docs/Glossary/Object

* Seven data types that are primitives:
 . {Boolean}[Boolean]. `true` and `false`.
 . {Null}[null]. A special keyword denoting a null value. (Because JavaScript is case-sensitive, `null` is not the same as `Null`, `NULL`, or any other variant.)
 . {Undefined}[undefined]. A top-level property whose value is not defined.
 . {Number}[Number]. An integer or floating point number. For example: `42` or `3.14159`.
 . {BigInt}[BigInt]. An integer with arbitrary precision. For example: `9007199254740992n`.
 . {String}[String]. A sequence of characters that represent a text value. For example: `"Howdy"`.
 . {Symbol}[Symbol]. A data type whose instances are unique and immutable.
* and {Object}[Object]

JavaScript is a *dynamically typed language*, which means that data types are automatically converted as-needed during script execution.

```js
let answer = 42;
answer = "Thanks for all the fish!";

x = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"

"37" - 7; // 30
"37" * 7; // 259

// An alternative method of retrieving a number from a string is with the `+` (unary plus) operator:
// Note: the parentheses are added for clarity, not required.
"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
```

An *array literal* is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets (`[]`).

```js
const coffees = ["French Roast", "Colombian", "Kona"];
```

* If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the fish array:
+
```js
const fish = ["Lion", /* empty */, "Angel"];
console.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]
```
+
Note that the second item is "empty", which is not exactly the same as the actual `undefined` value. When using array-traversing methods like `Array.prototype.map`, empty slots are skipped. However, index-accessing `fish[1]` still returns `undefined`.
+
```js
const fish = ["Lion", /* empty */, "Angel"];
fish.map(x => console.log(x));
// Lion
// Angel
```

* If you include a trailing comma at the end of the list of elements, the comma is ignored.
+
```js
// Only the last comma is ignored.
const myList = ["home", /* empty */, "school", /* empty */,];
```

*Integer and BigInt literals* can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

* A _decimal_ integer literal is a sequence of digits without a leading `0` (zero).

* A leading `0` (zero) on an integer literal, or a leading `0o` (or `0O`) indicates it is in _octal_.

* A leading `0x` (or `0X`) indicates a _hexadecimal_ integer literal.

* A leading `0b` (or `0B`) indicates a _binary_ integer literal.

* A trailing `n` suffix on an integer literal indicates a _BigInt_ literal. The BigInt literal can use any of the above bases. Note that leading-zero octal syntax like `0123n` is not allowed, but `0o123n` is fine.
+
```js
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)
```

A *floating-point literal* can have the following parts:

```js
[digits].[digits][(E|e)[(+|-)]digits]
```

* An unsigned decimal integer,
* A decimal point (`.`),
* A fraction (another decimal number),
* An exponent (`e` or `E`).
+
```js
3.1415926
.123456789
-.123456789 // -0.123456789
3.1E+12
.1e-23
```

NOTE: Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like `-123.4` are fine, being interpreted as a unary `-` operator applied to the numeric literal `123.4`.

An *object literal* is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`).

* Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript https://developer.mozilla.org/en-US/docs/Glossary/Identifier[identifier] or number, it must be enclosed in quotes.

* Property names that are not valid identifiers cannot be accessed as a dot (`.`) property.
+
```js
const unusualPropertyNames = {
  '': 'An empty string',
  '!': 'Bang!'
}
console.log(unusualPropertyNames.'');   // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!);    // SyntaxError: Unexpected token !
```

* Instead, they must be accessed with the bracket notation (`[]`).
+
```js
console.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!
```

* Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for `foo: foo` assignments, defining methods, making `super` calls, and computing property names with expressions.
+
```js
const obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return "d " + super.toString();
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
```

A https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions[*regex*] *literal* is a pattern enclosed between slashes: `/pattern/flags`.

```js
const re1 = /ab+c/; // new RegExp("ab+c");
const re2 = /\w+\s/g; // new RegExp("\\w+\\s", "g");
```

A *string literal* is zero or more characters enclosed in double (`"`) or single (`'`) quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).

```js
'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"
"He read \"The Cremation of Sam McGee\" by R.W. Service.";
```

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals[*Template literals*] are literals delimited with backtick (```) characters, allowing for _multi-line strings_, _string interpolation_ with embedded expressions, and special constructs called _tagged templates_.

```js
`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tagFunction`string text ${expression} string text`
```

== Control flow and error handling

The most basic statement is a *block statement*, which is used to group statements. The block is delimited by a pair of curly braces:

```js
{
  statement1;
  statement2;
  // …
  statementN;
}
```

A *conditional statement* is a set of commands that executes if a specified condition is true.

The following values evaluate to false (also known as https://developer.mozilla.org/en-US/docs/Glossary/Falsy[Falsy] values):

* `false`
* `undefined`
* `null`
* `0`
* `NaN`
* the empty string (`""`)

All other values—including all objects—evaluate to `true` when passed to a conditional statement.

[NOTE]
====
Note: Do not confuse the primitive boolean values `true` and `false` with the true and false values of the `Boolean` object!

For example:

```js
const b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}
```
====

JavaScript supports two conditional statements: `if...else` and `switch`.

* Use the `if` statement to execute a statement if a logical condition is `true`. Use the optional `else` clause to execute a statement if the condition is `false`. Use the optional `else if` to have multiple conditions tested in sequence. 
+
```js
if (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}
```

* A `switch` statement allows a program to evaluate an expression and attempt to match the expression's value to a `case` label. If a match is found, the program executes the associated statement. 
+
```js
switch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}
```

Use the `throw` statement to throw an exception. A throw statement specifies the value to be thrown:

```js
throw expression;
```

```js
throw "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
throw new Error("Whoops!");
```

While it is common to throw numbers or strings as https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error[errors], it is frequently more effective to use one of the exception types specifically created for this purpose: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#error_types[ECMAScript exceptions] and https://developer.mozilla.org/en-US/docs/Web/API/DOMException[DOMException].

The `try...catch` statement marks a block of statements to try, and specifies one or more responses should an exception be thrown. If an exception is thrown, the `try...catch` statement catches it. The `finally` block executes after the try and catch blocks execute but before the statements following the `try...catch` statement. 

* Throwing a generic error
+
```js
try {
  throw new Error("Whoops!");
} catch (e) {
  console.error(`${e.name}: ${e.message}`);
}
```

* Handling a specific error type
+
```js
try {
  foo.bar();
} catch (e) {
  if (e instanceof EvalError) {
    console.error(`${e.name}: ${e.message}`);
  } else if (e instanceof RangeError) {
    console.error(`${e.name}: ${e.message}`);
  }
  // etc.
  else {
    // If none of our cases matched leave the Error unhandled
    throw e;
  }
}
```

* Using `finally` ensures that the file is never left open, even if an error occurs. 
+
```js
openMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}
```

* If the `finally` block returns a value, this value becomes the return value of the entire `try…catch…finally` production, regardless of any `return` statements in the `try` and `catch` blocks: 
+
```js
function f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    console.log(4); // not reachable
  }
  // "return false" is executed now
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false
```

* Overwriting of return values by the `finally` block also applies to exceptions thrown or re-thrown inside of the `catch` block: 
+
```js
function f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
  }
  // "return false" is executed now
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false
```

* Custom https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error[error] types
+
```js
class CustomError extends Error {
  constructor(foo = "bar", ...params) {
    // Pass remaining arguments (including vendor specific ones) to parent constructor
    super(...params);

    // Maintains proper stack trace for where our error was thrown (only available on V8)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CustomError);
    }

    this.name = "CustomError";
    // Custom debugging information
    this.foo = foo;
    this.date = new Date();
  }
}

try {
  throw new CustomError("baz", "bazMessage");
} catch (e) {
  console.error(e.name); // CustomError
  console.error(e.foo); // baz
  console.error(e.message); // bazMessage
  console.error(e.stack); // stacktrace
}
```

== Loops and iteration

=== For

* A `for` loop repeats until a specified condition evaluates to false. The JavaScript for loop is similar to the Java and C `for` loop.
+
```js
// similar to the Java and C for loop.
for (initialization; condition; afterthought)
  statement
```
+
```js
for (let i = 0; i < 3; i++) {
  console.log(i);
}
// 0
// 1
// 2
```

* The `for...in` statement iterates a specified variable over all the enumerable properties of an object. For each distinct property, JavaScript executes the specified statements.
+
```js
for (variable in object)
  statement
```
+
```js
const car = { make: "Ford", model: "Mustang" };
for (const p in car) {
  console.log(`car.${p} = ${car[p]}`);
}
// car.make = Ford
// car.model = Mustang
```
+
Although it may be tempting to use this as a way to iterate over Array elements, the `for...in` statement will return the name of the user-defined properties in addition to the numeric indexes.
+
```js
const nums = [3, 4, 5];
nums.foo = 'bar';
for (const idx in nums) {
  console.log(`nums[${idx}] = ${nums[idx]}`);
}
// nums[0] = 3
// nums[1] = 4
// nums[2] = 5
// nums[foo] = bar
```

* The `for...of` statement creates a loop Iterating over https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols[iterable objects] (including `Array`, `Map`, `Set`, `arguments` object and so on), invoking a custom iteration hook with statements to be executed for the value of each distinct property. 
+
```js
for (variable of object)
  statement
```
+
```js
const nums = [3, 4, 5];
nums.foo = 'bar';
for (const num of nums) {
  console.log(num);
}
// 3
// 4
// 5
```

* The `for...of` and `for...in` statements can also be used with https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment[destructuring].
+
```js
const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2
```

=== While

* The `while` statement executes its statements as long as a specified condition evaluates to `true`.
+
```js
while (condition)
  statement
```
+
```js
let i = 0;
while (i < 3) {
  console.log(i);
  i++;
}
// 0
// 1
// 2
```

* The `do...while` statement repeats until a specified condition evaluates to false. 
+
```js
do
  // statement is always executed once before the condition is checked.
  statement
while (condition);
```
+
```js
let i = 0;
do {
  console.log(i);
  i++;
} while(i < 3)
// 0
// 1
// 2
```

=== Label, break, continue

* A `label` provides a statement with an identifier that lets you refer to it elsewhere in your program. 
+
```js
label:
  statement
```

*  Use the `break` statement to terminate a loop, `switch`, or in conjunction with a labeled statement.
+
--
** When you use `break` without a label, it terminates the innermost enclosing `while`, `do-while`, `for`, or `switch` immediately and transfers control to the following statement.
** When you use `break` with a label, it terminates the specified labeled statement.
--
+
```js
break;
break label;
```
+
```js
let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

* The `continue` statement can be used to restart a `while`, `do-while`, `for`, or `label` statement.
+
--
** When you use `continue` without a label, it terminates the current iteration of the innermost enclosing `while`, `do-while`, or `for` statement and continues execution of the loop with the next iteration.
+
In contrast to the `break` statement, `continue` does not terminate the execution of the loop entirely.
+
In a `while` loop, it jumps back to the condition.
+
In a `for` loop, it jumps to the `increment-expression`.

** When you use `continue` with a label, it applies to the looping statement identified with that label.
--
+
```js
continue;
continue label;
```
+
```js
let i = 0;
let j = 10;
checkiandj: while (i < 4) {
  console.log(i);
  i += 1;
  checkj: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue checkj;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

== Functions

* A *function definition* (also called a *function declaration*, or *function statement*) consists of the `function` keyword, followed by:
+
--
** The name of the function.

** A list of parameters to the function, enclosed in parentheses and separated by commas.
+
*** Parameters are essentially passed to functions by value.
*** When pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function.

** The JavaScript statements that define the function, enclosed in curly braces, `{ /* … */ }`.
--
+
```js
function square(number) {
  return number * number;
}
```

* The `function` keyword can be used to define a function inside an https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function[expression].
+
--
** Such a function can be *anonymous*; it does not have to have a name.
+
```js
const square = function (number) {
  return number * number;
};

console.log(square(4)); // 16
```

** Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:
+
```js
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6
```

** Function expressions are convenient when passing a function as an argument to another function.
+
```js
const nums = [1, 3, 5];
const square = nums.map(function(num) { return num * num});
console.log(square.join()); // 1,9,25
```
--

* Use the https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function[Function] constructor to create functions from a string at runtime, much like `eval()`.
+
```js
const sum = new Function('a', 'b', 'console.log(a + b)');
sum(2, 6); // 8
```
+
[TIP]
====
The `call()` and `apply()` methods of the Function object can also be used to call functions.

```js
sum.call(null, 1, 1); // 2
sum.apply(null, [1, 1]); // 2
```
====

* A *method* is a function that is a property of an object.
+
```js
const car = {
  make: "Ford",
  model: "Mustang",
  greet() { console.log(`${this.make}, ${this.model}`) }
};
car.greet(); // Ford, Mustang
```

* JavaScript interpreter *hoists* the entire function _declaration_ — not with function _expressions_ to the top of the current scope.
+
```js
console.log(square(5)); // 25

function square(n) {
  return n * n;
}
```
+
```js
console.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
```

* A function that calls itself is called a *recursive function*. There are three ways for a function to refer to itself:
+
--
** The function's name
** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee[arguments.callee]
** An in-scope variable that refers to the function
--
+
```js
const foo = function bar() {
  // statements go here

  // bar()
  // arguments.callee()
  // foo()
};
```

* A function can be nested within another function, which forms a *closure*. The nested (inner) function is private to its containing (outer) function.
+
```js
function outside(x) {
  function inside(y) {
    return x + y;
  }
  return inside;
}

const fnInside = outside(3); // Think of it like: give me a function that adds 3 to whatever you give it
console.log(fnInside(5)); // 8
console.log(outside(3)(5)); // 8
```
+
TIP: A closure is an expression (most commonly, a function) that can have free variables together with an environment that binds those variables (that "closes" the expression).
+
TIP: A closure must preserve the arguments and variables in all scopes it references. Since each call provides potentially different arguments, a new closure is created for each call to `outside`. The memory can be freed only when the returned `inside` is no longer accessible.

* When two arguments or variables in the scopes (_scope chaning_) of a closure have the same name, the more nested scopes take precedence.
+
```js
function outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)
```

* Creating closures in loops: a common mistake
+
```js
const funcs = [];
for (var i = 0; i < 3; i++) { // var-based index
  funcs.push(function () { console.log(i); });
  // solution: using the scope chaining to override the outer variable.
  // funcs.push(function (i) { return function () { console.log(i); } }(i));
}
for(const func of funcs) {
  func();
}
// 3
// 3
// 3
```
+
```js
const funcs = [];
for (let i = 0; i < 3; i++) { // let-based index
  funcs.push(function () { console.log(i); });
}
for(const func of funcs) {
  func();
}
// 0
// 1
// 2
```

* The `arguments` of a function are maintained in an array-like object, but not an array.
+
It is array-like in that it has a numbered index and a `length` property. However, it does not possess all of the array-manipulation methods.
+
Using the `arguments` object, you can call a function with more arguments than it is formally declared to accept.
+
```js
function seq() {
  console.log(arguments.length);
  for (const arg of arguments) {
    console.log(arg);
  }
}
seq(0, 1, 2);
// 3
// 0
// 1
// 2
```

* In JavaScript, parameters of functions default to `undefined`. However, in some situations it might be useful to set a different default value. This is exactly what https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters[default parameters] do.
+
```js
// function multiply(a, b) {
//   b = typeof b !== "undefined" ? b : 1;
//   return a * b;
// }
// With default parameters, a manual check in the function body is no longer necessary. 
function multiply(a, b = 1) {
  return a * b;
}
console.log(multiply(5)); // 5
```

* The https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters[rest parameter] (i.e., https://en.wikipedia.org/wiki/Variadic_function[variadic]) syntax allows us to represent an indefinite number of arguments as an array.
+
```js
function multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}
const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
```

* An https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions[arrow function expression] (also called a _fat arrow_ to distinguish from a hypothetical `+++->+++` syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own `this`, `arguments`, `super`, or `new.target`.
+
--
** Arrow functions are always anonymous.
** Two factors influenced the introduction of arrow functions: _shorter functions_ and _non-binding_ of `this`.
--
+
```js
const a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length); // shorter functions

console.log(a3); // [8, 6, 7, 9]
```
+
** Until arrow functions, every new function defined its own `this` value (a new object in the case of a constructor, undefined in https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode[strict mode] function calls, the base object if the function is called as an "object method", etc.). 
+
```js
function Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}
```
+
** In ECMAScript 3/5, this issue was fixed by assigning the value in `this` to a variable that could be closed over.
+
```js
// ECMAScript 3/5 closures
function Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}
```
+
** Alternatively, a https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind[bound function] could be created so that the proper `this` value would be passed to the `growUp()` function.
+
```js
function Person() {
  this.age = 0;

  setInterval(function growUp() {
    this.age++;
  }.bind(this), 1000);
}
```
+
** An arrow function does not have its own `this`; the `this` value of the enclosing execution context is used.
+
```js
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}
```

== Expressions and operators

```js
operand1 operator operand2 // infix binary operator, e.g., 3 + 4 or x * y
operator operand           // prefix unary operator, e.g., ++x
operand operator           // postfix unary operator, e.g., x++
```

=== Assignment operators

An assignment operator assigns a value to its left operand based on the value of its right operand. The simple assignment operator is equal (`=`), which assigns the value of its right operand to its left operand. There are also https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators#assignment_operators[compound assignment operators] that are shorthand for the operations.

```js
x = f()      // x = f()
x += f()     // x = x + f()
x -= f()     // x = x - f()
x *= f()     // x = x * f()
x /= f()     // x = x / f()
x %= f()     // x = x % f()
x **= f()    // x = x ** f()
x <<= f()    // x = x << f()
x >>= f()    // x = x >> f()
x >>>= f()   // x = x >>> f()
x &= f()     // x = x & f()
x ^= f()     // x = x ^ f()
x |= f()     // x = x | f()
x &&= f()    // x && (x = f())
x ||= f()    // x || (x = f())
x ??= f()    // x ?? (x = f())
```

==== Assigning to properties

* If an expression evaluates to an object, then the left-hand side of an assignment expression may make assignments to properties of that expression.
+
```js
const obj = {};

obj.x = 3;
console.log(obj.x); // Prints 3.
console.log(obj); // Prints { x: 3 }.

const key = "y";
obj[key] = 5;
console.log(obj[key]); // Prints 5.
console.log(obj); // Prints { x: 3, y: 5 }.
```

* If an expression does not evaluate to an object, then assignments to properties of that expression do not assign:
+
```js
const val = 0;
val.x = 3;

console.log(val.x); // Prints undefined.
console.log(val); // Prints 0.
```
+
In strict mode, the code above throws, because one cannot assign properties to primitives.
+
```js
"use strict"
const val = 0;
val.x = 3; // Uncaught TypeError: can't assign to property "x" on 0: not an object
```

==== Destructuring

The https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment[destructuring assignment] syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and object literals.

* Without destructuring, it takes multiple statements to extract values from arrays and objects:
+
```js
const foo = ["one", "two", "three"];

const one = foo[0];
const two = foo[1];
const three = foo[2];
```

* With destructuring, you can extract multiple values into distinct variables using a single statement:
+
```js
const [one, two, three] = foo;
```

==== Evaluation and nesting

In general, assignments are used within a variable declaration (i.e., with `const`, `let`, or `var`) or as standalone statements.

```js
// Declares a variable x and initializes it to the result of f().
// The result of the x = f() assignment expression is discarded.
let x = f();

x = g(); // Reassigns the variable x to the result of g().
```

However, like other expressions, assignment expressions like `x = f()` evaluate into a result value. Although this result value is usually not used, it can then be used by another expression. 

By chaining or nesting an assignment expression, its result can itself be assigned to another variable. It can be logged, it can be put inside an array literal or function call, and so on.

```js
let x;
const y = (x = f()); // Or equivalently: const y = x = f();
console.log(y); // Logs the return value of the assignment x = f().

console.log(x = f()); // Logs the return value directly.

// An assignment expression can be nested in any place
// where expressions are generally allowed,
// such as array literals' elements or as function calls' arguments.
console.log([0, x = f(), 0]);
console.log(f(0, x = f(), 0));
```

*Avoid assignment chains*

Chaining assignments or nesting assignments in other expressions can result in surprising behavior. For this reason, https://github.com/airbnb/javascript/blob/master/README.md#variables--no-chain-assignment[chaining assignments in the same statement is discouraged].

In particular, putting a variable chain in a `const`, `let`, or `var` statement often does not work. Only the outermost/leftmost variable would get declared; other variables within the assignment chain are not declared by the `const/let/var` statement.

```js
const z = y = x = f();
```

This statement seemingly declares the variables `x`, `y`, and `z`. However, it only actually declares the variable `z`. `y` and `x` are either invalid references to nonexistent variables (in strict mode) or, worse, would implicitly create global variables for `x` and `y` in sloppy mode.

```js
// "use strict"
{ const z = y = x = Math.PI; }
console.log(x, y); // 3.141592653589793 3.141592653589793
console.log(z);    // Uncaught ReferenceError: z is not defined
```

```js
"use strict"
{ const z = y = x = Math.PI; } // Uncaught ReferenceError: assignment to undeclared variable x
```

==== Comparison operators

* The *strict equality* (`===`) operator checks whether its two operands are equal, returning a Boolean result. Unlike the equality (`==`) operator, the strict equality operator always considers operands of different types to be different. See also https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is[Object.is] and https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness[sameness in JS].
+
```js
console.log(1 === 1);
// Expected output: true

console.log('hello' === 'hello');
// Expected output: true

console.log('1' === 1);
// Expected output: false

console.log(0 === false);
// Expected output: false
```
+
```js
console.log(1 == 1);
// Expected output: true

console.log('hello' == 'hello');
// Expected output: true

console.log('1' == 1);
// Expected output: true

console.log(0 == false);
// Expected output: true
```

* The *strict inequality* (`!==`) operator checks whether its two operands are not equal, returning a Boolean result. Unlike the inequality (`!=`) operator, the strict inequality operator always considers operands of different types to be different. 
+
```js
console.log(1 !== 1);
// Expected output: false

console.log('hello' !== 'hello');
// Expected output: false

console.log('1' !== 1);
// Expected output: true

console.log(0 !== false);
// Expected output: true
```
+
```js
console.log(1 != 1);
// Expected output: false

console.log('hello' != 'hello');
// Expected output: false

console.log('1' != 1);
// Expected output: false

console.log(0 != false);
// Expected output: false
```

==== Arithmetic operators

In addition to the standard arithmetic operations (`\+`, `-`, `\*`, `/`), JavaScript provides also the arithmetic operators: `%`, `++`, `--`, `-`, `+`, `**`.

NOTE: division by zero produces https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity[Infinity].

==== Bitwise operators

A bitwise operator treats their operands as a set of 32 bits (zeros and ones), rather than as decimal, hexadecimal, or octal numbers.

* `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`

* The operands are converted to thirty-two-bit integers and expressed by a series of bits (zeros and ones). Numbers with more than 32 bits get their most significant bits discarded. For example, the following integer with more than 32 bits will be converted to a 32-bit integer:
+
```txt
Before: 1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001
After:                 1010 0000 0000 0000 0110 0000 0000 0001
```

* The bitwise shift operators take two operands: the first is a quantity to be shifted, and the second specifies the number of bit positions by which the first operand is to be shifted. The direction of the shift operation is controlled by the operator used.

* Shift operators convert their operands to thirty-two-bit integers and return a result of either type `Number` or `BigInt`: specifically, if the type of the left operand is `BigInt`, they return `BigInt`; otherwise, they return `Number`. 

==== Logical operators

* Logical operators are typically used with Boolean (logical) values; when they are, they return a Boolean value.

* The `&&` and `||` operators actually return the value of one of the specified operands, so if these operators are used with non-Boolean values, they may return a non-Boolean value. 
+
```js
const a1 = true && true; // t && t returns true
const a2 = true && false; // t && f returns false
const a3 = false && true; // f && t returns false
const a4 = false && 3 === 4; // f && f returns false
const a5 = "Cat" && "Dog"; // t && t returns Dog
const a6 = false && "Cat"; // f && t returns false
const a7 = "Cat" && false; // t && f returns false
```
+
```js
const o1 = true || true; // t || t returns true
const o2 = false || true; // f || t returns true
const o3 = true || false; // t || f returns true
const o4 = false || 3 === 4; // f || f returns false
const o5 = "Cat" || "Dog"; // t || t returns Cat
const o6 = false || "Cat"; // f || t returns Cat
const o7 = "Cat" || false; // t || f returns Cat
```

* As logical expressions are evaluated left to right, they are tested for possible "*short-circuit*" evaluation using the following rules:
+
--
** `false && anything` is short-circuit evaluated to false.
** `true || anything` is short-circuit evaluated to true.
--

* The *nullish coalescing* (`??`) operator is a logical operator that returns its right-hand side operand when its left-hand side operand is `null` or `undefined`, and otherwise returns its left-hand side operand. 
+
```js
const foo = null ?? 'default string';
console.log(foo);
// Expected output: "default string"

const baz = 0 ?? 42;
console.log(baz);
// Expected output: 0
```

==== Conditional (ternary) operator

The conditional operator is the only JavaScript operator that takes three operands. The operator can have one of two values based on a condition. The syntax is:

```js
condition ? val1 : val2
```

==== Comma operator

The comma operator (`,`) evaluates both of its operands and returns the value of the last operand.

* This operator is primarily used inside a for loop, to allow multiple variables to be updated each time through the loop.

* It is regarded bad style to use it elsewhere, when it is not necessary. Often two separate statements can and should be used instead. 

```js
const x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const a = [x, x, x, x, x];

for (let i = 0, j = 9; i <= j; i++, j--) {
  //                              ^
  console.log(`a[${i}][${j}]= ${a[i][j]}`);
}
```

==== Unary operators

* The `delete` operator removes a property from an object. If the property's value is an object and there are no more references to the object, the object held by that property is eventually released automatically.
+
```js
delete object.property
delete object[property]
```
+
```js
const car = { make: "Ford", model: "Mustang" };
delete car.make;
console.log(car); // { model: "Mustang" }
```
+
```js
const nums = [0, 1, 2, 3];
delete nums[1];
console.log(nums); // [ 0, <1 empty slot>, 2, 3 ]
```

* The `typeof` operator returns a string indicating the type of the unevaluated operand. operand is the string, variable, keyword, or object for which the type is to be returned. The parentheses are optional. 
+
```js
typeof new Function("5 + 2"); // "function"
typeof "round"; // "string"
typeof 1; // "number"
typeof ["Apple", "Mango", "Orange"]; // "object"
typeof new Date(); // "object"
typeof true; // "boolean"
typeof {}; // "boolean"
typeof /ab+c/; // "object"
typeof undefined; // "undefined"
typeof null; // "object"
```

* The `void` operator specifies an expression to be evaluated without returning a value. `expression` is a JavaScript expression to evaluate. The parentheses surrounding the expression are optional, but it is good style to use them to avoid precedence issues. 
+
```js
const output = void 1;
console.log(output);
// Expected output: undefined

void console.log('expression evaluated');
// Expected output: "expression evaluated"

void (function iife() {
  console.log('iife is executed');
})();
// Expected output: "iife is executed"

void function test() {
  console.log('test function executed');
};
try {
  test();
} catch (e) {
  console.log('test function is not defined');
  // Expected output: "test function is not defined"
}
```

==== Relational operators

* The `in` operator returns `true` if the specified property is in the specified object or its prototype chain. The `in` operator cannot be used to search for values in other collections. To test if a certain value exists in an array, use `Array.prototype.includes()`. For sets, use `Set.prototype.has()`.
+
```js
// Arrays
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // returns true
3 in trees; // returns true
6 in trees; // returns false
"bay" in trees; // returns false
// (you must specify the index number, not the value at that index)
"length" in trees; // returns true (length is an Array property)

// built-in objects
"PI" in Math; // returns true
const myString = new String("coral");
"length" in myString; // returns true

// Custom objects
const mycar = { make: "Honda", model: "Accord", year: 1998 };
"make" in mycar; // returns true
"model" in mycar; // returns true
```

* The `instanceof` operator tests to see if the prototype property of a constructor appears anywhere in the prototype chain of an object. The return value is a boolean value. Its behavior can be customized with `Symbol.hasInstance`.
+
```js
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
const auto = new Car('Honda', 'Accord', 1998);

console.log(auto instanceof Car);
// Expected output: true

console.log(auto instanceof Object);
// Expected output: true
```



== References

* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide
