= How to compile and run Java
:page-layout: post
:page-categories: ['java']
:page-tags: ['java', 'maven', 'jvm', 'container', 'kubernetes', 'spring']
:revdate: 2021-11-01 13:12:53 +0800
:sectnums:
:toc:
:toclevels: 5

== The `javac` Command

*  *Hello.java*
+
[source,java]
----
// Hello.java
public class Hello {
   public static void main(String[] args) {
      System.out.println("Hello Java!");
   }
} 
----

* *Complile with `javac`*
+
[source,console]
----
$ javac Hello.java 
$ java Hello 
Hello Java!
----

** *javac -d and java -cp*
+
[source,console]
----
$ javac Hello.java -d target/classes/
$ java -cp target/classes/ Hello 
Hello Java!
----

== The `java` Command

The *java* command starts a Java application. It does this by starting the Java Virtual Machine (JVM), loading the specified class, and calling that class's _main()_ method. The method must be declared _public_ and _static_, it must not return any value, and it must accept a _String_ array as a parameter. The method declaration has the following form:

[source,java]
public static void main(String[] args)

In source-file mode, the java command can launch a class declared in a source file.

NOTE: You can use the `JDK_JAVA_OPTIONS` launcher environment variable to prepend its content to the actual command line of the java launcher.

By default, the first argument that isn't an option of the java command is the fully qualified name of the class to be called. If `-jar` is specified, then its argument is the name of the JAR file containing class and resource files for the application. The startup class must be indicated by the `Main-Class` manifest header in its manifest file.

Arguments after the class file name or the JAR file name are passed to the _main()_ method.

* *To launch a single source-file program*
+
** *Synopsis*
+
[source,console]
----
java [options] source-file [args ...]
----

** *java Hello.java*
+
[source,console]
----
$ java Hello.java
Hello Java!
----

* *To launch a class file*

** *Synopsis*
+
[source,console]
----
java [options] mainclass [args ...]
----

** *java Hello*
+
[source,console]
----
$ javac Hello.java 
$ java Hello 
Hello Java!
----

* *To launch the main class in a JAR file*
+
Executes a program encapsulated in a JAR file. The _jarfile_ argument is the name of a JAR file with a manifest that contains a line in the form `Main-Class:classname` that defines the class with the `public static void main(String[] args)` method that serves as your application's starting point. When you use `-jar`, the specified JAR file is the source of all user classes, and other class path settings are ignored.
+
** *Synopsis*
+
[source,console]
----
java [options] -jar jarfile [args ...]
----

** *The `jar` command*

*** *Synopsis*
+
[source,console]
----
jar [OPTION ...] [ [--release VERSION] [-C dir] files] ...
----

*** *Create an jar*
+
[source,console]
----
$ jar -cf foo.jar Hello.class 
$ java -cp foo.jar Hello
Hello Java!
----

*** *Create an executable jar*
+
[source,console,highlight='2,12']
----
$ java -jar foo.jar
no main manifest attribute, in foo.jar

$ jar --create --file buz.jar --main-class Hello Hello.class 
$ java -jar buz.jar 
Hello Java!

$ jar xf buz.jar META-INF/
$ cat META-INF/MANIFEST.MF 
Manifest-Version: 1.0
Created-By: 11.0.12 (Debian)
Main-Class: Hello

----

=== Overview of Java Options

The java command supports a wide range of options in the following categories:

* *Standard Options for Java*: Options guaranteed to be supported by all implementations of the Java Virtual Machine (JVM). They're used for common actions, such as checking the version of the JRE, setting the class path, enabling verbose output, and so on.

* *Extra Options for Java*: General purpose options that are specific to the Java HotSpot Virtual Machine. They aren't guaranteed to be supported by all JVM implementations, and are subject to change. These options start with `-X`.

The advanced options aren't recommended for casual use. These are developer options used for tuning specific areas of the Java HotSpot Virtual Machine operation that often have specific system requirements and may require privileged access to system configuration parameters. 

Boolean options are used to either enable a feature that's disabled by default or disable a feature that's enabled by default. Such options don't require a parameter. *Boolean -XX options* are enabled using the plus sign (`-XX:+OptionName`) and disabled using the minus sign (`-XX:-OptionName`).

For *options that require an argument*, the argument may be separated from the option name by a `space`, a `colon` (:), or an `equal sign` (=), or the argument may `directly follow the option` (the exact syntax differs for each option). If you're expected to `specify the size in bytes`, then you can use no suffix, or use the suffix k or K for kilobytes (KB), m or M for megabytes (MB), or g or G for gigabytes (GB). For example, to set the size to 8 GB, you can specify either 8g, 8192m, 8388608k, or 8589934592 as the argument. If you are expected to `specify the percentage`, then use a number from 0 to 1. For example, specify 0.25 for 25%.

=== Standard Options for Java

These are the most commonly used options supported by all implementations of the JVM.

NOTE: To specify an argument for a long option, you can use either `--name=value` or `--name value`.

* --class-path _classpath_, -classpath _classpath_, or *-cp* _classpath_
+
A semicolon (;) separated list of directories, JAR archives, and ZIP archives to search for class files.
+
Specifying classpath overrides any setting of the CLASSPATH environment variable. If the class path option isn't used and classpath isn't set, then the user class path consists of the current directory (.).
+
As a special convenience, a class path element that contains a base name of an asterisk (\*) is considered equivalent to specifying a list of all the files in the directory with the extension .jar or .JAR . A Java program can't tell the difference between the two invocations. For example, if the directory mydir contains a.jar and b.JAR, then the class path element mydir/* is expanded to A.jar:b.JAR, except that the order of JAR files is unspecified. All .jar files in the specified directory, even hidden ones, are included in the list. A class path entry consisting of an asterisk (*) expands to a list of all the jar files in the current directory. The CLASSPATH environment variable, where defined, is similarly expanded. Any class path wildcard expansion that occurs before the Java VM is started. Java programs never see wildcards that aren't expanded except by querying the environment, such as by calling System.getenv("CLASSPATH").

* --list-modules
+
Lists the observable modules and then exits. 

* -d _module_name_ or --describe-module _module_name_
+
Describes a specified module and then exits. 

* --dry-run
+
Creates the VM but doesn't execute the main method. This *--dry-run* option might be useful for validating the command-line options such as the module system configuration. 

* --validate-modules
+
Validates all modules and exit. This option is helpful for finding conflicts and other errors with modules on the module path. 

* **-D**property=value
+
Sets a system property value. The property variable is a string with no spaces that represents the name of the property. The value variable is a string that represents the value of the property. If value is a string with spaces, then enclose it in quotation marks (for example -Dfoo="foo bar"). 

* -verbose:class
+
Displays information about each loaded class. 

* *-verbose:gc*
+
Displays information about each garbage collection (GC) event. 

* -verbose:jni
+
Displays information about the use of native methods and other Java Native Interface (JNI) activity. 

* -verbose:module
+
Displays information about the modules in use. 

* *-X*
+
Prints the help on extra options to the error stream. 

=== Extra Options for Java

The following java options are general purpose options that are specific to the Java HotSpot Virtual Machine.

* -Xlog:option
+
Configure or enable logging with the Java Virtual Machine (JVM) unified logging framework. 

* -Xinternalversion
+
Displays more detailed JVM version information than the -version option, and then exits. 

* *-Xmn* _size_
+
Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery) in the generational collectors. Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, or g or G to indicate gigabytes. The young generation region of the heap is used for new objects. GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. It is recommended that you do not set the size for the young generation for the G1 collector, and keep the size for the young generation greater than 25% and less than 50% of the overall heap size for other collectors. The following examples show how to set the initial and maximum size of young generation to 256 MB using various units:
+
[source,console]
----
-Xmn256m
-Xmn262144k
-Xmn268435456
----
+
Instead of the *-Xmn* option to set both the initial and maximum size of the heap for the young generation, you can use *-XX:NewSize* to set the initial size and *-XX:MaxNewSize* to set the maximum size.

* *-Xms* _size_
+
Sets the minimum and initial size (in bytes) of the heap. This value must be a multiple of 1024 and greater than 1 MB. Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, g or G to indicate gigabytes. The following examples show how to set the size of allocated memory to 6 MB using various units:
+
[source,console]
----
-Xms6291456
-Xms6144k
-Xms6m
----
+
Instead of the *-Xms* option to set both the minimum and initial size of the heap, you can use *-XX:MinHeapSize* to set the minimum size and *-XX:InitialHeapSize* to set the initial size.
+
If you don't set this option, the initial size is set as the sum of the sizes allocated for the old generation and the young generation. The initial size of the heap for the young generation can be set using the -Xmn option or the *-XX:NewSize* option.

* *-Xmx* _size_
+
Specifies the maximum size (in bytes) of the heap. This value must be a multiple of 1024 and greater than 2 MB. Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, or g or G to indicate gigabytes. The default value is chosen at runtime based on system configuration. For server deployments, *-Xms* and *-Xmx* are often set to the same value. The following examples show how to set the maximum allowed size of allocated memory to 80 MB using various units:
+
[source,console]
----
-Xmx83886080
-Xmx81920k
-Xmx80m
----
+
The *-Xmx* option is equivalent to *-XX:MaxHeapSize*.

* -XshowSettings
+
Shows all settings and then continues. 

* *-XshowSettings*:__category__
+
Shows settings and continues. Possible category arguments for this option include the following:
+
** all
+
Shows all categories of settings. This is the default value. 
** locale
+
Shows settings related to locale. 
+
** properties
+
Shows settings related to system properties. 
** vm
+
Shows the settings of the JVM. 
** system
+
Linux: Shows host system or container configuration and continues. 

* *-Xss* _size_
+
Sets the thread stack size (in bytes). Append the letter k or K to indicate KB, m or M to indicate MB, or g or G to indicate GB. The default value depends on the platform:
+
** Linux/x64 (64-bit): 1024 KB
** macOS (64-bit): 1024 KB
** Windows: The default value depends on virtual memory
+
The following examples set the thread stack size to 1024 KB in different units:
+
[source,console]
----
-Xss1m
-Xss1024k
-Xss1048576
----
+
This option is similar to *-XX:ThreadStackSize*.

* --source version
+
Sets the version of the source in source-file mode. 

=== Advanced Options for Java

These java options can be used to enable other advanced options.

* -XX:+UnlockDiagnosticVMOptions
+
Unlocks the options intended for diagnosing the JVM. By default, this option is disabled and diagnostic options aren't available.
+
Command line options that are enabled with the use of this option are not supported. If you encounter issues while using any of these options, it is very likely that you will be required to reproduce the problem without using any of these unsupported options before Oracle Support can assist with an investigation. It is also possible that any of these options may be removed or their behavior changed without any warning.

* -XX:+UnlockExperimentalVMOptions
+
Unlocks the options that provide experimental features in the JVM. By default, this option is disabled and experimental features aren't available. 

* -XX:+PrintFlagsInitial
+
Print all the default values of all XX flags.

* -XX:+PrintFlagsFinal
+
Print all the current values to all XX flags.

=== Advanced Runtime Options for Java

These java options control the runtime behavior of the Java HotSpot VM.

* -XX:ActiveProcessorCount=_x_
+
Overrides the number of CPUs that the VM will use to calculate the size of thread pools it will use for various operations such as Garbage Collection and ForkJoinPool.
+
The VM normally determines the number of available processors from the operating system. This flag can be useful for partitioning CPU resources when running multiple Java processes in docker containers. This flag is honored even if UseContainerSupport is not enabled. See *-XX:-UseContainerSupport* for a description of enabling and disabling container support.

* **-XX:MaxDirectMemorySize**=_size_
+
Sets the maximum total size (in bytes) of the java.nio package, direct-buffer allocations. Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, or g or G to indicate gigabytes. By default, the size is set to 0, meaning that the JVM chooses the size for NIO direct-buffer allocations automatically.
+
The following examples illustrate how to set the NIO size to 1024 KB in different units:
+
[source,console]
----
-XX:MaxDirectMemorySize=1m
-XX:MaxDirectMemorySize=1024k
-XX:MaxDirectMemorySize=1048576
----

* -XX:NativeMemoryTracking=mode
+
Specifies the mode for tracking JVM native memory usage. Possible mode arguments for this option include the following:
+
** off
+
Instructs not to track JVM native memory usage. This is the default behavior if you don't specify the -XX:NativeMemoryTracking option. 
** summary
+
Tracks memory usage only by JVM subsystems, such as Java heap, class, code, and thread. 
+
** detail
+
In addition to tracking memory usage by JVM subsystems, track memory usage by individual CallSite, individual virtual memory region and its committed regions. 

* -XX:OnError=_string_
+
Sets a custom command or a series of semicolon-separated commands to run when an irrecoverable error occurs. If the string contains spaces, then it must be enclosed in quotation marks.
+
** Linux and macOS: The following example shows how the -XX:OnError option can be used to run the gcore command to create a core image, and start the gdb debugger to attach to the process in case of an irrecoverable error (the %p designates the current process identifier):
+
[source,console]
-XX:OnError="gcore %p;gdb -p %p"
+
** Windows: The following example shows how the -XX:OnError option can be used to run the userdump.exe utility to obtain a crash dump in case of an irrecoverable error (the %p designates the current process identifier). This example assumes that the path to the userdump.exe utility is specified in the PATH environment variable:
+
[source,console]
-XX:OnError="userdump.exe %p"

* -XX:OnOutOfMemoryError=_string_
+
Sets a custom command or a series of semicolon-separated commands to run when an OutOfMemoryError exception is first thrown. If the string contains spaces, then it must be enclosed in quotation marks. For an example of a command string, see the description of the *-XX:OnError* option. 

* *-XX:+PrintCommandLineFlags*
+
Enables printing of ergonomically selected JVM flags that appeared on the command line. It can be useful to know the ergonomic values set by the JVM, such as the heap space size and the selected garbage collector. By default, this option is disabled and flags aren't printed. 

* -XX:+PrintNMTStatistics
+
Enables printing of collected native memory tracking data at JVM exit when native memory tracking is enabled (see -XX:NativeMemoryTracking). By default, this option is disabled and native memory tracking data isn't printed. 

* *-XX:ThreadStackSize*=_size_
+
Sets the Java thread stack size (in kilobytes). Use of a scaling suffix, such as k, results in the scaling of the kilobytes value so that -XX:ThreadStackSize=1k sets the Java thread stack size to 1024*1024 bytes or 1 megabyte. The default value depends on the platform:
+
** Linux/x64 (64-bit): 1024 KB
** macOS (64-bit): 1024 KB
** Windows: The default value depends on virtual memory
+
The following examples show how to set the thread stack size to 1 megabyte in different units:
+
[source,console]
----
-XX:ThreadStackSize=1k
-XX:ThreadStackSize=1024
----
+
This option is similar to *-Xss*.

* **-XX:-UseContainerSupport**
+
The VM now provides automatic container detection support, which allows the VM to determine the amount of memory and number of processors that are available to a Java process running in docker containers. It uses this information to allocate system resources. This support is only available on Linux x64 platforms. If supported, the default for this flag is true, and container support is enabled by default. It can be disabled with *-XX:-UseContainerSupport*.
+
Unified Logging is available to help to diagnose issues related to this support.
+
Use *-Xlog:os+container=trace* for maximum logging of container information. 

=== Advanced JIT Compiler Options for java

These java options control the dynamic just-in-time (JIT) compilation performed by the Java HotSpot VM.

* -XX:InitialCodeCacheSize=_size_
+
Sets the initial code cache size (in bytes). Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, or g or G to indicate gigabytes. The default value depends on the platform. The initial code cache size shouldn't be less than the system's minimal memory page size. The following example shows how to set the initial code cache size to 32 KB:
+
[source,console]
----
-XX:InitialCodeCacheSize=32k
----

* *-XX:ReservedCodeCacheSize*=_size_
+
Sets the maximum code cache size (in bytes) for JIT-compiled code. Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, or g or G to indicate gigabytes. The default maximum code cache size is 240 MB; if you disable tiered compilation with the option *-XX:-TieredCompilation*, then the default size is 48 MB. This option has a limit of 2 GB; otherwise, an error is generated. The maximum code cache size shouldn't be less than the initial code cache size; see the option *-XX:InitialCodeCacheSize*. 

* *-XX:-TieredCompilation*
+
Disables the use of tiered compilation. By default, this option is enabled.

=== Advanced Garbage Collection Options for Java

These java options control how garbage collection (GC) is performed by the Java HotSpot VM.

* -XX:ConcGCThreads=_threads_
+
Sets the number of threads used for concurrent GC. Sets _threads_ to approximately 1/4 of the number of parallel garbage collection threads. The default value depends on the number of CPUs available to the JVM.
+
For example, to set the number of threads for concurrent GC to 2, specify the following option:
+
[source,console]
-XX:ConcGCThreads=2

* -XX:+DisableExplicitGC
+
Enables the option that disables processing of calls to the System.gc() method. This option is disabled by default, meaning that calls to System.gc() are processed. If processing of calls to System.gc() is disabled, then the JVM still performs GC when necessary. 

* -XX:+ExplicitGCInvokesConcurrent
+
Enables invoking of concurrent GC by using the System.gc() request. This option is disabled by default and can be enabled only with the -XX:+UseG1GC option. 

* -XX:InitialHeapSize=_size_
+
Sets the initial size (in bytes) of the memory allocation pool. This value must be either 0, or a multiple of 1024 and greater than 1 MB. Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, or g or G to indicate gigabytes. The default value is selected at run time based on the system configuration.
+
The following examples show how to set the size of allocated memory to 6 MB using various units:
+
[source,console]
----
-XX:InitialHeapSize=6291456
-XX:InitialHeapSize=6144k
-XX:InitialHeapSize=6m
----
+
If you set this option to 0, then the initial size is set as the sum of the sizes allocated for the old generation and the young generation. The size of the heap for the young generation can be set using the *-XX:NewSize* option.

* -XX:InitialRAMPercentage=_percent_
+
Sets the initial amount of memory that the JVM will use for the Java heap before applying ergonomics heuristics as a percentage of the maximum amount determined as described in the -XX:MaxRAM option. The default value is 1.5625 percent.
+
The following example shows how to set the percentage of the initial amount of memory used for the Java heap:
+
[source,console]
----
-XX:InitialRAMPercentage=5
----

* -XX:MaxGCPauseMillis=_time_
+
Sets a target for the maximum GC pause time (in milliseconds). This is a soft goal, and the JVM will make its best effort to achieve it. The specified value doesn't adapt to your heap size. By default, for G1 the maximum pause time target is 200 milliseconds. The other generational collectors do not use a pause time goal by default.
+
The following example shows how to set the maximum target pause time to 500 ms:
+
[source,console]
----
-XX:MaxGCPauseMillis=500
----

* *-XX:MaxHeapSize*=_size_
+
Sets the maximum size (in byes) of the memory allocation pool. This value must be a multiple of 1024 and greater than 2 MB. Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, or g or G to indicate gigabytes. The default value is selected at run time based on the system configuration. For server deployments, the options -XX:InitialHeapSize and -XX:MaxHeapSize are often set to the same value.
+
The following examples show how to set the maximum allowed size of allocated memory to 80 MB using various units:
+
[source,console]
----
-XX:MaxHeapSize=83886080
-XX:MaxHeapSize=81920k
-XX:MaxHeapSize=80m
----
+
The *-XX:MaxHeapSize* option is equivalent to *-Xmx*.

* *-XX:MaxMetaspaceSize*=_size_
+
Sets the maximum amount of native memory that can be allocated for class metadata. By default, the size isn't limited. The amount of metadata for an application depends on the application itself, other running applications, and the amount of memory available on the system.
+
The following example shows how to set the maximum class metadata size to 256 MB:
+
[source,console]
----
-XX:MaxMetaspaceSize=256m
----

* -XX:MaxNewSize=_size_
+
Sets the maximum size (in bytes) of the heap for the young generation (nursery). The default value is set ergonomically. 

* -XX:MaxRAM=_size_
+
Sets the maximum amount of memory that the JVM may use for the Java heap before applying ergonomics heuristics. The default value is the maximum amount of available memory to the JVM process or 128 GB, whichever is lower.
+
The maximum amount of available memory to the JVM process is the minimum of the machine's physical memory and any constraints set by the environment (e.g. container).
+
Specifying this option disables automatic use of compressed oops if the combined result of this and other options influencing the maximum amount of memory is larger than the range of memory addressable by compressed oops.
+
The following example shows how to set the maximum amount of available memory for sizing the Java heap to 2 GB:
+
[source,console]
----
-XX:MaxRAM=2G
----

* -XX:MaxRAMPercentage=_percent_
+
Sets the maximum amount of memory that the JVM may use for the Java heap before applying ergonomics heuristics as a percentage of the maximum amount determined as described in the -XX:MaxRAM option. The default value is 25 percent.
+
Specifying this option disables automatic use of compressed oops if the combined result of this and other options influencing the maximum amount of memory is larger than the range of memory addressable by compressed oops. See -XX:UseCompressedOops for further information about compressed oops.
+
The following example shows how to set the percentage of the maximum amount of memory used for the Java heap:
+
[source,console]
----
-XX:MaxRAMPercentage=75
----

* -XX:MinRAMPercentage=_percent_
+
Sets the _maximum_ amount of memory that the JVM may use for the Java heap before applying ergonomics heuristics as a percentage of the maximum amount determined as described in the *-XX:MaxRAM* option for small heaps. A small heap is a heap of approximately 125 MB. The default value is 50 percent.
+
The following example shows how to set the percentage of the maximum amount of memory used for the Java heap for small heaps:
+
[source,console]
----
-XX:MinRAMPercentage=75
----

* *-XX:MetaspaceSize*=_size_
+
Sets the size of the allocated class metadata space that triggers a garbage collection the first time it's exceeded. This threshold for a garbage collection is increased or decreased depending on the amount of metadata used. The default size depends on the platform. 

* *-XX:MinHeapSize*=_size_
+
Sets the minimum size (in bytes) of the memory allocation pool. This value must be either 0, or a multiple of 1024 and greater than 1 MB. Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, or g or G to indicate gigabytes. The default value is selected at run time based on the system configuration.
+
The following examples show how to set the mimimum size of allocated memory to 6 MB using various units:
+
[source,console]
----
-XX:MinHeapSize=6291456
-XX:MinHeapSize=6144k
-XX:MinHeapSize=6m
----
+
If you set this option to 0, then the minimum size is set to the same value as the initial size.

* -XX:NewSize=_size_
+
Sets the initial size (in bytes) of the heap for the young generation (nursery). Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, or g or G to indicate gigabytes.
+
The young generation region of the heap is used for new objects. GC is performed in this region more often than in other regions. If the size for the young generation is too low, then a large number of minor GCs are performed. If the size is too high, then only full GCs are performed, which can take a long time to complete. It is recommended that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.
+
The following examples show how to set the initial size of the young generation to 256 MB using various units:
+
[source,console]
----
-XX:NewSize=256m
-XX:NewSize=262144k
-XX:NewSize=268435456
----
+
The *-XX:NewSize* option is equivalent to *-Xmn*.

* -XX:+UseG1GC
+
Enables the use of the garbage-first (G1) garbage collector. It's a server-style garbage collector, targeted for multiprocessor machines with a large amount of RAM. This option meets GC pause time goals with high probability, while maintaining good throughput. The G1 collector is recommended for applications requiring large heaps (sizes of around 6 GB or larger) with limited GC latency requirements (a stable and predictable pause time below 0.5 seconds). By default, this option is enabled and G1 is used as the default garbage collector. 

=== Removed Java Options

These java options have been removed in JDK 17 and using them results in an error of:

[source,console]
----
Unrecognized VM option option-name
----

* *-XX:MaxPermSize*=_size_
+
Sets the maximum permanent generation space size (in bytes). This option was deprecated in JDK 8 and superseded by the *-XX:MaxMetaspaceSize* option. 

* *-XX:PermSize*=_size_
+
Sets the space (in bytes) allocated to the permanent generation that triggers a garbage collection if it's exceeded. This option was deprecated in JDK 8 and superseded by the *-XX:MetaspaceSize* option. 

== Apache Maven

Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information. 

=== Build `Lifecycle` Basics

Maven is based around the central concept of a *build lifecycle*. What this means is that the process for building and distributing a particular artifact (project) is clearly defined.

For the person building a project, this means that it is only necessary to learn a small set of commands to build any Maven project, and the POM will ensure they get the results they desired.

There are three built-in build lifecycles: `default`, `clean` and `site`. The default lifecycle handles your project deployment, the clean lifecycle handles project cleaning, while the site lifecycle handles the creation of your project's web site.

=== A Build Lifecycle is Made Up of `Phases`

Each of these build lifecycles is defined by a different list of build phases, wherein a *build phase* represents a *stage* in the lifecycle.

For example, the `default lifecycle` comprises of the following phases (for a complete list of the lifecycle phases, refer to the Lifecycle Reference):

* `validate` - validate the project is correct and all necessary information is available
* `compile` - compile the source code of the project
* `test` - test the compiled source code using a suitable unit testing framework. These tests should not require the code be packaged or deployed
* `package` - take the compiled code and package it in its distributable format, such as a JAR.
* `verify` - run any checks on results of integration tests to ensure quality criteria are met
* `install` - install the package into the local repository, for use as a dependency in other projects locally
* `deploy` - done in the build environment, copies the final package to the remote repository for sharing with other developers and projects.

These lifecycle phases (plus the other lifecycle phases not shown here) are executed sequentially to complete the default lifecycle. Given the lifecycle phases above, this means that when the default lifecycle is used, Maven will first validate the project, then will try to compile the sources, run those against the tests, package the binaries (e.g. jar), run integration tests against that package, verify the integration tests, install the verified package to the local repository, then deploy the installed package to a remote repository.

==== Usual Command Line Calls

You should select the phase that matches your outcome. If you want your jar, run `package`. If you want to run the unit tests, run test.

If you are uncertain what you want, the preferred phase to call is

[source,console]
mvn verify

This command executes each default lifecycle phase in order (`validate`, `compile`, `package`, etc.), before executing verify. You only need to call the last build phase to be executed, in this case, `verify`. In most cases the effect is the same as `package`. However, in case there are integration-tests, these will be executed as well. And during the verify phase some additional checks can be done, e.g. if your code written according to the predefined checkstyle rules.

In a build environment, use the following call to cleanly build and deploy artifacts into the shared repository.

[source,console]
mvn clean deploy

The same command can be used in a multi-module scenario (i.e. a project with one or more subprojects). Maven traverses into every subproject and executes `clean`, then executes `deploy` (including all of the prior build phase steps).

=== A Build Phase is Made Up of `Plugin Goals`

However, even though a build phase is responsible for a specific step in the build lifecycle, the manner in which it carries out those responsibilities may vary. And this is done by declaring the plugin goals bound to those build phases.

A *plugin goal* represents a specific task (finer than a build phase) which contributes to the building and managing of a project. It may be bound to zero or more build phases. A goal not bound to any build phase could be executed outside of the build lifecycle by direct invocation. The order of execution depends on the order in which the goal(s) and the build phase(s) are invoked. For example, consider the command below. The `clean` and `package` arguments are `build` phases, while the `dependency:copy-dependencies` is a goal (of a plugin).

[source,console]
mvn clean dependency:copy-dependencies package

If this were to be executed, the `clean` phase will be executed first (meaning it will run all preceding phases of the clean lifecycle, plus the `clean` phase itself), and then the `dependency:copy-dependencies` goal, before finally executing the package phase (and all its preceding build phases of the default lifecycle).

Moreover, if a goal is bound to one or more build phases, that goal will be called in all those phases.

Furthermore, a build phase can also have zero or more goals bound to it. If a build phase has no goals bound to it, that build phase will not execute. But if it has one or more goals bound to it, it will execute all those goals.

=== Standard Directory Layout

Having a common directory layout allows users familiar with one Maven project to immediately feel at home in another Maven project. The advantages are analogous to adopting a site-wide look-and-feel.

The next section documents the directory layout expected by Maven and the directory layout created by Maven. Try to conform to this structure as much as possible. However, if you can't, these settings can be overridden via the project descriptor.

[cols='1,3']
|===
|src/main/java
|Application/Library sources

|src/main/resources
|Application/Library resources

|src/main/filters
|Resource filter files

|src/main/webapp
|Web application sources

|src/test/java
|Test sources

|src/test/resources
|Test resources

|src/test/filters
|Test resource filter files

|src/it
|Integration Tests (primarily for plugins)

|src/assembly
|Assembly descriptors

|src/site
|Site

|LICENSE.txt
|Project's license

|NOTICE.txt
|Notices and attributions required by libraries that the project depends on

|README.txt
|Project's readme
|===

===  Apache Maven Help Plugin

* The *help:active-profiles* Goal
+
The active-profiles goal is used to discover which profiles have been applied to the projects currently being built. For each project in the build session, it will output a list of profiles which have been applied to that project, along with the source of the profile (POM, settings.xml or profiles.xml).
+
You can execute this goal using the following command:
+
[source,sh]
# mvn help:active-profiles

NOTE: you could also use the output parameter to redirect output to a file.

* The *help:all-profiles* Goal
+
The all-profiles goal is used to discover all available profiles under the current project.
+
You can execute this goal using the following command:
+
[source,sh]
# mvn help:all-profiles
+
NOTE: you could also use the output parameter to redirect output to a file.

* The *help:describe* Goal
+
The describe goal is used to discover information about Maven plugins. Given either a plugin or a groupId, an artifactId and optionally a version, the goal will lookup that plugin and output details about it. If the user also specifies which goal to describe, the describe goal will limit output to the details of that goal, including parameters.
+
You can execute this goal using the following command:
+
[source,sh]
# mvn help:describe -DgroupId=org.somewhere -DartifactId=some-plugin -Dversion=0.0.0
+
NOTE: you could also use the output parameter to redirect output to a file.
+
Refer to Configuring Describe Goal for more information about its configuration.

* The *help:effective-pom* Goal
+
The effective-pom goal is used to make visible the POM that results from the application of interpolation, inheritance and active profiles. It provides a useful way of removing the guesswork about just what ends up in the POM that Maven uses to build your project. It will iterate over all projects in the current build session, printing the effective POM for each.
+
You can execute this goal using the following command:
+    
[source,sh]
# mvn help:effective-pom
+
NOTE: you could also use the output parameter to redirect output to a file.

* The *help:effective-settings* Goal
+
The effective-settings goal is used to view the settings that Maven actually uses to run the build. These settings are a result of merging the global file with the user's file, with the user's file taking precedence.
+
You can execute this goal using the following command:
+
[source,sh]
# mvn help:effective-settings
+
NOTE: you could also use the output parameter to redirect output to a file.

* The *help:system* Goal
+
The system goal is used to view the system information like system properties and environment variables.
+
You can execute this goal using the following command:
+
[source,sh]
# mvn help:system
+
NOTE: you could also use the output parameter to redirect output to a file.

* The *help:evaluate* Goal
+
You could use this interactive goal to evaluate some Maven expressions. To do it, just call the help:evaluate goal:
+
[source,console]
----
# mvn help:evaluate -Dartifact=org.apache.maven.plugins:maven-help-plugin
...
[INFO] [help:evaluate]
[INFO] Enter the Maven expression i.e. ${project.groupId} or 0 to exit?:
${project.artifactId}
[INFO]
maven-help-plugin
[INFO] Enter the Maven expression i.e. ${project.groupId} or 0 to exit?:
${project.none}
[INFO]
null object or invalid expression
...
----
+
The artifact parameter refers to ask expressions on the artifact POM. If omitted, the evaluate goal uses the current pom.
+
You could ask for all Maven expressions listed in the Javadoc of the PluginParameterExpressionEvaluator class.

=== Spring Boot Maven Plugin

* Create a Spring MVC project with link:start.spring.io[]
+
[source,console]
----
$ curl -sS -o demo.zip "https://start.spring.io/starter.zip?type=maven-project&language=java&bootVersion=2.5.6&baseDir=demo&groupId=com.example&artifactId=demo&name=demo&description=Demo%20project%20for%20Spring%20Boot&packageName=com.example.demo&packaging=jar&javaVersion=11&dependencies=web,devtools,actuator"
$ unzip demo.zip && cd demo
----

* Display help information on spring-boot-maven-plugin.
+
[source,console]
----
$ mvn spring-boot:help

...

This plugin has 7 goals:

spring-boot:build-image
  Package an application into a OCI image using a buildpack.

spring-boot:build-info
  Generate a build-info.properties file based on the content of the current
  MavenProject.

spring-boot:help
  Display help information on spring-boot-maven-plugin.
  Call mvn spring-boot:help -Ddetail=true -Dgoal=<goal-name> to display
  parameter details.

spring-boot:repackage
  Repackage existing JAR and WAR archives so that they can be executed from the
  command line using java -jar. With layout=NONE can also be used simply to
  package a JAR with nested dependencies (and no main class, so not executable).

spring-boot:run
  Run an application in place.

spring-boot:start
  Start a spring application. Contrary to the run goal, this does not block and
  allows other goals to operate on the application. This goal is typically used
  in integration test scenario where the application is started before a test
  suite and stopped after.

spring-boot:stop
  Stop an application that has been started by the 'start' goal. Typically
  invoked once a test suite has completed.

...
----

* Build and run Spring boot
+
[source,console]
----
$ mvn package
$ java -Dmanagement.endpoints.web.exposure.include=health -Dserver.port=8088 -jar target/demo-0.0.1-SNAPSHOT.jar
----
+
Open another command shell:
+
[source,console]
----
$ curl -i localhost:8088/actuator/health
HTTP/1.1 200 
Content-Type: application/vnd.spring-boot.actuator.v3+json
Transfer-Encoding: chunked
Date: Mon, 01 Nov 2021 10:52:48 GMT

{"status":"UP"}
----

* Show `META-INF/MANIFEST.MF` of _demo-0.0.1-SNAPSHOT.jar_
+
[source,console,highlight=8]
----
$ jar -xf target/demo-0.0.1-SNAPSHOT.jar META-INF/MANIFEST.MF
$ cat META-INF/MANIFEST.MF 
Manifest-Version: 1.0
Created-By: Maven Jar Plugin 3.2.0
Build-Jdk-Spec: 11
Implementation-Title: demo
Implementation-Version: 0.0.1-SNAPSHOT
Main-Class: org.springframework.boot.loader.JarLauncher
Start-Class: com.example.demo.DemoApplication
Spring-Boot-Version: 2.5.6
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
Spring-Boot-Classpath-Index: BOOT-INF/classpath.idx
Spring-Boot-Layers-Index: BOOT-INF/layers.idx

----

== Java in Container

The linux `free` command detects memory info from `/proc/meminfo` instead of `/sys/fs/cgroup/memory/memory.stat`, that's the container total memory is always the same with the virtual machine host total memory.

[source,console]
----
$ free 
              total        used        free      shared  buff/cache   available
Mem:        4017728      726892     1148152        1212     2142684     3026308
Swap:             0           0           0

$ docker run --rm openjdk:8 free 
               total        used        free      shared  buff/cache   available
Mem:         4017728      814556     1408108        1284     1795064     2943488
Swap:              0           0           0

$ docker run --rm -m 512m openjdk:11 free
WARNING: Your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap.
               total        used        free      shared  buff/cache   available
Mem:         4017728      816368     1383084        1292     1818276     2941724
Swap:              0           0           0

$ docker run --rm -m 512m openjdk:11 cat /sys/fs/cgroup/memory/memory.limit_in_bytes
WARNING: Your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap.
536870912
----

=== Run Java in Container

We will use the https://docs.oracle.com/en/java/javase/17/gctuning/parallel-collector1.html[parallel collector] to demostrate the java VM container support. Unless the initial and maximum heap sizes are specified on the command line, they're calculated based on the amount of memory on the machine. The default maximum heap size is one-fourth of the physical memory while the initial heap size is 1/64th of physical memory. The maximum amount of space allocated to the young generation is one third of the total heap size.

[source,sh,highlight='4']
----
# Run Java in virtual machine host
$ java -XX:+UseParallelGC -XshowSettings:vm -version
VM settings:
    Max. Heap Size (Estimated): 873.00M
    Using VM: OpenJDK 64-Bit Server VM

openjdk version "11.0.12" 2021-07-20
OpenJDK Runtime Environment (build 11.0.12+7-post-Debian-2deb10u1)
OpenJDK 64-Bit Server VM (build 11.0.12+7-post-Debian-2deb10u1, mixed mode, sharing)
----

=== Java VM container detection support

* -XX:-UseContainerSupport
+
The VM now provides automatic container detection support, which allows the VM to determine the amount of memory and number of processors that are available to a Java process running in docker containers. It uses this information to allocate system resources. This support is only available on Linux x64 platforms. If supported, the default for this flag is true, and container support is enabled by default. It can be disabled with -XX:-UseContainerSupport.

* Use `-XX:-UseContainerSupport` to disable container support
+
As we can see, the default java VM maximum heap size is always same with the host, and the maximum  heap size _874M_ is about one fourth of the physical memory 4G.
+
** Run Java in container without memory limit
+
[source,console,highlight='4']
----
$ docker run --rm openjdk:11 java -XX:-UseContainerSupport -XX:+UseParallelGC -XshowSettings:vm -version
VM settings:
    Max. Heap Size (Estimated): 873.00M
    Using VM: OpenJDK 64-Bit Server VM

openjdk version "11.0.13" 2021-10-19
OpenJDK Runtime Environment 18.9 (build 11.0.13+8)
OpenJDK 64-Bit Server VM 18.9 (build 11.0.13+8, mixed mode, sharing)
----
+
** Run Java in container with memory limit
+
[source,console,highlight='4']
----
$ docker run --rm -m 512m openjdk:11 java -XX:-UseContainerSupport -XX:+UseParallelGC -XshowSettings:vm -version
WARNING: Your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap.
VM settings:
    Max. Heap Size (Estimated): 873.00M
    Using VM: OpenJDK 64-Bit Server VM

openjdk version "11.0.13" 2021-10-19
OpenJDK Runtime Environment 18.9 (build 11.0.13+8)
OpenJDK 64-Bit Server VM 18.9 (build 11.0.13+8, mixed mode, sharing)
----

* Use `-XX:+UseContainerSupport` to enable container support
+
The default value for this flag `-XX:+UseContainerSupport` is true, so we can run java without it. Now, the default maximum heap size is _114M_, which is about one fourth of the memory limit 512m.
+
** Run Java in container with memory limit 
+
[source,console,highlight='4']
----
$ docker run --rm -m 512m openjdk:11 java -XX:+UseParallelGC -XshowSettings:vm -version
WARNING: Your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap.
VM settings:
    Max. Heap Size (Estimated): 114.00M
    Using VM: OpenJDK 64-Bit Server VM

openjdk version "11.0.13" 2021-10-19
OpenJDK Runtime Environment 18.9 (build 11.0.13+8)
OpenJDK 64-Bit Server VM 18.9 (build 11.0.13+8, mixed mode, sharing)
----

** Use `-Xlog:os+container=trace` for maximum logging of container information.
+
[source,console,highlight='4,6,9,11,13']
----
$ docker run --rm -m 512m openjdk:11 java -Xlog:os+container=trace -version
WARNING: Your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap.
[0.000s][trace][os,container] OSContainer::init: Initializing Container Support
[0.001s][trace][os,container] Path to /memory.use_hierarchy is /sys/fs/cgroup/memory/memory.use_hierarchy
[0.001s][trace][os,container] Use Hierarchy is: 1
[0.001s][trace][os,container] Path to /memory.limit_in_bytes is /sys/fs/cgroup/memory/memory.limit_in_bytes
[0.001s][trace][os,container] Memory Limit is: 536870912
[0.001s][info ][os,container] Memory Limit is: 536870912
[0.001s][trace][os,container] Path to /cpu.cfs_quota_us is /sys/fs/cgroup/cpu,cpuacct/cpu.cfs_quota_us
[0.001s][trace][os,container] CPU Quota is: -1
[0.001s][trace][os,container] Path to /cpu.cfs_period_us is /sys/fs/cgroup/cpu,cpuacct/cpu.cfs_period_us
[0.001s][trace][os,container] CPU Period is: 100000
[0.001s][trace][os,container] Path to /cpu.shares is /sys/fs/cgroup/cpu,cpuacct/cpu.shares
[0.001s][trace][os,container] CPU Shares is: 1024
[0.001s][trace][os,container] OSContainer::active_processor_count: 2
[0.001s][trace][os,container] OSContainer::active_processor_count (cached): 2
[0.003s][trace][os,container] OSContainer::active_processor_count (cached): 2
[0.039s][trace][os,container] Path to /cpu.cfs_quota_us is /sys/fs/cgroup/cpu,cpuacct/cpu.cfs_quota_us
[0.040s][trace][os,container] CPU Quota is: -1
[0.040s][trace][os,container] Path to /cpu.cfs_period_us is /sys/fs/cgroup/cpu,cpuacct/cpu.cfs_period_us
[0.040s][trace][os,container] CPU Period is: 100000
[0.040s][trace][os,container] Path to /cpu.shares is /sys/fs/cgroup/cpu,cpuacct/cpu.shares
[0.041s][trace][os,container] CPU Shares is: 1024
[0.041s][trace][os,container] OSContainer::active_processor_count: 2
[0.063s][trace][os,container] Path to /memory.limit_in_bytes is /sys/fs/cgroup/memory/memory.limit_in_bytes
[0.064s][trace][os,container] Memory Limit is: 536870912
[0.064s][trace][os,container] Path to /memory.usage_in_bytes is /sys/fs/cgroup/memory/memory.usage_in_bytes
[0.065s][trace][os,container] Memory Usage is: 10055680

...

[0.112s][trace][os,container] Path to /memory.usage_in_bytes is /sys/fs/cgroup/memory/memory.usage_in_bytes
[0.112s][trace][os,container] Memory Usage is: 11456512
openjdk version "11.0.13" 2021-10-19
OpenJDK Runtime Environment 18.9 (build 11.0.13+8)
OpenJDK 64-Bit Server VM 18.9 (build 11.0.13+8, mixed mode, sharing)
----

=== Spring Boot in Kubernetes

. Create Spring MVC project with start.spring.io
+
[source,console]
----
$ curl -sS -o demo.zip "https://start.spring.io/starter.zip?type=maven-project&language=java&bootVersion=2.5.6&baseDir=demo&groupId=com.example&artifactId=demo&name=demo&description=Demo%20project%20for%20Spring%20Boot&packageName=com.example.demo&packaging=jar&javaVersion=11&dependencies=web,devtools,actuator"
$ unzip demo.zip && cd demo
----

. Build OCI image with `mvn spring-boot:build-image`
+
[source,console,highlight=37]
----
$ mvn spring-boot:build-image
[INFO] Scanning for projects...
[INFO] 
[INFO] --------------------------< com.example:demo >--------------------------
[INFO] Building demo 0.0.1-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------

...

[INFO]     [creator]     Paketo BellSoft Liberica Buildpack 8.9.0
[INFO]     [creator]       https://github.com/paketo-buildpacks/bellsoft-liberica
[INFO]     [creator]       Build Configuration:
[INFO]     [creator]         $BP_JVM_TYPE                 JRE             the JVM type - JDK or JRE
[INFO]     [creator]         $BP_JVM_VERSION              11.*            the Java version
[INFO]     [creator]       Launch Configuration:
[INFO]     [creator]         $BPL_DEBUG_ENABLED           false           enables Java remote debugging support
[INFO]     [creator]         $BPL_DEBUG_PORT              8000            configure the remote debugging port
[INFO]     [creator]         $BPL_DEBUG_SUSPEND           false           configure whether to suspend execution until a debugger has attached
[INFO]     [creator]         $BPL_HEAP_DUMP_PATH                          write heap dumps on error to this path
[INFO]     [creator]         $BPL_JAVA_NMT_ENABLED        true            enables Java Native Memory Tracking (NMT)
[INFO]     [creator]         $BPL_JAVA_NMT_LEVEL          summary         configure level of NMT, summary or detail
[INFO]     [creator]         $BPL_JFR_ARGS                                configure custom Java Flight Recording (JFR) arguments
[INFO]     [creator]         $BPL_JFR_ENABLED             false           enables Java Flight Recording (JFR)
[INFO]     [creator]         $BPL_JMX_ENABLED             false           enables Java Management Extensions (JMX)
[INFO]     [creator]         $BPL_JMX_PORT                5000            configure the JMX port
[INFO]     [creator]         $BPL_JVM_HEAD_ROOM           0               the headroom in memory calculation
[INFO]     [creator]         $BPL_JVM_LOADED_CLASS_COUNT  35% of classes  the number of loaded classes in memory calculation
[INFO]     [creator]         $BPL_JVM_THREAD_COUNT        250             the number of threads in memory calculation
[INFO]     [creator]         $JAVA_TOOL_OPTIONS                           the JVM launch flags

...

[INFO]     [creator]     Saving docker.io/library/demo:0.0.1-SNAPSHOT...
[INFO]     [creator]     *** Images (702b824ba18f):
[INFO]     [creator]           docker.io/library/demo:0.0.1-SNAPSHOT
[INFO] 
[INFO] Successfully built image 'docker.io/library/demo:0.0.1-SNAPSHOT'
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  15.435 s
[INFO] Finished at: 2021-11-02T14:35:32+08:00
[INFO] ------------------------------------------------------------------------
----

. Deploy demo.app into Kubernetes

** unable to calculate memory configuration
+
[source,yaml]
----
# demo.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: demo
  name: demo
spec:
  replicas: 1
  selector:
    matchLabels:
      app: demo
  template:
    metadata:
      labels:
        app: demo
    spec:
      containers:
        - name: demo
          image: demo:0.0.1-SNAPSHOT
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 250m
              memory: 256Mi
----
+
[source,console,highlight=11]
----
$ kubectl apply -f demo-0.yaml 
deployment.apps/demo created

$ kubectl get po demo-f74fb85d9-gh28w 
NAME                   READY   STATUS   RESTARTS      AGE
demo-f74fb85d9-gh28w   0/1     Error    3 (34s ago)   52s

$ kubectl logs demo-f74fb85d9-gh28w 
Setting Active Processor Count to 2
unable to calculate memory configuration
fixed memory regions require 597169K which is greater than 256M available for allocation: -XX:MaxDirectMemorySize=10M, -XX:MaxMetaspaceSize=85169K, -XX:ReservedCodeCacheSize=240M, -Xss1M * 250 threads
ERROR: failed to launch: exec.d: failed to execute exec.d file at path '/layers/paketo-buildpacks_bellsoft-liberica/helper/exec.d/memory-calculator': exit status 1
----

** Java VM  Garbage Collection Tuning
+
[source,yml,highlight='21-23']
----
# demo.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: demo
  name: demo
spec:
  replicas: 1
  selector:
    matchLabels:
      app: demo
  template:
    metadata:
      labels:
        app: demo
    spec:
      containers:
        - name: demo
          image: demo:0.0.1-SNAPSHOT
          env:
            - name: JAVA_TOOL_OPTIONS
              value: "-XX:MaxDirectMemorySize=8M -XX:MaxMetaspaceSize=64M -XX:ReservedCodeCacheSize=16M -Xss512K"
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 250m
              memory: 256Mi
----
+
[source,console]
----
$ kubectl get po -l app=demo
NAME                    READY   STATUS    RESTARTS   AGE
demo-7b848bcfd6-82lms   1/1     Running   0          25s

$ kubectl logs -f demo-7b848bcfd6-82lms 
Setting Active Processor Count to 2
Calculated JVM Memory Configuration: -Xmx43M (Total Memory: 256M, Thread Count: 250, Loaded Class Count: 12623, Headroom: 0%)
Enabling Java Native Memory Tracking
Adding 128 container CA certificates to JVM truststore
Spring Cloud Bindings Enabled
Picked up JAVA_TOOL_OPTIONS: -XX:MaxDirectMemorySize=8M -XX:MaxMetaspaceSize=64M -XX:ReservedCodeCacheSize=16M -Xss512K -Djava.security.properties=/layers/paketo-buildpacks_bellsoft-liberica/java-security-properties/java-security.properties -XX:+ExitOnOutOfMemoryError -XX:ActiveProcessorCount=2 -Xmx43M -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary -XX:+PrintNMTStatistics -Dorg.springframework.cloud.bindings.boot.enable=true

...

2021-11-02 07:34:06.238  INFO 1 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2021-11-02 07:34:06.432  INFO 1 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 28.591 seconds (JVM running for 32.397)
----
+
[source,console]
----
$ kubectl expose deployment demo --port 8080 --type NodePort
service/demo exposed

$ kubectl get svc -l app=demo
NAME   TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
demo   NodePort   10.99.172.195   <none>        8080:30227/TCP   6s

$ curl -i localhost:30227
HTTP/1.1 404 
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Content-Type: application/json
Transfer-Encoding: chunked
Date: Tue, 02 Nov 2021 07:42:29 GMT

{"timestamp":"2021-11-02T07:42:29.133+00:00","status":404,"error":"Not Found","path":"/"}
----

** Liveness and Readiness Probes with Spring Boot
+
[source,yaml,highlight='24-36']
----
# demo.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: demo
  name: demo
spec:
  replicas: 1
  selector:
    matchLabels:
      app: demo
  template:
    metadata:
      labels:
        app: demo
    spec:
      containers:
        - name: demo
          image: demo:0.0.1-SNAPSHOT
          env:
            - name: JAVA_TOOL_OPTIONS
              value: "-XX:MaxDirectMemorySize=8M -XX:MaxMetaspaceSize=64M -XX:ReservedCodeCacheSize=16M -Xss512K"
          args:
            - Dmanagement.endpoint.health.group.health.include=readiness,liveness
            - Dmanagement.endpoints.web.exposure.include=health
          livenessProbe:
            initialDelaySeconds: 60
            httpGet:
              path: /actuator/health/liveness
              port: 8080
          readinessProbe:
            initialDelaySeconds: 60
            httpGet:
              path: /actuator/health/readiness
              port: 8080
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 250m
              memory: 256Mi
----
+
[source,console]
----
$ kubectl get po -l app=demo
NAME                    READY   STATUS    RESTARTS   AGE
demo-5f9cd9c556-mwkrx   1/1     Running   0          110s

$ curl -i localhost:30227/actuator/health
HTTP/1.1 200 
Content-Type: application/vnd.spring-boot.actuator.v3+json
Transfer-Encoding: chunked
Date: Tue, 02 Nov 2021 07:48:07 GMT

{"status":"UP","groups":["liveness","readiness"]}
----

== References

* https://docs.oracle.com/en/java/javase/17/docs/specs/man/javac.html
* https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html
* https://docs.oracle.com/en/java/javase/17/docs/specs/man/jar.html
* https://docs.oracle.com/en/java/javase/17/gctuning/parallel-collector1.html
* https://maven.apache.org/index.html
* https://maven.apache.org/plugins/index.html
* https://maven.apache.org/pom.html
* https://maven.apache.org/settings.html
* https://maven.apache.org/plugins/maven-help-plugin/usage.html
* https://maven.apache.org/plugins/maven-dependency-plugin/usage.html
* https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html
* https://dzone.com/articles/best-practices-java-memory-arguments-for-container
* https://paketo.io/docs/reference/java-reference/
* https://spring.io/blog/2020/03/25/liveness-and-readiness-probes-with-spring-boot
* https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index
* https://www.redhat.com/sysadmin/cgroups-part-one
