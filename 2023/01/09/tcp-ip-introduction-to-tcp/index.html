<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bing WebMaster -->
  <meta name="msvalidate.01" content="AB2FFF876C37F59D9121882CC8395DE5" />

  <title>TCP/IP: Introduction to TCP</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://blog.codefarm.me/2023/01/09/tcp-ip-introduction-to-tcp/">
  <link rel="alternate" type="application/rss+xml" title="CODE FARM" href="https://blog.codefarm.me/feed.xml">

  <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->
<script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>

  
<!-- Google Analytics Website tracking -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-83971182-1', 'auto');
  ga('send', 'pageview');

</script>


  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SN88FJ18E5');
</script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">
    <h2 class="site-title">
      <a class="site-title" href="/">CODE FARM</a>
    </h2>

     <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
        <div class="trigger">
            <ul>
                <li><a href="/">home</a>
                <li><a href="/category">category</a>
                <li><a href="/tag">tag</a>
                <li><a href="/archive">archive</a>
                <li><a href="/about">about</a>
                <li><a href="https://resume.github.io/?qqbuby" target="_blank">R&eacute;sum&eacute;</a>
            </ul>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">TCP/IP: Introduction to TCP</h1>
    
    
    <p class="post-meta"><time datetime="2023-01-09T08:53:28+08:00" itemprop="datePublished">Jan 9, 2023</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#arq-and-retransmission">1. ARQ and Retransmission</a>
<ul class="sectlevel2">
<li><a href="#windows-of-packets-and-sliding-windows">1.1. Windows of Packets and Sliding Windows</a></li>
<li><a href="#variable-windows-flow-control-and-congestion-control">1.2. Variable Windows: Flow Control and Congestion Control</a></li>
<li><a href="#setting-the-retransmission-timeout">1.3. Setting the Retransmission Timeout</a></li>
</ul>
</li>
<li><a href="#introduction-to-tcp">2. Introduction to TCP</a>
<ul class="sectlevel2">
<li><a href="#the-tcp-service-model">2.1. The TCP Service Model</a></li>
<li><a href="#reliability-in-tcp">2.2. Reliability in TCP</a></li>
</ul>
</li>
<li><a href="#tcp-header-and-encapsulation">3. TCP Header and Encapsulation</a></li>
<li><a href="#summary">4. Summary</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>So far we have been discussing protocols that do not include their own mechanisms for delivering data reliably.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>They may <em>detect</em> that erroneous data has been received, using a mathematical function such as a checksum or CRC, but they do not try very hard to repair errors.</p>
</li>
<li>
<p>With IP and UDP, no error repair is done at all.</p>
</li>
<li>
<p>With Ethernet and other protocols based on it, the protocol provides some number of <em>retries</em> and then gives up if it cannot succeed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The problem of communicating in environments where the communication medium may lose or alter the messages being delivered has been studied for years.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Some of the most important theoretical work on the topic was developed by <strong>Claude Shannon</strong> in 1948.</p>
<div class="paragraph">
<p>This work, which popularized the term <strong><em>bit</em></strong> and became the foundation of the field of <strong><em>information theory</em></strong>, helps us understand the fundamental limits on the amount of information that can be moved across an information channel that is lossy (that may delete or alter bits).</p>
</div>
</li>
<li>
<p>Information theory is closely related to the field of <strong><em>coding theory</em></strong>, which provides ways of encoding information so that it is as resilient as possible to errors in the communications channel.</p>
<div class="paragraph">
<p>Using <em>error-correcting codes</em> (basically, adding redundant bits so that the real information can be retrieved even if some bits are damaged) to correct communications problems is one very important method for handling errors.</p>
</div>
</li>
<li>
<p>Another is to simply "try sending again" until the information is finally received. This approach, called <strong>Automatic Repeat Request</strong> (ARQ), forms the basis for many communications protocols, including TCP.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="arq-and-retransmission">1. ARQ and Retransmission</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If we consider not only a single communication channel but the <em>multihop</em> cascade of several, we realize that not only may we have the types of errors mentioned so far (<em>packet bit errors</em>), but there may be others which  might arise at an <em>intermediate router</em> and are the types of problems we brought up when discussing IP: <em>packet reordering</em>, <em>packet duplication</em>, and <em>packet erasures (drops)</em>. An errorcorrecting protocol designed for use over a <em>multihop communications channel</em> (such as IP) must cope with all of these problems.</p>
</div>
<div class="paragraph">
<p>A straightforward method of dealing with <strong><em>packet drops</em></strong> (and bit errors) is to <em>resend</em> the packet until it is received properly. This requires a way to determine</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(1) whether the receiver has received the packet and</p>
</li>
<li>
<p>(2) whether the packet it received was the same one the sender sent.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The method for a receiver to signal to a sender that it has received a packet is called an <strong><em>acknowledgment</em></strong>, or ACK. In its most basic form,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the sender sends a packet and awaits an ACK.</p>
</li>
<li>
<p>When the receiver receives the packet, it sends the ACK.</p>
</li>
<li>
<p>When the sender receives the ACK, it sends another packet, and the process continues.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Interesting questions to ask here are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(1) How long should the sender wait for an ACK?</p>
<div class="paragraph">
<p>Deciding how long to wait relates to how long the sender should <em>expect</em> to wait for an ACK.</p>
</div>
</li>
<li>
<p>(2) What if the ACK is lost?</p>
<div class="paragraph">
<p>If an ACK is dropped, the sender cannot readily distinguish this case from the case in which the original packet is dropped, so it simply sends the packet again.</p>
</div>
<div class="paragraph">
<p>Of course, the receiver may receive two or more copies in that case, so it must be prepared to handle that situation.</p>
</div>
</li>
<li>
<p>(3) What if the packet was received but had errors in it?</p>
<div class="paragraph">
<p>It is generally much easier to use codes to <em>detect</em> errors in a large packet (with high probability) using only a few bits than it is to correct them.</p>
</div>
<div class="paragraph">
<p>Simpler codes are typically not capable of correcting errors but are capable of detecting them. That is why checksums and CRCs are so popular.</p>
</div>
<div class="paragraph">
<p>In order to detect errors in a packet, then, we use a form of checksum.</p>
</div>
<div class="paragraph">
<p>When a receiver receives a packet containing an error, it refrains from sending an ACK. Eventually, the sender resends the packet, which ideally arrives undamaged.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Even with the simple scenario presented so far, there is the possibility that the receiver might receive <em>duplicate copies</em> of the packet being transferred. This problem is addressed using a <strong><em>sequence number</em></strong>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Basically, every unique packet gets a new sequence number when it is sent at the source, and this sequence number is carried along in the packet itself.</p>
</li>
<li>
<p>The receiver can use this number to determine whether it has already seen the packet and if so, discard it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The protocol described so far is reliable but not very efficient.</p>
</div>
<div class="paragraph">
<p>Consider what happens when the time to deliver even a small packet from sender to receiver (the delay or latency) is large (e.g., a second or two, which is not unusual for satellite links) and there are several packets to send.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The sender is able to inject a single packet into the communications path but then must stop until it hears the ACK. This protocol is therefore called "stop and wait".</p>
</li>
<li>
<p>Its throughput performance (data sent on the network per unit time) is proportional to <em>M/R</em> where <em>M</em> is the packet size and <em>R</em> is the round-trip time (RTT), assuming no packets are lost or irreparably damaged in transit.</p>
</li>
<li>
<p>For a fixed-size packet, as <em>R</em> goes up, the throughput goes down. If packets are lost or damaged, the situation is even worse: the "<em>goodput</em>" (useful amount of data transferred per unit time) can be considerably less than the throughput.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a network that doesn&#8217;t damage or drop many packets, the cause for low throughput is usually that the network is not being kept busy. The situation is similar to using an assembly line where new work cannot enter the line until a complete product emerges. Most of the line goes idle. If we take this comparison one step further, it seems obvious that we would do better if we could have more than one work unit in the line at a time. It is the same for network communication—if we could have more than one packet in the network, we would keep it "more busy", leading to higher throughput.</p>
</div>
<div class="paragraph">
<p>Allowing more than one packet to be in the network at a time complicates matters considerably.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Now the sender must decide not only when to inject a packet into the network, but also how many.</p>
</li>
<li>
<p>It also must figure out how to keep the timers when waiting for ACKs, and it must keep a copy of each packet not yet acknowledged in case retransmissions are necessary.</p>
</li>
<li>
<p>The receiver needs to have a more sophisticated ACK mechanism: one that can distinguish which packets have been received and which have not.</p>
</li>
<li>
<p>The receiver may need a more sophisticated buffering (packet storage) mechanism—one that allows it to hold "out-of-sequence" packets (those packets that have arrived earlier than those expected because of loss or reordering), unless it simply wants to throw away such packets, which is very inefficient.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="windows-of-packets-and-sliding-windows">1.1. Windows of Packets and Sliding Windows</h3>
<div class="paragraph">
<p>To handle all of these problems,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>we begin with the assumption that each unique packet has a <strong>sequence number</strong>, as described earlier.</p>
</li>
<li>
<p>We define a <strong>window</strong> of packets as the collection of packets (or their sequence numbers) that have been injected by the sender but not yet completely acknowledged (i.e., the sender has not received an ACK for them).</p>
<div class="paragraph">
<p>We refer to the <strong>window size</strong> as the number of packets in the window.</p>
</div>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/introduction-to-tcp/window.png" alt="TCP Window" width="55%" height="55%">
</div>
<div class="title">Figure 1. The sender&#8217;s window, showing which packets are eligible to be sent (or have already been sent), which are not yet eligible, and which have already been sent and acknowledged. In this example, the window size is fixed at three packets.</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>This figure shows the current window of three packets, for a total window size of 3.</p>
</li>
<li>
<p>Packet number 3 has already been sent and acknowledged, so the copy of it that the sender was keeping can now be released.</p>
</li>
<li>
<p>Packet 7 is ready at the sender but not yet able to be sent because it is not yet "in" the window.</p>
</li>
<li>
<p>If we now imagine that data starts to flow from the sender to the receiver and ACKs start to flow in the reverse direction, the sender might next receive an ACK for packet 4.</p>
<div class="paragraph">
<p>When this happens, the window "slides" to the right by one packet, meaning that the copy of packet 4 can be released and packet 7 can be sent.</p>
</div>
<div class="paragraph">
<p>This movement of the window gives rise to another name for this type of protocol, a <strong>sliding window</strong> protocol.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The sliding window approach can be used to combat many of the problems described so far. Typically, this window structure is kept at both the sender and the receiver.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>At the sender, it keeps track of what packets can be released, what packets are awaiting ACKs, and what packets cannot yet be sent.</p>
</li>
<li>
<p>At the receiver, it keeps track of what packets have already been received and acknowledged, what packets are expected (and how much memory has been allocated to hold them), and which packets, even if received, will not be kept because of limited memory.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="variable-windows-flow-control-and-congestion-control">1.2. Variable Windows: Flow Control and Congestion Control</h3>
<div class="paragraph">
<p>To handle the problem that arises when a receiver is too slow relative to a sender, we introduce a way to force the sender to slow down when the receiver cannot keep up. This is called <strong>flow control</strong> and is usually handled in one of two ways.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>One way, called <strong>rate-based</strong> flow control, gives the sender a certain data rate allocation and ensures that data is never allowed to be sent at a rate that exceeds the allocation.</p>
<div class="paragraph">
<p>This type of flow control is most appropriate for streaming applications and can be used with broadcast and multicast delivery.</p>
</div>
</li>
<li>
<p>The other predominant form of flow control is called <strong>window-based</strong> flow control and is the most popular approach when sliding windows are being used.</p>
<div class="paragraph">
<p>In this approach, the window size is not fixed but is instead allowed to vary over time.</p>
</div>
<div class="paragraph">
<p>To achieve flow control using this technique, there must be a method for the receiver to signal the sender how large a window to use. This is typically called a <strong><em>window advertisement</em></strong>, or simply a <strong><em>window update</em></strong>. This value is used by the sender (i.e., the receiver of the window advertisement) to adjust its window size.</p>
</div>
<div class="paragraph">
<p>Logically, a window update is separate from the ACKs we discussed previously, but <em>in practice the window update and ACK are carried in a single packet</em>, meaning that the sender tends to adjust the size of its window at the same time it slides it to the right.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If we consider the effect of changing the window size at the sender, it becomes clear how this achieves flow control.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The sender is allowed to inject <em>W</em> packets into the network before it hears an ACK for any of them.</p>
</li>
<li>
<p>If the sender and receiver are sufficiently fast, and the network loses no packets and has an infinite capacity, this means that the transfer rate is proportional to (<em>SW/R</em>) bits/s, where <em>W</em> is the window size, <em>S</em> is the packet size in bits, and <em>R</em> is the RTT.</p>
</li>
<li>
<p>When the window advertisement from the receiver clamps the value of <em>W</em> at the sender, the sender&#8217;s overall rate can be limited so as to not overwhelm the receiver.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This approach works fine for protecting the receiver, but what about the network in between?</p>
</div>
<div class="paragraph">
<p>We may have routers with limited memory between the sender and the receiver that have to contend with slow network links. When this happens, it is possible for the sender&#8217;s rate to exceed a router&#8217;s ability to keep up, leading to packet loss. This is addressed with a special form of flow control called <strong>congestion control</strong>.</p>
</div>
<div class="paragraph">
<p>Congestion control involves the sender slowing down so as to not overwhelm the network between itself and the receiver.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Recall that in our discussion of flow control, we used a window advertisement to signal the sender to slow down for the receiver.</p>
<div class="paragraph">
<p>This is called <strong><em>explicit signaling</em></strong>, because there is a protocol field specifically used to inform the sender about what is happening.</p>
</div>
</li>
<li>
<p>Another option might be for the sender to <em>guess</em> that it needs to slow down.</p>
<div class="paragraph">
<p>Such an approach would involve <strong><em>implicit signaling</em></strong>—that is, it would involve deciding to slow down based on some other evidence.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="setting-the-retransmission-timeout">1.3. Setting the Retransmission Timeout</h3>
<div class="paragraph">
<p>One of the most important performance issues the designer of a retransmissionbased reliable protocol faces is how long to wait before concluding that a packet has been lost and should be resent.</p>
</div>
<div class="paragraph">
<p>Stated another way, What should the retransmission timeout be?</p>
</div>
<div class="paragraph">
<p>Intuitively, the amount of time the sender should wait before resending a packet is about the sum of the following times:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the time to send the packet,</p>
</li>
<li>
<p>the time for the receiver to process it and send an ACK,</p>
</li>
<li>
<p>the time for the ACK to travel back to the sender,</p>
</li>
<li>
<p>and the time for the sender to process the ACK.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unfortunately, in practice, none of these times are known with certainty. To make matters worse, any or all of them vary over time as additional load is added to or removed from the end hosts or routers.</p>
</div>
<div class="paragraph">
<p>Because it is not practical for the user to tell the protocol implementation what the values of all the times are (or to keep them up-to-date) for all circumstances, a better strategy is to have the protocol implementation try to estimate them. This is called <strong>round-trip-time estimation</strong> and is a statistical process.</p>
</div>
<div class="paragraph">
<p>Basically , the true RTT is likely to be close to the sample mean of a collection of samples of RTTs. Note that this average naturally changes over time (it is not stationary), as the paths taken through the network may change.</p>
</div>
<div class="paragraph">
<p>Once some estimate of the RTT is made, the question of setting the actual timeout value, used to trigger retransmissions, remains.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If we recall the definition of a mean, it can never be the extreme value of a set of samples (unless they are all the same).</p>
</li>
<li>
<p>So, it would not be sensible to set the retransmission timer to be exactly equal to the mean estimator, as it is likely that many actual RTTs will be larger, thereby inducing unwanted retransmissions.</p>
<div class="paragraph">
<p>Clearly, the timeout should be set to something larger than the mean, but exactly what this relationship is (or even if the mean should be directly used) is not yet clear.</p>
</div>
</li>
<li>
<p>Setting the timeout too large is also undesirable, as this leads back to letting the network go idle, reducing throughput.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction-to-tcp">2. Introduction to TCP</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Given the background we now have regarding the issues affecting reliable delivery in general, let us see how they play out in TCP and what type of service it provides to Internet applications.</p>
</div>
<div class="sect2">
<h3 id="the-tcp-service-model">2.1. The TCP Service Model</h3>
<div class="paragraph">
<p>Even though TCP and UDP use the same network layer (IPv4 or IPv6), TCP provides a totally different service to the application layer from what UDP does.</p>
</div>
<div class="paragraph">
<p>TCP provides a <strong><em>connection-oriented</em></strong>, reliable, byte stream service.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The term connection-oriented means that the two applications using TCP must establish a TCP connection by contacting each other before they can exchange data.</p>
</li>
<li>
<p>The typical analogy is dialing a telephone number, waiting for the other party to answer the phone and saying "Hello", and then saying "Who&#8217;s calling?"</p>
</li>
<li>
<p>There are exactly two endpoints communicating with each other on a TCP connection; concepts such as broadcasting and multicasting are not applicable to TCP.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The TCP provides a <strong><em>byte stream</em></strong> abstraction to applications that use it.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The consequence of this design decision is that no <em>record markers</em> or <em>message boundaries</em> are automatically inserted by TCP. A record marker corresponds to an indication of an application&#8217;s write extent.</p>
<div class="paragraph">
<p>If the application on one end writes 10 bytes, followed by a write of 20 bytes, followed by a write of 50 bytes, the application at the other end of the connection cannot tell what size the individual writes were.</p>
</div>
<div class="paragraph">
<p>For example, the other end may read the 80 bytes in four reads of 20 bytes at a time or in some other way.</p>
</div>
</li>
<li>
<p>One end puts a stream of bytes into TCP, and the identical stream of bytes appears at the other end.</p>
</li>
<li>
<p>Each endpoint individually chooses its read and write sizes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TCP does not interpret the contents of the bytes in the byte stream at all.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has no idea if the data bytes being exchanged are binary data, ASCII characters, EBCDIC characters, or something else.</p>
</li>
<li>
<p>The interpretation of this byte stream is up to the applications on each end of the connection.</p>
</li>
<li>
<p>TCP does, however, support the urgent mechanism mentioned before, although it is no longer recommended for use.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="reliability-in-tcp">2.2. Reliability in TCP</h3>
<div class="paragraph">
<p>Because TCP provides a byte stream interface, it must convert a sending application&#8217;s stream of bytes into a set of packets that IP can carry. This is called <strong><em>packetization</em></strong>. These packets contain sequence numbers, which in TCP actually represent the byte offsets of the first byte in each packet in the overall data stream rather than packet numbers. This allows packets to be of variable size during a transfer and may also allow them to be combined, called <strong><em>repacketization</em></strong>.</p>
</div>
<div class="paragraph">
<p>The application data is broken into what TCP considers the best-size chunks to send, typically fitting each segment into a single IP-layer datagram that will not be fragmented. This is different from UDP, where each write by the application usually generates a UDP datagram of that size (plus headers). The chunk passed by TCP to IP is called a <strong>segment</strong>.</p>
</div>
<div class="paragraph">
<p>TCP maintains a mandatory checksum on its header, any associated application data, and fields from the IP header.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This is an <em>end-to-end pseudo-header checksum</em> whose purpose is to detect any bit errors introduced in transit.</p>
</li>
<li>
<p>If a segment arrives with an invalid checksum, TCP discards it without sending any acknowledgment for the discarded packet.</p>
<div class="paragraph">
<p>The receiving TCP might acknowledge a <em>previous</em> (already acknowledged) segment, however, to help the sender with its congestion control computations.</p>
</div>
</li>
<li>
<p>The TCP checksum uses the same mathematical function as is used by other Internet protocols (UDP, ICMP, etc.).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When TCP sends a group of segments, it normally sets a single retransmission timer, waiting for the other end to acknowledge reception.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>TCP does not set a different retransmission timer for every segment.</p>
</li>
<li>
<p>Rather, it sets a timer when it sends a window of data and updates the timeout as ACKs arrive.</p>
</li>
<li>
<p>If an acknowledgment is not received in time, a segment is retransmitted.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When TCP receives data from the other end of the connection, it sends an acknowledgment.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This acknowledgment may not be sent immediately but is normally delayed a fraction of a second.</p>
</li>
<li>
<p>The ACKs used by TCP are cumulative in the sense that an ACK indicating byte number <em>N</em> implies that all bytes up to number <em>N</em> (but not including it) have already been received successfully.</p>
<div class="paragraph">
<p>This provides some robustness against ACK loss—if an ACK is lost, it is very likely that a subsequent ACK is sufficient to ACK the previous segments.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>TCP provides a full-duplex service to the application layer.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This means that data can be flowing in each direction, independent of the other direction.</p>
</li>
<li>
<p>Therefore, each end of a connection must maintain a sequence number of the data flowing in each direction.</p>
</li>
<li>
<p>Once a connection is established, every TCP segment that contains data flowing in one direction of the connection also includes an ACK for segments flowing in the opposite direction.</p>
</li>
<li>
<p>Each segment also contains a window advertisement for implementing flow control in the opposite direction.</p>
<div class="paragraph">
<p>Thus, when a TCP segment arrives on a connection, the window may slide forward, the window size may change, and new data may have arrived.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using sequence numbers, a receiving TCP discards duplicate segments and reorders segments that arrive out of order.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Recall that any of these anomalies can happen because TCP uses IP to deliver its segments, and IP does not provide duplicate elimination or guarantee correct ordering.</p>
</li>
<li>
<p>Because it is a byte stream protocol, however, TCP never delivers data to the receiving application out of order.</p>
<div class="paragraph">
<p>Thus, the receiving TCP may be forced to hold on to data with larger sequence numbers before giving it to an application until a missing lower-sequence-numbered segment (a "hole") is filled in.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tcp-header-and-encapsulation">3. TCP Header and Encapsulation</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/introduction-to-tcp/tcp-segment-in-ip-datagram.png" alt="TCP segement in IP datagram" width="65%" height="65%">
</div>
<div class="title">Figure 2. The TCP header appears immediately following the IP header or last IPv6 extension header and is often 20 bytes long (with no TCP options). With options, the TCP header can be as large as 60 bytes. Common options include <em>Maximum Segment Size</em>, <em>Timestamps</em>, <em>Window Scaling</em>, and <em>Selective ACKs</em>.</div>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/introduction-to-tcp/tcp-header.png" alt="TCP header" width="65%" height="65%">
</div>
<div class="title">Figure 3. The TCP header. Its normal size is 20 bytes, unless options are present. The <em>Header Length</em> field gives the size of the header in 32-bit words (minimum value is 5). The shaded fields (<em>Acknowledgment Number</em>, <em>Window Size</em>, plus <em>ECE</em> and <em>ACK</em> bits) refer to the data flowing in the opposite direction relative to the sender of this segment.</div>
</div>
<div class="paragraph">
<p>Each TCP header contains the source and destination port number.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>These two values, along with the source and destination IP addresses in the IP header, uniquely identify each connection.</p>
</li>
<li>
<p>The combination of an IP address and a port number is sometimes called an <strong><em>endpoint</em></strong> or <strong><em>socket</em></strong> in the TCP literature.</p>
<div class="paragraph">
<p>The latter term appeared in [RFC0793] and was ultimately adopted as the name of the Berkeley-derived programming interface for network communications (now frequently called "Berkeley sockets").</p>
</div>
<div class="paragraph">
<p>It is a <strong><em>pair</em></strong> of sockets or endpoints (the 4-tuple consisting of the client IP address, client port number, server IP address, and server port number) that uniquely identifies each TCP connection.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Sequence Number</em> field identifies the byte in the stream of data from the sending TCP to the receiving TCP that the first byte of data in the containing segment represents.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<div class="title">Sequence number (32 bits)</div>
<p>Has a dual role: <a href="#WIKITCP">[WIKITCP]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the SYN flag is set (1), then this is the initial sequence number. The sequence number of the actual first data byte and the acknowledged number in the corresponding ACK are then this sequence number plus 1.</p>
</li>
<li>
<p>If the SYN flag is clear (0), then this is the accumulated sequence number of the first data byte of this segment for the current session.</p>
</li>
</ul>
</div>
</blockquote>
</div>
<div class="ulist">
<ul>
<li>
<p>If we consider the stream of bytes flowing in one direction between two applications, TCP numbers each byte with a sequence number.</p>
</li>
<li>
<p>This sequence number is a 32-bit unsigned number that wraps back around to 0 after reaching (2<sup>32</sup>) − 1.</p>
</li>
<li>
<p>Because every byte exchanged is numbered, the <em>Acknowledgment Number</em> field (also called the <em>ACK Number</em> or <em>ACK</em> field for short) contains the next sequence number that the sender of the acknowledgment expects to receive.</p>
<div class="paragraph">
<p>This is therefore the sequence number of the last successfully received byte of data plus 1.</p>
</div>
<div class="paragraph">
<p>This field is valid only if the <em>ACK</em> bit field is on, which it usually is for all but initial and closing segments.</p>
</div>
</li>
<li>
<p>Sending an ACK costs nothing more than sending any other TCP segment because the 32-bit <em>ACK Number</em> field is always part of the header, as is the <em>ACK</em> bit field.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a new connection is being established, the <em>SYN</em> bit field is turned on in the first segment sent from client to server.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Such segments are called <em>SYN segments</em>, or simply <em>SYNs</em>.</p>
</li>
<li>
<p>The <em>Sequence Number</em> field then contains the first sequence number to be used on that direction of the connection for subsequent sequence numbers and in returning ACK numbers (recall that connections are all bidirectional).</p>
<div class="paragraph">
<p>Note that this number is not 0 or 1 but instead is another number, often randomly chosen, called the <strong><em>initial sequence number</em></strong> (ISN). The reason for the ISN not being 0 or 1 is a security measure.</p>
</div>
</li>
<li>
<p>The sequence number of the first byte of data sent on this direction of the connection is the ISN plus 1 because the <em>SYN</em> bit field consumes one sequence number.</p>
</li>
<li>
<p>Consuming a sequence number also implies reliable delivery using retransmission.</p>
<div class="paragraph">
<p>Thus, <em>SYNs</em> and application bytes (and <em>FINs</em>) are reliably delivered.</p>
</div>
<div class="paragraph">
<p>ACKs, which do not consume sequence numbers, are not.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>TCP can be described as <em>a sliding window protocol with cumulative positive acknowledgments</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>ACK Number</em> field is constructed to indicate the largest byte received in order at the receiver (plus 1).</p>
<div class="paragraph">
<p>For example, if bytes 1–1024 are received OK, and the next segment contains bytes 2049–3072, the receiver cannot use the regular <em>ACK Number</em> field to signal the sender that it received this new segment.</p>
</div>
</li>
<li>
<p>Modern TCPs, however, have a <em>selective acknowledgment</em> (SACK) option that allows the receiver to indicate to the sender out-of-order data it has received correctly. When paired with a TCP sender capable of <em>selective repeat</em>, a significant performance benefit may be realized.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Header Length</em> field gives the length of the header in 32-bit words.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This is required because the length of the <em>Options</em> field is variable.</p>
</li>
<li>
<p>With a 4-bit field, TCP is limited to a 60-byte header.</p>
</li>
<li>
<p>Without options, however, the size is 20 bytes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Currently eight bit fields are defined for the TCP header, although some older implementations understand only the last six of them.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>CWR</strong>—Congestion Window Reduced (the sender reduced its sending rate);</p>
</li>
<li>
<p><strong>ECE</strong>—ECN Echo (the sender received an earlier congestion notification);</p>
</li>
<li>
<p><strong>URG</strong>—Urgent (the Urgent Pointer field is valid—rarely used);</p>
</li>
<li>
<p><strong>ACK</strong>—Acknowledgment (the Acknowledgment Number field is valid—always on after a connection is established);</p>
</li>
<li>
<p><strong>PSH</strong>—Push (the receiver should pass this data to the application as soon as possible—not reliably implemented or used);</p>
</li>
<li>
<p><strong>RST</strong>—Reset the connection (connection abort, usually because of an error);</p>
</li>
<li>
<p><strong>SYN</strong>—Synchronize sequence numbers to initiate a connection;</p>
</li>
<li>
<p><strong>FIN</strong>—The sender of the segment is finished sending data to its peer;</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>TCP&#8217;s flow control is provided by each end advertising a window size using the <em>Window Size</em> field.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This is the number of bytes, starting with the one specified by the ACK number, that the receiver is willing to accept.</p>
</li>
<li>
<p>This is a 16-bit field, limiting the window to 65,535 bytes, and thereby limiting TCP&#8217;s throughput performance.</p>
<div class="paragraph">
<p>The <em>Window Scale</em> option that allows this value to be scaled, providing much larger windows and improved performance for high-speed and long-delay networks.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The TCP <em>Checksum</em> field covers the TCP header and data and some fields in the IP header, using a pseudo-header computation similar to the one used with ICMPv6 and UDP.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is mandatory for this field to be calculated and stored by the sender, and then verified by the receiver.</p>
</li>
<li>
<p>The TCP checksum is calculated with the same algorithm as the IP, ICMP, and UDP ("Internet") checksums.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>Urgent Pointer</em> field is valid only if the <em>URG</em> bit field is set.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This "pointer" is a positive offset that must be added to the <em>Sequence Number</em> field of the segment to yield the sequence number of the last byte of urgent data.</p>
</li>
<li>
<p>TCP&#8217;s urgent mechanism is a way for the sender to provide specially marked data to the other end.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The most common <em>Option</em> field is the <em>Maximum Segment Size</em> option, called the <em>MSS</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each end of a connection normally specifies this option on the first segment it sends (the ones with the <em>SYN</em> bit field set to establish the connection).</p>
</li>
<li>
<p>The <em>MSS</em> option specifies the maximum-size segment that the sender of the option is willing to receive in the reverse direction.</p>
</li>
<li>
<p>Other common options we investigate include <em>SACK</em>, <em>Timestamp</em>, and <em>Window Scale</em>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary">4. Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The problem of providing reliable communications over lossy communication channels has been studied for years. The two primary methods for dealing with errors include <strong>error-correcting codes</strong> and <strong>data retransmission</strong>. The protocols using retransmissions must also handle data loss, usually by setting a timer, and must also arrange some way for the receiver to signal the sender what it has received. Deciding how long to wait for an ACK can be tricky, as the appropriate time may change as network routing or load on the end systems varies. Modern protocols estimate the round-trip time and set the retransmission timer based on some function of these measurements.</p>
</div>
<div class="paragraph">
<p>Except for setting the retransmission timer, retransmission protocols are simple when only one packet may be in the network at one time, but they perform poorly for networks where the delay is high. To be more efficient, multiple packets must be injected into the network before an ACK is received. This approach is more efficient but also more complex. A typical approach to managing the complexity is to use <strong>sliding windows</strong>, whereby packets are marked with sequence numbers, and the window size bounds the number of such packets. When the window size varies based on either feedback from the receiver or other signals (such as dropped packets), both flow control and congestion control can be achieved.</p>
</div>
<div class="paragraph">
<p>TCP provides a <strong>reliable</strong>, <strong>connection-oriented</strong>, <strong>byte stream</strong>, transport-layer service built using many of these techniques. We looked briefly at all of the fields in the TCP header, noting that most of them are directly related to these abstract concepts in reliable delivery. TCP packetizes the application data into <strong>segments</strong>, sets a timeout anytime it sends data, acknowledges data received by the other end, reorders out-of-order data, discards duplicate data, provides end-to-end flow control, and calculates and verifies a mandatory end-to-end checksum. It is the most widely used protocol on the Internet. It is used by most of the popular applications, such as HTTP, SSH/TLS, NetBIOS (NBT—NetBIOS over TCP), Telnet, FTP, and electronic mail (SMTP). Many distributed file-sharing applications (e.g., BitTorrent, Shareaza) also use TCP.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="tcp_ip_vol_1"></a>[1] Kevin Fall, W. Stevens <em>TCP/IP Illustrated: The Protocols, Volume 1</em>. 2nd edition, Addison-Wesley Professional, 2011</p>
</li>
<li>
<p><a id="WIKITCP"></a>[WIKITCP] <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure" class="bare">https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure</a></p>
</li>
</ul>
</div>
</div>
</div>
  </div>

  <ul class="post-navigation">
    <li>
      
      <a href="/2022/12/09/tcp-ip-name-resolution-and-the-domain-name-system/">&laquo; TCP/IP: Name Resolution and the Domain Name System (DNS)</a>
      
    </li>
    <li>
      
      <a href="/2023/01/10/tcp-ip-tcp-connection-management/">TCP/IP: TCP Connection Management &raquo;</a>
      
    </li>
  </ul>
</article>

      </div>
    </div>

    <footer class="site-footer">
  <div class="license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details open>
    <summary>Extral Links</summary>
    <div>
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>


<!-- https://github.com/bryanbraun/anchorjs -->
<script src="/js/anchor.min.js"></script>
<script>
  anchors.add();
  anchors.remove(".site-title");
</script>




  </body>

</html>
