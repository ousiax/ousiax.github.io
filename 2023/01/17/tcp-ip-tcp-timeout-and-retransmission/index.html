<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bing WebMaster -->
  <meta name="msvalidate.01" content="AB2FFF876C37F59D9121882CC8395DE5" />

  <title>TCP/IP: TCP Timeout and Retransmission</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://blog.codefarm.me/2023/01/17/tcp-ip-tcp-timeout-and-retransmission/">
  <link rel="alternate" type="application/rss+xml" title="CODE FARM" href="https://blog.codefarm.me/feed.xml">

  <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->
<script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>

  
<!-- Google Analytics Website tracking -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-83971182-1', 'auto');
  ga('send', 'pageview');

</script>


  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SN88FJ18E5');
</script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">
    <h2 class="site-title">
      <a class="site-title" href="/">CODE FARM</a>
    </h2>

     <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
        <div class="trigger">
            <ul>
                <li><a href="/">home</a>
                <li><a href="/category">category</a>
                <li><a href="/tag">tag</a>
                <li><a href="/archive">archive</a>
                <li><a href="/about">about</a>
                <li><a href="https://resume.github.io/?qqbuby" target="_blank">R&eacute;sum&eacute;</a>
            </ul>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">TCP/IP: TCP Timeout and Retransmission</h1>
    
    
    <p class="post-meta"><time datetime="2023-01-17T14:45:16+08:00" itemprop="datePublished">Jan 17, 2023</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>To decide what data it needs to resend, TCP depends on a continuous flow of acknowledgments from receiver to sender.</p>
</div>
<div class="paragraph">
<p>When data segments or acknowledgments are lost, TCP initiates a <strong>retransmission</strong> of the data that has not been acknowledged.</p>
</div>
<div class="paragraph">
<p>TCP has two separate mechanisms for accomplishing retransmission, one based on time and one based on the structure of the acknowledgments.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>TCP sets a timer when it sends data, and if the data is not acknowledged when the timer expires, a <strong><em>timeout</em></strong> or <strong><em>timer-based retransmission</em></strong> of data occurs.</p>
<div class="paragraph">
<p>The timeout occurs after an interval called the <strong><em>retransmission timeout</em></strong> (RTO).</p>
</div>
</li>
<li>
<p>It has another way of initiating a retransmission called <strong><em>fast retransmission</em></strong> or <strong><em>fast retransmit</em></strong>, which usually happens without any delay.</p>
<div class="paragraph">
<p>Fast retransmit is based on inferring losses by noticing</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>when TCP&#8217;s cumulative acknowledgment fails to advance in the (duplicate) ACKs received over time, or</p>
</li>
<li>
<p>when ACKs carrying selective acknowledgment information (SACKs) indicate that out-of-order segments are present at the receiver.</p>
</li>
</ul>
</div>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#simple-timeout-and-retransmission-time-based-example">1. Simple Timeout and Retransmission (Time-based) Example</a></li>
<li><a href="#setting-the-retransmission-timeout-rto">2. Setting the Retransmission Timeout (RTO)</a>
<ul class="sectlevel2">
<li><a href="#the-classic-method">2.1. The Classic Method</a></li>
<li><a href="#the-standard-method">2.2. The Standard Method</a></li>
</ul>
</li>
<li><a href="#timer-based-retransmission">3. Timer-Based Retransmission</a></li>
<li><a href="#fast-retransmit">4. Fast Retransmit</a></li>
<li><a href="#retransmission-with-selective-acknowledgments">5. Retransmission with Selective Acknowledgments</a>
<ul class="sectlevel2">
<li><a href="#sack-receiver-behavior">5.1. SACK Receiver Behavior</a></li>
<li><a href="#sack-sender-behavior">5.2. SACK Sender Behavior</a></li>
<li><a href="#example">5.3. Example</a></li>
</ul>
</li>
<li><a href="#spurious-timeouts-and-retransmissions">6. Spurious Timeouts and Retransmissions</a>
<ul class="sectlevel2">
<li><a href="#duplicate-sack-dsack-extension">6.1. Duplicate SACK (DSACK) Extension</a></li>
<li><a href="#the-eifel-detection-algorithm">6.2. The Eifel Detection Algorithm</a></li>
<li><a href="#forward-rto-recovery-f-rto">6.3. Forward-RTO Recovery (F-RTO)</a></li>
<li><a href="#the-eifel-response-algorithm">6.4. The Eifel Response Algorithm</a></li>
</ul>
</li>
<li><a href="#packet-reordering-and-duplication">7. Packet Reordering and Duplication</a>
<ul class="sectlevel2">
<li><a href="#reordering">7.1. Reordering</a></li>
<li><a href="#duplication">7.2. Duplication</a></li>
</ul>
</li>
<li><a href="#destination-metrics">8. Destination Metrics</a></li>
<li><a href="#repacketization">9. Repacketization</a></li>
<li><a href="#dropping-packets-in-linux-using-tc-and-iptables">Appendix A: Dropping Packets in Linux using tc and iptables</a>
<ul class="sectlevel2">
<li><a href="#dropping-packets-with-tc">A.1. Dropping Packets with tc</a></li>
<li><a href="#dropping-packets-with-iptables">A.2. Dropping Packets with iptables</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul>
</div>
</div>
<div class="sect1">
<h2 id="simple-timeout-and-retransmission-time-based-example">1. Simple Timeout and Retransmission (Time-based) Example</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We will establish a connection, send some data to verify that everything is OK, isolate one end of the connection, send some more data, and watch what TCP does.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-1:~$</span><span class="w"> </span>nc <span class="nt">-kl</span> 6666</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-0:~$</span><span class="w"> </span>telnet node-1 6666
<span class="go">Trying 192.168.91.135...
Connected to node-1.localdomain.
Escape character is '^]'.
hello
Connection closed by foreign host.</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-1:~$</span><span class="w"> </span><span class="nb">sudo </span>ip <span class="nb">link set </span>ens32 down</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-0:~$</span><span class="w"> </span>ss <span class="nt">-nta</span> dst <span class="k">*</span>:6666
<span class="go">State     Recv-Q     Send-Q            Local Address:Port              Peer Address:Port     Process
ESTAB     0          7                192.168.91.128:36824           192.168.91.137:6666
</span><span class="gp">x@node-0:~$</span><span class="w"> </span>netstat <span class="nt">-nta4</span>
<span class="go">Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      7 192.168.91.128:36824    192.168.91.137:6666     ESTABLISHED</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>tcpdump <span class="nt">-tttttSnv</span> <span class="nt">-i</span> any icmp or port 6666
<span class="go"> 00:00:00.000000 ens32 Out IP (tos 0x10, ttl 64, id 26731, offset 0, flags [DF], proto TCP (6), length 60)
</span><span class="gp">    192.168.91.128.50688 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>S], <span class="nb">cksum </span>0x3889 <span class="o">(</span>incorrect -&gt; 0xc8d2<span class="o">)</span>, <span class="nb">seq </span>1476981540, win 64240, options <span class="o">[</span>mss 1460,sackOK,TS val 3360184417 ecr 0,nop,wscale 7], length 0
<span class="go"> 00:00:00.000396 ens32 In  IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60)
</span><span class="gp">    192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.50688: Flags <span class="o">[</span>S.], <span class="nb">cksum </span>0x34e8 <span class="o">(</span>correct<span class="o">)</span>, <span class="nb">seq </span>2021627494, ack 1476981541, win 65160, options <span class="o">[</span>mss 1460,sackOK,TS val 1682840845 ecr 3360184417,nop,wscale 7], length 0
<span class="go"> 00:00:00.000462 ens32 Out IP (tos 0x10, ttl 64, id 26732, offset 0, flags [DF], proto TCP (6), length 52)
</span><span class="gp">    192.168.91.128.50688 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">cksum </span>0x3881 <span class="o">(</span>incorrect -&gt; 0x6046<span class="o">)</span>, ack 2021627495, win 502, options <span class="o">[</span>nop,nop,TS val 3360184418 ecr 1682840845], length 0
<span class="go"> 00:00:33.520679 ens32 Out IP (tos 0x10, ttl 64, id 26733, offset 0, flags [DF], proto TCP (6), length 59)
</span><span class="gp">    192.168.91.128.50688 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">cksum </span>0x3888 <span class="o">(</span>incorrect -&gt; 0x8f67<span class="o">)</span>, <span class="nb">seq </span>1476981541:1476981548, ack 2021627495, win 502, options <span class="o">[</span>nop,nop,TS val 3360217938 ecr 1682840845], length 7
<span class="c">...
</span><span class="go"> 00:00:40.385007 ens32 Out IP (tos 0x10, ttl 64, id 26739, offset 0, flags [DF], proto TCP (6), length 59)
</span><span class="gp">    192.168.91.128.50688 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">cksum </span>0x3888 <span class="o">(</span>incorrect -&gt; 0x7497<span class="o">)</span>, <span class="nb">seq </span>1476981541:1476981548, ack 2021627495, win 502, options <span class="o">[</span>nop,nop,TS val 3360224802 ecr 1682840845], length 7
<span class="go"> 00:00:50.113908 lo    In  IP (tos 0xd0, ttl 64, id 25299, offset 0, flags [none], proto ICMP (1), length 87)
</span><span class="gp">    192.168.91.128 &gt;</span><span class="w"> </span>192.168.91.128: ICMP host 192.168.91.137 unreachable, length 67
<span class="go">	IP (tos 0x10, ttl 64, id 26740, offset 0, flags [DF], proto TCP (6), length 59)
</span><span class="gp">    192.168.91.128.50688 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">cksum </span>0x3888 <span class="o">(</span>incorrect -&gt; 0x5a96<span class="o">)</span>, <span class="nb">seq </span>1476981541:1476981548, ack 2021627495, win 502, options <span class="o">[</span>nop,nop,TS val 3360231459 ecr 1682840845], length 7
<span class="c">...
</span><span class="go"> 00:15:55.330154 lo    In  IP (tos 0xd0, ttl 64, id 7913, offset 0, flags [none], proto ICMP (1), length 87)
</span><span class="gp">    192.168.91.128 &gt;</span><span class="w"> </span>192.168.91.128: ICMP host 192.168.91.137 unreachable, length 67
<span class="go">	IP (tos 0x10, ttl 64, id 26876, offset 0, flags [DF], proto TCP (6), length 59)
</span><span class="gp">    192.168.91.128.50688 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">cksum </span>0x3888 <span class="o">(</span>incorrect -&gt; 0x8a89<span class="o">)</span>, <span class="nb">seq </span>1476981541:1476981548, ack 2021627495, win 502, options <span class="o">[</span>nop,nop,TS val 3361136674 ecr 1682840845], length 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>Logically, TCP has two thresholds <code>R1</code> and <code>R2</code> to determine how persistently it will attempt to resend the same segment <a href="#RFC1122">[RFC1122]</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Threshold <code>R1</code> indicates the number of tries TCP will make (or the amount of time it will wait) to resend a segment before passing <em>negative advice</em> to the IP layer (e.g., causing it to reevaluate the IP route it is using).</p>
</li>
<li>
<p>Threshold <code>R2</code> (larger than <code>R1</code>) dictates the point at which TCP should abandon the connection.</p>
</li>
<li>
<p><code>R1</code> and <code>R2</code> might be measured in time units or as a count of retransmissions.</p>
<div class="paragraph">
<p>The value of <code>R1</code> SHOULD correspond to at least 3 retransmissions, at the current RTO.</p>
</div>
<div class="paragraph">
<p>The value of <code>R2</code> SHOULD correspond to at least 100 seconds.</p>
</div>
</li>
<li>
<p>However, the values of <code>R1</code> and <code>R2</code> may be different for SYN and data segments.</p>
<div class="paragraph">
<p>In particular, <code>R2</code> for a SYN segment MUST be set large enough to provide retransmission of the segment for at least 3 minutes.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>In Linux, the <code>R1</code> and <code>R2</code> values for regular data segments are available to be changed by applications or can be changed using the system-wide configuration variables <code>net.ipv4.tcp_retries1</code> and <code>net.ipv4.tcp_retries2</code>, respectively.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>These are measured in the number of retransmissions, and not in units of time.</p>
</li>
<li>
<p>The default value for <code>net.ipv4.tcp_retries2</code> is 15, which corresponds roughly to 13–30 minutes, depending on the connection&#8217;s RTO.</p>
</li>
<li>
<p>The default value for <code>net.ipv4.tcp_retries1</code> is 3.</p>
</li>
<li>
<p>For SYN segments, <code>net.ipv4.tcp_syn_retries</code> and <code>net.ipv4.tcp_synack_retries</code> bounds the number of retransmissions of SYN segments; their default value is 5 (roughly 180s).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-1:~$</span><span class="w"> </span><span class="nb">sudo </span>iptables <span class="nt">-A</span> INPUT <span class="nt">-p</span> tcp <span class="nt">-s</span> 192.168.91.128/32 <span class="nt">--dport</span> 6666 <span class="nt">--syn</span> <span class="nt">-j</span> DROP</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>sysctl net.ipv4.tcp_syn_retries
<span class="go">net.ipv4.tcp_syn_retries = 6
</span><span class="gp">x@node-0:~$</span><span class="w"> </span><span class="nb">time </span>telnet 192.168.91.137 6666
<span class="go">Trying 192.168.91.137...
telnet: Unable to connect to remote host: Connection timed out

real	2m9.448s
user	0m0.003s
sys	0m0.001s</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp"> 00:00:00.000000 IP 192.168.91.128.42966 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>S], <span class="nb">seq </span>2460858944, win 1460, options <span class="o">[</span>mss 1460,sackOK,TS val 991112255 ecr 0,nop,wscale 7], length 0
<span class="gp"> 00:00:01.030071 IP 192.168.91.128.42966 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>S], <span class="nb">seq </span>2460858944, win 1460, options <span class="o">[</span>mss 1460,sackOK,TS val 991113285 ecr 0,nop,wscale 7], length 0
<span class="gp"> 00:00:03.045544 IP 192.168.91.128.42966 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>S], <span class="nb">seq </span>2460858944, win 1460, options <span class="o">[</span>mss 1460,sackOK,TS val 991115301 ecr 0,nop,wscale 7], length 0
<span class="gp"> 00:00:07.077396 IP 192.168.91.128.42966 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>S], <span class="nb">seq </span>2460858944, win 1460, options <span class="o">[</span>mss 1460,sackOK,TS val 991119332 ecr 0,nop,wscale 7], length 0
<span class="gp"> 00:00:15.269455 IP 192.168.91.128.42966 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>S], <span class="nb">seq </span>2460858944, win 1460, options <span class="o">[</span>mss 1460,sackOK,TS val 991127524 ecr 0,nop,wscale 7], length 0
<span class="gp"> 00:00:31.397938 IP 192.168.91.128.42966 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>S], <span class="nb">seq </span>2460858944, win 1460, options <span class="o">[</span>mss 1460,sackOK,TS val 991143653 ecr 0,nop,wscale 7], length 0
<span class="gp"> 00:01:03.909769 IP 192.168.91.128.42966 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>S], <span class="nb">seq </span>2460858944, win 1460, options <span class="o">[</span>mss 1460,sackOK,TS val 991176165 ecr 0,nop,wscale 7], length 0</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setting-the-retransmission-timeout-rto">2. Setting the Retransmission Timeout (RTO)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fundamental to TCP&#8217;s timeout and retransmission procedures is how to set the RTO based upon measurement of the RTT experienced on a given connection.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If TCP retransmits a segment earlier than the RTT, it may be injecting duplicate traffic into the network unnecessarily.</p>
</li>
<li>
<p>Conversely, if it delays sending until much longer than one RTT, the overall network utilization (and single-connection throughput) drops when traffic is lost.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Knowing the RTT is made more complicated because it can change over time, as routes and network usage vary.</p>
</div>
<div class="paragraph">
<p>Because TCP sends acknowledgments when it receives data, it is possible to send a byte with a particular sequence number and measure the time (called an <em>RTT sample</em>) required to receive an acknowledgment that covers that sequence number.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The challenge for TCP is to establish a good estimate for the range of RTT values given a set of samples that vary over time and set the RTO based on these values.</p>
</li>
<li>
<p>The RTT is estimated for each TCP connection separately, and one retransmission timer is pending whenever any data is in flight that consumes a sequence number (including SYN and FIN segments).</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="the-classic-method">2.1. The Classic Method</h3>
<div class="paragraph">
<p>The original TCP specification [RFC0793] had TCP update a <em>smoothed RTT</em> estimator (called <em>SRTT</em>) using the following formula:</p>
</div>
<div class="paragraph text-center">
<p><em>SRTT</em> ← α(<em>SRTT</em>) + (1 − α) <em>RTT<sub>s</sub></em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Here, <em>SRTT</em> is updated based on both its existing value and a new sample, <em>RTT<sub>s</sub></em>.</p>
</li>
<li>
<p>The constant <em>α</em> is a smoothing or scale factor with a recommended value between 0.8 and 0.9.</p>
</li>
<li>
<p><em>SRTT</em> is updated every time a new measurement is made.</p>
</li>
<li>
<p>With the original recommended value for <em>α</em>, it is clear that 80% to 90% of each new estimate is from the previous estimate and 10% to 20% is from the new measurement.</p>
</li>
<li>
<p>This type of average is also known as an <em>exponentially weighted moving average</em> (EWMA) or <em>low-pass</em> filter.</p>
</li>
<li>
<p>It is convenient for implementation reasons because it requires only one previous value of <em>SRTT</em> to be stored in order to keep the running estimate.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Given the estimator <em>SRTT</em>, which changes as the RTT changes, [RFC0793] recommended that the RTO be set to the following:</p>
</div>
<div class="paragraph text-center">
<p>RTO = min(<em>ubound</em>, max(<em>lbound</em>,(<em>SRTT</em>)β))</p>
</div>
<div class="ulist">
<ul>
<li>
<p>where <em>β</em> is a delay variance factor with a recommended value of 1.3 to 2.0,</p>
</li>
<li>
<p><em>ubound</em> is an upper bound (suggested to be, e.g., 1 minute),</p>
</li>
<li>
<p>and <em>lbound</em> is a lower bound (suggested to be, e.g., 1s) on the RTO.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We shall call this assignment procedure <em>the classic method</em>. It generally results in the RTO being set either to 1s, or to about twice <em>SRTT</em>.</p>
</div>
<div class="paragraph">
<p>For relatively stable distributions of the RTT, this was adequate. However, when TCP was run over networks with highly variable <em>RTT<sub>s</sub></em> (e.g., early packet radio networks in this case), it did not perform so well.</p>
</div>
</div>
<div class="sect2">
<h3 id="the-standard-method">2.2. The Standard Method</h3>
<div class="paragraph">
<p>In <a href="#J88">[J88]</a>, Jacobson detailed problems with the classic method further—basically, that the timer specified by [RFC0793] cannot keep up with wide <em>fluctuations in the RTT</em> (and in particular, it causes unnecessary retransmissions when the real RTT is much larger than expected).</p>
</div>
<div class="paragraph">
<p>To address this problem, the method used to assign the RTO was enhanced to accommodate a larger variability in the RTT.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This is accomplished by keeping track of an estimate of the <em>variability</em> in the RTT measurements in addition to the estimate of its <em>average</em>.</p>
</li>
<li>
<p>Setting the RTO based on both a mean and a variability estimator provides a better timeout response to wide fluctuations in the roundtrip times than just calculating the RTO as a constant multiple of the mean.</p>
</li>
<li>
<p>If we think of the RTT measurements made by TCP as samples of a statistical process, estimating both the mean and variance (or standard deviation) helps to make better predictions about the possible future values the process may take on.</p>
</li>
<li>
<p>A good prediction for the range of possible values for the RTT helps TCP determine an RTO that is neither too large nor too small in most cases.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following equations that are applied to each RTT measurement <em>M</em> (called <em>RTT<sub>s</sub></em> earlier):</p>
</div>
<div class="paragraph text-center">
<p><em>srtt</em> ← (1 - g)(<em>srtt</em>) + (g)<em>M</em></p>
</div>
<div class="paragraph text-center">
<p><em>rttvar</em> ← (1 - h)(<em>rttvar</em>) + (h)(|<em>M</em> - <em>srtt</em>|)</p>
</div>
<div class="paragraph text-center">
<p>RTO = <em>srtt</em> + 4(<em>rttvar</em>)</p>
</div>
<div class="paragraph">
<p>Here, the value <em>srtt</em> effectively replaces the earlier value of <em>SRTT</em>, and the value <em>rttvar</em>, which becomes an EWMA of the <em>mean deviation</em>, is used instead of <em>β</em> to help determine the RTO.</p>
</div>
<div class="paragraph">
<p>This is the basis for the way many TCP implementations compute their RTOs to this day, and because of its adoption as the basis for <a href="#RFC6298">[RFC6298]</a> we shall call it <em>the standard method</em>, although there are slight refinements in <a href="#RFC6298">[RFC6298]</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="timer-based-retransmission">3. Timer-Based Retransmission</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Once a sending TCP has established its RTO based upon measurements of the time-varying values of effective RTT, whenever it sends a segment it ensures that a retransmission timer is set appropriately.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When setting a retransmission timer, the sequence number of the so-called timed segment is recorded, and if an ACK is received in time, the retransmission timer is canceled.</p>
</li>
<li>
<p>The next time the sender emits a packet with data in it, a new retransmission timer is set, the old one is canceled, and the new sequence number is recorded.</p>
</li>
<li>
<p>The sending TCP therefore continuously sets and cancels one retransmission timer per connection; if no data is ever lost, no retransmission timer ever expires.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When TCP fails to receive an ACK for a segment it has timed on a connection within the RTO, it performs a timer-based retransmission.</p>
</div>
<div class="paragraph">
<p>TCP considers a timer-based retransmission as a fairly major event; it reacts very cautiously when it happens by quickly reducing the rate at which it sends data into the network. It does this in two ways.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The first way is to reduce its sending window size based on congestion control procedures.</p>
</li>
<li>
<p>The other way is to keep increasing a multiplicative backoff factor applied to the RTO each time a retransmitted segment is again retransmitted.</p>
<div class="paragraph">
<p>In particular, the RTO value is (temporarily) multiplied by the value <code>γ</code> to form the backed-off timeout when multiple retransmissions of the same segment occur:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">RTO = γRTO</code></pre>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>In ordinary circumstances, <code>γ</code> has the value 1.</p>
</li>
<li>
<p>On subsequent retransmissions, <code>γ</code> is doubled: 2, 4, 8, and so forth.</p>
<div class="paragraph">
<p>There is typically a maximum backoff factor that <code>γ</code> is not allowed to exceed (Linux ensures that the used RTO never exceeds the value <code>TCP_RTO_MAX</code>, which defaults to 120s).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">x@node-0:~<span class="nv">$ </span><span class="nb">uname</span> <span class="nt">-a</span><span class="p">;</span> <span class="nb">uname</span> <span class="nt">-r</span>
Linux node-0 5.10.0-19-amd64 <span class="c">#1 SMP Debian 5.10.149-2 (2022-10-21) x86_64 GNU/Linux</span>
5.10.0-19-amd64
x@node-0:~<span class="nv">$ </span><span class="nb">grep</span> <span class="s2">"#define HZ"</span> /usr/include/asm-generic/param.h
<span class="c">#define HZ 100</span>
x@node-0:~<span class="nv">$ </span><span class="nb">grep</span> <span class="s2">"#define TCP_RTO_"</span> /usr/src/linux-headers-5.10.0-19-common/include/net/tcp.h
<span class="c">#define TCP_RTO_MAX	((unsigned)(120*HZ))</span>
<span class="c">#define TCP_RTO_MIN	((unsigned)(HZ/5))</span></code></pre>
</div>
</div>
</li>
<li>
<p>Once an acceptable ACK is received, <code>γ</code> is reset to 1.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-0:~$</span><span class="w"> </span><span class="k">while </span>ss <span class="nt">-itn</span> dst <span class="k">*</span>:6666<span class="p">;</span> <span class="k">do </span><span class="nb">sleep </span>1<span class="p">;</span> <span class="k">done</span>
<span class="go">State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      0      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:204 rtt:1.86/0.93 cwnd:10
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:204 rtt:1.86/0.93 cwnd:10
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:816 backoff:2 rtt:1.86/0.93 cwnd:1
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:1632 backoff:3 rtt:1.86/0.93 cwnd:1
</span><span class="c">...
</span><span class="go">State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      7      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:6528 backoff:5 rtt:1.86/0.93 cwnd:1
State Recv-Q Send-Q  Local Address:Port    Peer Address:Port
ESTAB 0      0      192.168.91.128:33176 192.168.91.135:6666
	 cubic wscale:7,7 rto:204 rtt:1.752/0.912 cwnd:2</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fast-retransmit">4. Fast Retransmit</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Fast retransmit</strong> <a href="#RFC5681">[RFC5681]</a> is a TCP procedure that can induce a packet retransmission based on feedback from the receiver instead of requiring a retransmission timer to expire.</p>
</div>
<div class="paragraph">
<p>TCP generates an immediate acknowledgment (a <em>duplicate ACK</em>) when an <strong><em>out-of-order segment</em></strong> is received, and that the loss of a segment implies out-of-order arrivals at the receiver when subsequent data arrives.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When this happens, a <strong><em>hole</em></strong> is created at the receiver.</p>
</li>
<li>
<p>The sender&#8217;s job then becomes filling the receiver&#8217;s holes as quickly and efficiently as possible.</p>
</li>
<li>
<p>The duplicate ACKs sent immediately when out-of-order data arrives are not delayed.</p>
<div class="paragraph">
<p>The reason is to let the sender know that a segment was received out of order, and to indicate what sequence number is expected (i.e., where the hole is).</p>
</div>
</li>
<li>
<p>When SACK is used, these duplicate ACKs typically contain SACK blocks as well, which can provide information about more than one hole.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A duplicate ACK (with or without SACK blocks) arriving at a sender is a potential indicator that a packet sent earlier has been lost.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It can also appear when there is <strong><em>packet reordering</em></strong> in the network—if a receiver receives a packet for a sequence number beyond the one it is expecting next, the expected packet could be either missing or merely delayed.</p>
</li>
<li>
<p>TCP waits for a small number of duplicate ACKs (called the <em>duplicate ACK threshold</em> or <em>dupthresh</em>) to be received before concluding that a packet has been lost and initiating a fast retransmit.</p>
</li>
<li>
<p>Traditionally, <em>dupthresh</em> has been a constant (with value 3 <a href="#RFC5681">[RFC5681]</a>), but some nonstandard implementations (including Linux) alter this value based on the current measured level of reordering.</p>
</li>
<li>
<p>A TCP sender observing at least <em>dupthresh</em> duplicate ACKs retransmits one or more packets that appear to be missing without waiting for a retransmission timer to expire. It may also send additional data that has not yet been sent.</p>
</li>
<li>
<p>Packet loss inferred by the presence of duplicate ACKs is assumed to be related to <em>network congestion</em>, and <em>congestion control</em> procedures are invoked along with <em>fast retransmit</em>.</p>
</li>
<li>
<p>Without SACK, no more than one segment is typically retransmitted until an acceptable ACK is received.</p>
</li>
<li>
<p>With SACK, ACKs contain additional information allowing the sender to fill more than one hole in the receiver per RTT.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-1:~$</span><span class="w"> </span><span class="nb">sudo </span>sysctl net.ipv4.tcp_sack<span class="o">=</span>0 <span class="c"># Disable select acknowledgments (SACKS).</span>
<span class="go">net.ipv4.tcp_sack = 0
</span><span class="gp">x@node-1:~$</span><span class="w"> </span><span class="nb">sudo </span>iptables <span class="nt">-A</span> INPUT <span class="nt">-p</span> tcp <span class="nt">--dport</span> 6666 <span class="nt">-m</span> statistic <span class="nt">--mode</span> nth <span class="nt">--every</span> 2 <span class="nt">--packet</span> 0 <span class="nt">-j</span> DROP
<span class="gp">x@node-1:~$</span><span class="w"> </span><span class="nb">sudo </span>iptables <span class="nt">-L</span> INPUT
<span class="go">Chain INPUT (policy ACCEPT)
target     prot opt source               destination
DROP       tcp  --  anywhere             anywhere             tcp dpt:6666 statistic mode nth every 2</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>ethtool <span class="nt">-K</span> ens32 tso off
<span class="gp">x@node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>sysctl net.ipv4.tcp_sack<span class="o">=</span>0
<span class="go">net.ipv4.tcp_sack = 0
</span><span class="gp">x@node-0:~$</span><span class="w"> </span><span class="nb">head</span> <span class="nt">-c</span> 10000 /dev/random | nc <span class="nt">-v</span> node-1 6666
<span class="go">Ncat: Version 7.80 ( https://nmap.org/ncat )
Ncat: Connected to 192.168.91.137:6666.
Ncat: 10000 bytes sent, 0 bytes received in 2.50 seconds.</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/tcp-timeout-and-retransmission/fast-retransmit-wireshark.png" alt="fast retransmit wireshark" width="100%" height="100%">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The packets 23 and 28 are window update ACKs with a duplicate sequence number (because no data is being carried) but contains a change to the TCP flow control window. The window changes from 65,160 bytes to 63,488 bytes.</p>
<div class="paragraph">
<p>Thus, it is not counted toward the three-duplicate-ACK threshold required to initiate a fast retransmit.</p>
</div>
<div class="paragraph">
<p>Window updates merely provide a copy of the window advertisement.</p>
</div>
</li>
<li>
<p>The packets 14 and 15 are all duplicate ACKs for sequence number 1449.</p>
<div class="paragraph">
<p>The arrival of the second of these duplicate ACKs triggers the fast retransmit of segment 1449 by packets 16 and 17.</p>
</div>
</li>
<li>
<p>The retransmissions from packet 19 to 22 are somewhat different from the first two.</p>
<div class="paragraph">
<p>When the first two retransmissions takes place, the sending TCP notes the highest sequence number (called the <strong>recovery point</strong>) it had sent just before it performed the retransmission (9641 + 360 = 10001).</p>
</div>
<div class="paragraph">
<p>TCP is considered to be recovering from loss after a retransmission until it receives an ACK that matches or exceeds the sequence number of the recovery point.</p>
</div>
<div class="paragraph">
<p>In this example, the ACKs at packet 18 are not for 10001, but instead for 5793.</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>This number is larger than the previous highest ACK value seen (1449), but not enough to meet or exceed the recovery point (10001).</p>
</li>
<li>
<p>This type of ACK is called a <strong>partial ACK</strong> for this reason.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>When partial ACKs arrive, the sending TCP immediately sends the segments that appears to be missing (5793 to 9641 in this case) and continues this way until the recovery point is matched or exceeded by an arriving ACK.</p>
</div>
<div class="paragraph">
<p>If permitted by congestion control procedures, it may also send new data it has not yet sent.</p>
</div>
</li>
<li>
<p>Because no SACKs are being used, the sender can learn of at most one receiver hole per round-trip time, indicated by the increase in the ACK number of returning packets, which can only occur once a retransmission filling the receiver’s lowest-numbered hole has been received and ACKed.</p>
</li>
</ul>
</div>
<details>
<summary class="title">Show tcpdump trace</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="gp"> 00:00:00.000000 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>S], <span class="nb">seq </span>2395807434, win 64240, options <span class="o">[</span>mss 1460,nop,nop,TS val 3245551521 ecr 0,nop,wscale 7], length 0
<span class="gp"> 00:00:01.013807 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>S], <span class="nb">seq </span>2395807434, win 64240, options <span class="o">[</span>mss 1460,nop,nop,TS val 3245552536 ecr 0,nop,wscale 7], length 0
<span class="gp"> 00:00:01.014094 IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.58368: Flags <span class="o">[</span>S.], <span class="nb">seq </span>3105090969, ack 2395807435, win 65160, options <span class="o">[</span>mss 1460,nop,nop,TS val 939993754 ecr 3245552536,nop,wscale 7], length 0
<span class="gp"> 00:00:01.014138 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245552536 ecr 939993754], length 0
<span class="gp"> 00:00:01.014253 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>1:1449, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245552536 ecr 939993754], length 1448
<span class="gp"> 00:00:01.014303 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>1449:2897, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245552536 ecr 939993754], length 1448
<span class="gp"> 00:00:01.014329 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>2897:4345, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245552536 ecr 939993754], length 1448
<span class="gp"> 00:00:01.014330 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>4345:5793, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245552536 ecr 939993754], length 1448
<span class="gp"> 00:00:01.014331 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>5793:7241, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245552536 ecr 939993754], length 1448
<span class="gp"> 00:00:01.014367 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>7241:8193, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245552536 ecr 939993754], length 952
<span class="gp"> 00:00:01.014392 IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.58368: Flags <span class="o">[</span>.], ack 1449, win 501, options <span class="o">[</span>nop,nop,TS val 939993754 ecr 3245552536], length 0
<span class="gp"> 00:00:01.014401 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>8193:9641, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245552536 ecr 939993754], length 1448
<span class="gp"> 00:00:01.014419 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>FP.], <span class="nb">seq </span>9641:10001, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245552536 ecr 939993754], length 360
<span class="gp"> 00:00:01.014498 IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.58368: Flags <span class="o">[</span>.], ack 1449, win 501, options <span class="o">[</span>nop,nop,TS val 939993754 ecr 3245552536], length 0
<span class="gp"> 00:00:01.014498 IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.58368: Flags <span class="o">[</span>.], ack 1449, win 501, options <span class="o">[</span>nop,nop,TS val 939993754 ecr 3245552536], length 0
<span class="gp"> 00:00:01.221646 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>1449:2897, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245552743 ecr 939993754], length 1448
<span class="gp"> 00:00:01.653752 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>1449:2897, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245553175 ecr 939993754], length 1448
<span class="gp"> 00:00:01.654191 IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.58368: Flags <span class="o">[</span>.], ack 5793, win 473, options <span class="o">[</span>nop,nop,TS val 939994394 ecr 3245553175], length 0
<span class="gp"> 00:00:01.654217 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>5793:7241, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245553176 ecr 939994394], length 1448
<span class="gp"> 00:00:01.654221 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>7241:8193, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245553176 ecr 939994394], length 952
<span class="gp"> 00:00:01.654278 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>8193:9641, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245553176 ecr 939994394], length 1448
<span class="gp"> 00:00:01.654303 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>FP.], <span class="nb">seq </span>9641:10001, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245553176 ecr 939994394], length 360
<span class="gp"> 00:00:01.654539 IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.58368: Flags <span class="o">[</span>.], ack 5793, win 496, options <span class="o">[</span>nop,nop,TS val 939994394 ecr 3245553175], length 0
<span class="gp"> 00:00:01.862139 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>5793:7241, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245553384 ecr 939994394], length 1448
<span class="gp"> 00:00:01.862428 IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.58368: Flags <span class="o">[</span>.], ack 7241, win 488, options <span class="o">[</span>nop,nop,TS val 939994602 ecr 3245553384], length 0
<span class="gp"> 00:00:01.862444 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>7241:8193, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245553384 ecr 939994602], length 952
<span class="gp"> 00:00:01.862475 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>8193:9641, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245553384 ecr 939994602], length 1448
<span class="gp"> 00:00:01.862675 IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.58368: Flags <span class="o">[</span>.], ack 7241, win 496, options <span class="o">[</span>nop,nop,TS val 939994602 ecr 3245553384], length 0
<span class="gp"> 00:00:02.070061 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>7241:8193, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245553592 ecr 939994602], length 952
<span class="gp"> 00:00:02.486074 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>7241:8193, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3245554008 ecr 939994602], length 952
<span class="gp"> 00:00:02.486555 IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.58368: Flags <span class="o">[</span>.], ack 10002, win 489, options <span class="o">[</span>nop,nop,TS val 939995226 ecr 3245554008], length 0
<span class="gp"> 00:00:02.486557 IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.58368: Flags <span class="o">[</span>F.], <span class="nb">seq </span>1, ack 10002, win 501, options <span class="o">[</span>nop,nop,TS val 939995226 ecr 3245554008], length 0
<span class="gp"> 00:00:02.486636 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], ack 2, win 502, options <span class="o">[</span>nop,nop,TS val 3245554008 ecr 939995226], length 0
<span class="gp"> 00:00:02.717525 IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.58368: Flags <span class="o">[</span>F.], <span class="nb">seq </span>1, ack 10002, win 501, options <span class="o">[</span>nop,nop,TS val 939995457 ecr 3245554008], length 0
<span class="gp"> 00:00:02.717540 IP 192.168.91.128.58368 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], ack 2, win 502, options <span class="o">[</span>nop,nop,TS val 3245554239 ecr 939995226], length 0
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</details>
</div>
</div>
<div class="sect1">
<h2 id="retransmission-with-selective-acknowledgments">5. Retransmission with Selective Acknowledgments</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With the standardization of the Selective Acknowledgment options in <a href="#RFC2018">[RFC2018]</a>, a SACK-capable TCP receiver is able to describe data it has received with sequence numbers beyond the cumulative <em>ACK Number</em> field it sends in the primary portion of the TCP header.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The gaps between the ACK number and other in-window data cached at the receiver are called <strong>holes</strong>.</p>
</li>
<li>
<p>Data with sequence numbers beyond the holes are called <strong>out-of-sequence</strong> data because that data is not contiguous, in terms of its sequence numbers, with the other data the receiver has already received.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The job of a sending TCP is to fill the holes in the receiver by retransmitting any data the receiver is missing, yet to be as efficient as possible by not resending data the receiver already has.</p>
</div>
<div class="paragraph">
<p>In many circumstances, the properly operating SACK sender is able to fill these holes more quickly and with fewer unnecessary retransmissions than a comparable non-SACK sender because it does not have to wait an entire RTT to learn about additional holes.</p>
</div>
<div class="paragraph">
<p>When the SACK option is being used, an ACK can be augmented with up to three or four SACK blocks that contain information about out-of-sequence data at the receiver.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each <strong>SACK block</strong> contains two 32-bit sequence numbers representing the first and last sequence numbers (plus 1) of a continuous block of out-of-sequence data being held at the receiver.</p>
</li>
<li>
<p>A SACK option that specifies <em>n</em> blocks has a length of 8n + 2 bytes (8n bytes for the sequence numbers and 2 to indicate the option kind and length), so the 40 bytes available to hold TCP options can specify a maximum of four blocks.</p>
</li>
<li>
<p>It is expected that SACK will often be used in conjunction with the TSOPT, which takes an additional 10 bytes (plus 2 bytes of padding), meaning that SACK is typically able to include only three blocks per ACK.</p>
</li>
<li>
<p>With three distinct blocks, up to three holes can be reported to the sender.</p>
</li>
<li>
<p>If not limited by <em>congestion control</em>, all three could be filled within one round-trip time using a SACK-capable sender.</p>
</li>
<li>
<p>An ACK packet containing one or more SACK blocks is sometimes called simply a <strong>SACK</strong>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">=&gt;</span><span class="w"> </span><span class="o">[</span>.], <span class="nb">seq </span>1:1449, ack 1, <span class="o">[</span>TS val 3251433112 ecr 945874299], length 1448
<span class="gp">=&gt;</span><span class="w"> </span><span class="o">[</span>P.], <span class="nb">seq </span>1449:2897, ack 1, <span class="o">[</span>TS val 3251433112 ecr 945874299], length 1448
<span class="gp">=&gt;</span><span class="w"> </span><span class="o">[</span>.], <span class="nb">seq </span>2897:4345, ack 1, <span class="o">[</span>TS val 3251433112 ecr 945874299], length 1448
<span class="gp">=&gt;</span><span class="w"> </span><span class="o">[</span>P.], <span class="nb">seq </span>4345:5793, ack 1, <span class="o">[</span>TS val 3251433112 ecr 945874299], length 1448
<span class="gp">=&gt;</span><span class="w"> </span><span class="o">[</span>.], <span class="nb">seq </span>5793:7241, ack 1, <span class="o">[</span>TS val 3251433112 ecr 945874299], length 1448
<span class="gp">=&gt;</span><span class="w"> </span><span class="o">[</span>P.], <span class="nb">seq </span>7241:8193, ack 1, <span class="o">[</span>TS val 3251433112 ecr 945874299], length 952
<span class="go">&lt;= [.], ack 1449, [TS val 945874300 ecr 3251433112], length 0
</span><span class="gp">=&gt;</span><span class="w"> </span><span class="o">[</span>.], <span class="nb">seq </span>8193:9641, ack 1, <span class="o">[</span>TS val 3251433113 ecr 945874300], length 1448
<span class="gp">=&gt;</span><span class="w"> </span><span class="o">[</span>FP.], <span class="nb">seq </span>9641:10001, ack 1, <span class="o">[</span>TS val 3251433113 ecr 945874300], length 360
<span class="go">
&lt;= [.], ack 1449, [TS val 945874300 ecr 3251433112,sack 1 {2897:5793}], length 0
&lt;= [.], ack 1449, [TS val 945874300 ecr 3251433112,sack 2 {8193:10002}{2897:5793}], length 0

</span><span class="gp">=&gt;</span><span class="w"> </span><span class="o">[</span>.], <span class="nb">seq </span>1449:2897, ack 1, <span class="o">[</span>TS val 3251433113 ecr 945874300], length 1448
<span class="gp">=&gt;</span><span class="w"> </span><span class="o">[</span>.], <span class="nb">seq </span>5793:7241, ack 1, <span class="o">[</span>TS val 3251433113 ecr 945874300], length 1448</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="sack-receiver-behavior">5.1. SACK Receiver Behavior</h3>
<div class="paragraph">
<p>A SACK-capable receiver is allowed to generate SACKs if it has received the SACK-Permitted option during the TCP connection establishment.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">// The SACK-Permitted option is exchanged in SYN segments to indicate the capability to generate and process SACK information.
// Most modern TCPs support the MSS, Timestamps, Window Scale, and SACK-Permitted options during connection establishment.
</span><span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>S], <span class="nb">seq </span>3680115076, win 64240, options <span class="o">[</span>mss 1460,sackOK,TS val 3251433112 ecr 0,nop,wscale 7], length 0
<span class="gp">IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.56276: Flags <span class="o">[</span>S.], <span class="nb">seq </span>2651302134, ack 3680115077, win 65160, options <span class="o">[</span>mss 1460,sackOK,TS val 945874299 ecr 3251433112,nop,wscale 7], length 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Generally speaking, a receiver generates SACKs whenever there is any out-of-order data in its buffer. This can happen either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>because data was <em>lost</em> in transit, or</p>
</li>
<li>
<p>because it has been reordered and newer data has arrived at the receiver before older data.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The receiver places in the first SACK block the sequence number range contained in the segment it has <em>most recently received</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Because the space in a SACK option is limited, it is best to ensure that the most recent information is always provided to the sending TCP, if possible.</p>
</li>
<li>
<p>Other SACK blocks are listed in the order in which they appeared as first blocks in previous SACK options.</p>
<div class="paragraph">
<p>That is, they are filled in by repeating the most recently sent SACK blocks (in other segments) that are not subsets of another block about to be placed in the option being constructed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="go">&lt;= [.], ack 1449, [TS val 945874300 ecr 3251433112], length 0
&lt;= [.], ack 1449, [TS val 945874300 ecr 3251433112,sack 1 {2897:5793}], length 0
&lt;= [.], ack 1449, [TS val 945874300 ecr 3251433112,sack 2 {8193:10002}{2897:5793}], length 0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The purpose of including more than one SACK block in a SACK option and repeating these blocks across multiple SACKs is to provide some redundancy in the case where SACKs are lost.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If SACKs were never lost, <a href="#RFC2018">[RFC2018]</a> points out that only one SACK block would be required per SACK for full SACK functionality.</p>
</li>
<li>
<p>Unfortunately, SACKs and regular ACKs are sometimes lost and are not retransmitted by TCP unless they contain data (or the <em>SYN</em> or <em>FIN</em> control bit fields are turned on).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="sack-sender-behavior">5.2. SACK Sender Behavior</h3>
<div class="paragraph">
<p>A SACK-capable sender must be used that treats the SACK blocks appropriately and performs <strong>selective retransmission</strong> by sending only those segments missing at the receiver, a process also called <strong>selective repeat</strong>.</p>
</div>
<div class="paragraph">
<p>The SACK sender keeps track of any cumulative ACK information it receives (like any TCP sender), plus any SACK information it receives.</p>
</div>
<div class="paragraph">
<p>When a SACK-capable sender has the opportunity to perform a retransmission, usually because it has received a SACK or seen multiple duplicate ACKs, it has the choice of whether it sends new data or retransmits old data.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The SACK information provides the sequence number ranges present at the receiver, so the sender can infer what segments likely need to be retransmitted to fill the receiver&#8217;s holes.</p>
</li>
<li>
<p>The simplest approach is to have the sender first fill the holes at the receiver and then move on to send more new data <a href="#RFC3517">[RFC3517]</a> if the congestion control procedures allow. This is the most common approach.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="example">5.3. Example</h3>
<div class="paragraph">
<p>To understand how the use of SACK alters the sender and receiver behaviors, we repeat the preceding fast retransmit experiment, but this time the sender and receiver are using SACK.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/tcp-timeout-and-retransmission/fast-retransmit-with-sack-wireshark.png" alt="fast retransmit with sack wireshark" width="100%" height="100%">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The SYN packet from the sender, the first packet of the trace, also contains an identical option.</p>
<div class="paragraph">
<p>These options are present only at connection setup, and thus they only ever appear in segments with the <em>SYN bit</em> field set.</p>
</div>
<div class="paragraph">
<p>Once the connection is permitted to use SACKs, packet loss generally causes the receiver to start producing SACKs.</p>
</div>
</li>
<li>
<p>The ACK at packet 14 for 1449 contains a SACK block of [2897:5793], indicating a hole at the receiver.</p>
<div class="paragraph">
<p>The receiver is missing the sequence number range [1449,2896], which corresponds to the single 1448-byte packet starting with sequence number 1449.</p>
</div>
</li>
<li>
<p>The SACK arriving at packet 15 contains two SACK blocks: [8193:10002] and [2897:5793].</p>
<div class="paragraph">
<p>Recall that the first SACK blocks from previous SACKs are repeated in later positions in subsequent SACKs for robustness against ACK loss.</p>
</div>
<div class="paragraph">
<p>This SACK is a duplicate ACK for sequence number 1449 and suggests that the receiver now requires the missing segments starting with sequence numbers 1449 and 5793.</p>
</div>
</li>
<li>
<p>The SACK sender has not had to wait an RTT to retransmit lost segment 5793 after retransmitting segment 1449.</p>
</li>
</ul>
</div>
<details>
<summary class="title">Show tcpdump trace</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>S], <span class="nb">seq </span>3680115076, win 64240, options <span class="o">[</span>mss 1460,sackOK,TS val 3251432089 ecr 0,nop,wscale 7], length 0
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>S], <span class="nb">seq </span>3680115076, win 64240, options <span class="o">[</span>mss 1460,sackOK,TS val 3251433112 ecr 0,nop,wscale 7], length 0
<span class="gp">IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.56276: Flags <span class="o">[</span>S.], <span class="nb">seq </span>2651302134, ack 3680115077, win 65160, options <span class="o">[</span>mss 1460,sackOK,TS val 945874299 ecr 3251433112,nop,wscale 7], length 0
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433112 ecr 945874299], length 0
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>1:1449, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433112 ecr 945874299], length 1448
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>1449:2897, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433112 ecr 945874299], length 1448
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>2897:4345, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433112 ecr 945874299], length 1448
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>4345:5793, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433112 ecr 945874299], length 1448
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>5793:7241, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433112 ecr 945874299], length 1448
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>7241:8193, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433112 ecr 945874299], length 952
<span class="gp">IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.56276: Flags <span class="o">[</span>.], ack 1449, win 501, options <span class="o">[</span>nop,nop,TS val 945874300 ecr 3251433112], length 0
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>8193:9641, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433113 ecr 945874300], length 1448
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>FP.], <span class="nb">seq </span>9641:10001, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433113 ecr 945874300], length 360
<span class="gp">IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.56276: Flags <span class="o">[</span>.], ack 1449, win 501, options <span class="o">[</span>nop,nop,TS val 945874300 ecr 3251433112,nop,nop,sack 1 <span class="o">{</span>2897:5793<span class="o">}]</span>, length 0
<span class="gp">IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.56276: Flags <span class="o">[</span>.], ack 1449, win 501, options <span class="o">[</span>nop,nop,TS val 945874300 ecr 3251433112,nop,nop,sack 2 <span class="o">{</span>8193:10002<span class="o">}{</span>2897:5793<span class="o">}]</span>, length 0
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>1449:2897, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433113 ecr 945874300], length 1448
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>5793:7241, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433113 ecr 945874300], length 1448
<span class="gp">IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.56276: Flags <span class="o">[</span>.], ack 1449, win 501, options <span class="o">[</span>nop,nop,TS val 945874301 ecr 3251433112,nop,nop,sack 2 <span class="o">{</span>2897:7241<span class="o">}{</span>8193:10002<span class="o">}]</span>, length 0
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>1449:2897, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433113 ecr 945874301], length 1448
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], <span class="nb">seq </span>1449:2897, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433324 ecr 945874301], length 1448
<span class="gp">IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.56276: Flags <span class="o">[</span>.], ack 7241, win 465, options <span class="o">[</span>nop,nop,TS val 945874513 ecr 3251433324,nop,nop,sack 1 <span class="o">{</span>8193:10002<span class="o">}]</span>, length 0
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>7241:8193, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433326 ecr 945874513], length 952
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>7241:8193, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3251433532 ecr 945874513], length 952
<span class="gp">IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.56276: Flags <span class="o">[</span>.], ack 10002, win 489, options <span class="o">[</span>nop,nop,TS val 945874720 ecr 3251433532], length 0
<span class="gp">IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.56276: Flags <span class="o">[</span>F.], <span class="nb">seq </span>1, ack 10002, win 501, options <span class="o">[</span>nop,nop,TS val 945874720 ecr 3251433532], length 0
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], ack 2, win 502, options <span class="o">[</span>nop,nop,TS val 3251433533 ecr 945874720], length 0
<span class="gp">IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.56276: Flags <span class="o">[</span>F.], <span class="nb">seq </span>1, ack 10002, win 501, options <span class="o">[</span>nop,nop,TS val 945874926 ecr 3251433532], length 0
<span class="gp">IP 192.168.91.128.56276 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], ack 2, win 502, options <span class="o">[</span>nop,nop,TS val 3251433739 ecr 945874720], length 0
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</details>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spurious-timeouts-and-retransmissions">6. Spurious Timeouts and Retransmissions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Under a number of circumstances, TCP may initiate a retransmission even when no data has been lost.</p>
</div>
<div class="paragraph">
<p>Such undesirable retransmissions are called <strong>spurious retransmissions</strong> and are caused by <em>spurious timeouts</em> (timeouts firing too early) and other reasons such as <em>packet reordering</em>, <em>packet duplication</em>, or <em>lost ACKs</em>.</p>
</div>
<div class="paragraph">
<p>Spurious timeouts can occur when the real RTT has recently increased significantly, beyond the RTO. This happens more frequently in environments where lower-layer protocols have widely varying performance (e.g., wireless).</p>
</div>
<div class="paragraph">
<p>A number of approaches have been suggested to deal with spurious timeouts. They generally involve a <strong>detection algorithm</strong> and a <strong>response algorithm</strong>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The detection algorithm attempts to determine whether a timeout or timer-based retransmission was spurious.</p>
</li>
<li>
<p>The response algorithm is invoked once a timeout or retransmission is deemed spurious.</p>
<div class="paragraph">
<p>Its purpose is to undo or mitigate some action that is otherwise normally performed by TCP when a retransmission timer expires.</p>
</div>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/tcp-timeout-and-retransmission/suprious-timeout-spike-delay.png" alt="suprious timeout spike delay" width="25%" height="25%">
</div>
<div class="title">Figure 1. A delay spike occurs after the transmission of packet 8, causing a spurious retransmission timeout and retransmission of packet 5. After retransmission, an ACK for the first copy of 5 arrives. The retransmission for 5 creates a duplicate packet at the receiver, followed by an undesirable "go-back-N" behavior whereby packets 6, 7, and 8 are retransmitted even though they are already present at the receiver.</div>
</div>
<div class="sect2">
<h3 id="duplicate-sack-dsack-extension">6.1. Duplicate SACK (DSACK) Extension</h3>
<div class="paragraph">
<p>With a non-SACK TCP, an ACK can indicate only the highest in-sequence segment back to the sender. With SACK, it can signal other (out-of-order) segments as well.</p>
</div>
<div class="paragraph">
<p><em>DSACK</em> or <em>D-SACK</em> (stands for <em>duplicate SACK</em> <a href="#RFC2883">[RFC2883]</a>) is a rule, applied at the SACK receiver and interoperable with conventional SACK senders, that causes <em>the first SACK block to indicate the sequence numbers of a duplicate segment that has arrived at the receiver</em>, which is usually to determine when a retransmission was not necessary and to learn additional facts about the network.</p>
</div>
<div class="paragraph">
<p>The change to the SACK <em>receiver</em> is to allow a SACK block to be included even if it covers sequence numbers below (or equal to) the cumulative <em>ACK Number</em> field.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It applies equally well in cases where the DSACK information is <em>above</em> the cumulative <em>ACK Number</em> field; this happens for duplicated out-of-order segments.</p>
</li>
<li>
<p>DSACK information is included in only a single ACK, and such an ACK is called a <strong>DSACK</strong>.</p>
</li>
<li>
<p>DSACK information is not repeated across multiple SACKs as conventional SACK information is.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Exactly what a <em>sender</em> given DSACK information is supposed to do with it is not specified by <a href="#RFC2883">[RFC2883]</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="the-eifel-detection-algorithm">6.2. The Eifel Detection Algorithm</h3>
<div class="paragraph">
<p>The experimental <em>Eifel Detection Algorithm</em> <a href="#RFC3522">[RFC3522]</a> deals with the retransmission ambiguity problem using the TCP TSOPT to detect spurious retransmissions.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>After a retransmission timeout occurs, Eifel awaits the next acceptable ACK.</p>
</li>
<li>
<p>If the next acceptable ACK indicates that the first copy of a retransmitted packet (called the <em>original transmit</em>) was the cause for the ACK, the retransmission is considered to be spurious.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Eifel Detection Algorithm is able to detect spurious behavior earlier than the approach using only DSACK because it relies on ACKs generated as a result of packets arriving before loss recovery is initiated.</p>
</div>
<div class="paragraph">
<p>DSACKs, conversely, are able to be sent only after a duplicate segment has arrived at the receiver and able to be acted upon only after the DSACK is returned to the sender.</p>
</div>
<div class="paragraph">
<p>Detecting spurious retransmissions early can offer advantages, because it allows the sender to avoid most of the <em>go-back-N</em> behavior.</p>
</div>
<div class="paragraph">
<p>The mechanics of the Eifel Detection Algorithm are simple. It requires the use of the TCP TSOPT.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When a retransmission is sent (either a timer-based retransmission or a fast retransmit), the TSV value is stored.</p>
</li>
<li>
<p>When the first acceptable ACK covering its sequence number is received, the incoming ACK&#8217;s TSER is examined.</p>
</li>
<li>
<p>If it is smaller than the stored value, the ACK corresponds to the original transmission of the packet and not the retransmission, implying that the retransmission must have been spurious.</p>
</li>
<li>
<p>This approach is fairly robust to ACK loss as well.</p>
<div class="ulist">
<ul>
<li>
<p>If an ACK is lost, any subsequent ACKs still have TSER values less than the stored TSV of the retransmitted segment.</p>
</li>
<li>
<p>Thus, a retransmission can be deemed spurious as a result of any of the window&#8217;s worth of ACKs arriving, so a loss of any single ACK is not likely to cause a problem.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Eifel Detection Algorithm can be combined with DSACKs which can be beneficial when an entire window&#8217;s worth of ACKs are lost but both the original transmit and retransmission have arrived at the receiver.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In this particular case, the arriving retransmit causes a DSACK to be generated.</p>
</li>
<li>
<p>The Eifel Detection Algorithm would by default conclude that the retransmission is spurious.</p>
</li>
<li>
<p>It is thought, however, that if so many ACKs are being lost, allowing TCP to believe the retransmission was not spurious is useful (e.g., to induce it to start sending more slowly—a consequence of the congestion control procedures).</p>
</li>
<li>
<p>Thus, arriving DSACKs cause the Eifel Detection Algorithm to conclude that the corresponding retransmission is not spurious.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="forward-rto-recovery-f-rto">6.3. Forward-RTO Recovery (F-RTO)</h3>
<div class="paragraph">
<p><em>Forward-RTO Recovery (F-RTO)</em> <a href="#RFC5682">[RFC5682]</a> is a standard algorithm for detecting spurious retransmissions.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It does not require any TCP options, so when it is implemented in a sender, it can be used effectively even with an older receiver that does not support the TCP TSOPT.</p>
</li>
<li>
<p>It attempts to detect only spurious retransmissions caused by expiration of the retransmission timer; it does not deal with the other causes for spurious retransmissions or duplications mentioned before.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>F-RTO makes a modification to the action TCP ordinarily takes after a timer-based retransmission.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>These retransmissions are for the smallest sequence number for which no ACK has yet been received.</p>
</li>
<li>
<p>Ordinarily, TCP continues sending additional adjacent packets in order as additional ACKs arrive. This is the <em>go-back-N</em> behavior.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>F-RTO modifies the ordinary behavior of TCP by having TCP send new (so far unsent) data after the timeout-based retransmission when the first ACK arrives. It then inspects the second arriving ACK.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If either of the first two ACKs arriving after the retransmission was sent are duplicate ACKs, the retransmission is deemed OK.</p>
</li>
<li>
<p>If they are both acceptable ACKs that advance the sender&#8217;s window, the retransmission is deemed to have been spurious.</p>
</li>
<li>
<p>If the transmission of new data results in the arrival of acceptable ACKs, the arrival of the new data is moving the receiver&#8217;s window forward.</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>If such data is only causing duplicate ACKs, there must be one or more holes at the receiver.</p>
</li>
<li>
<p>In either case, the reception of new data at the receiver does not harm the overall data transfer performance (provided there are sufficient buffers at the receiver).</p>
</li>
</ul>
</div>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="the-eifel-response-algorithm">6.4. The Eifel Response Algorithm</h3>
<div class="paragraph">
<p>The <em>Eifel Response Algorithm</em> [RFC4015] is a standard set of operations to be executed by a TCP once a retransmission has been deemed spurious.</p>
</div>
<div class="paragraph">
<p>Because the response algorithm is logically decoupled from the Eifel Detection Algorithm, it can be used with any of the detection algorithms we just discussed.</p>
</div>
<div class="paragraph">
<p>The Eifel Response Algorithm was originally intended to operate for both timer-based and fast retransmit spurious retransmissions but is currently specified only for timer-based retransmissions.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="packet-reordering-and-duplication">7. Packet Reordering and Duplication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to packet loss, other packet delivery anomalies such as duplication and reordering can also affect TCP&#8217;s operation. In both of these cases, we wish TCP to be able to distinguish between packets that are reordered or duplicated and those that are lost.</p>
</div>
<div class="sect2">
<h3 id="reordering">7.1. Reordering</h3>
<div class="paragraph">
<p>Packet reordering can occur in an IP network because IP provides no guarantee that relative ordering between packets is maintained during delivery.</p>
</div>
<div class="paragraph">
<p>This can be beneficial (to IP at least), because IP can choose another path for traffic (e.g., that is faster) without having to worry about the consequences that doing so may cause traffic freshly injected into the network to pass ahead of older traffic, resulting in the order of packet arrivals at the receiver not matching the order of transmission at the sender.</p>
</div>
<div class="paragraph">
<p>There are other reasons packet reordering may occur. For example, some high-performance routers employ multiple parallel data paths within the hardware [BPS99], and different processing delays among packets can lead to a departure order that does not match the arrival order.</p>
</div>
<div class="paragraph">
<p>Reordering may take place in the <em>forward path</em> or the <em>reverse path</em> of a TCP connection (or in some cases both). The reordering of data segments has a somewhat different effect on TCP as does reordering of ACK packets.</p>
</div>
<div class="paragraph">
<p>Recall that because of <em>asymmetric routing</em>, it is frequently the case that ACKs travel along different network links (and through different routers) from data packets on the forward path.</p>
</div>
<div class="paragraph">
<p>When traffic is reordered, TCP can be affected in several ways.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If reordering takes place in the reverse (ACK) direction, it causes the sending TCP to receive some ACKs that move the window significantly forward followed by some evidently old redundant ACKs that are discarded.</p>
<div class="paragraph">
<p>This can lead to an unwanted <em>burstiness</em> (instantaneous high-speed sending) behavior in the sending pattern of TCP and also trouble in taking advantage of available network bandwidth, because of the behavior of TCP&#8217;s congestion control.</p>
</div>
</li>
<li>
<p>If reordering occurs in the forward direction, TCP may have trouble distinguishing this condition from loss.</p>
<div class="paragraph">
<p>Both loss and reordering result in the receiver receiving out-of-order packets that create holes between the next expected packet and the other packets received so far.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When reordering is moderate (e.g., two adjacent packets switch order), the situation can be handled fairly quickly.</p>
</li>
<li>
<p>When reorderings are more severe, TCP can be tricked into believing that data has been lost even though it has not.</p>
<div class="paragraph">
<p>This can result in spurious retransmissions, primarily from the fast retransmit algorithm.</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Because a TCP receiver is supposed to immediately ACK any out-of-sequence data it receives in order to help induce fast retransmit to be triggered on packet loss, any packet that is reordered within the network causes a receiver to produce a duplicate ACK.</p>
</div>
<div class="paragraph">
<p>If fast retransmit were to be invoked whenever any duplicate ACK is received at the sender, a large number of unnecessary retransmissions would occur on network paths where a small amount of reordering is common.</p>
</div>
<div class="paragraph">
<p>To handle this situation, fast retransmit is triggered only after the duplicate threshold (<em>dupthresh</em>) has been reached.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/tcp-timeout-and-retransmission/packet-reordering-fast-retransit.png" alt="packet reordering fast retransit" width="45%" height="45%">
</div>
<div class="title">Figure 2. Mild reordering (left) is overcome by ignoring a small number of duplicate ACKs. When reordering is more severe (right), as in this case where packet 4 is three places out of sequence, a spurious fast retransmit can be triggered.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The left portion of the figure indicates how TCP behaves with light reordering, where <em>dupthresh</em> is set to 3.</p>
<div class="paragraph">
<p>In this case, the single duplicate ACK does not affect TCP. It is effectively ignored and TCP overcomes the reordering.</p>
</div>
</li>
<li>
<p>The right-hand side indicates what happens when a packet has been more severely reordered.</p>
<div class="paragraph">
<p>Because it is three positions out of sequence, three duplicate ACKs are generated. This invokes the fast retransmit procedure in the sending TCP, producing a duplicate segment at the receiver.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The problem of distinguishing loss from reordering is not trivial. Dealing with it involves trying to decide when a sender has waited long enough to try to fill apparent holes at the receiver.</p>
</div>
<div class="paragraph">
<p>Fortunately, severe reordering on the Internet is not common <a href="#J03">[J03]</a>, so setting <em>dupthresh</em> to a relatively small number (such as the default of 3) handles most circumstances. That said, there are a number of research projects that modify TCP to handle more severe reordering <a href="#LLY07">[LLY07]</a>. Some of these adjust <em>dupthresh</em> dynamically, as does the Linux TCP implementation.</p>
</div>
</div>
<div class="sect2">
<h3 id="duplication">7.2. Duplication</h3>
<div class="paragraph">
<p>Although rare, the IP protocol may deliver a single packet more than one time. This can happen, for example, when a link-layer network protocol performs a retransmission and creates two copies of the same packet.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/tcp-ip/tcp-timeout-and-retransmission/packet-dup-fast-retransit.png" alt="packet dup fast retransit" width="25%" height="25%">
</div>
<div class="title">Figure 3. Packet (no. 3) duplication in the network has caused a spurious fast retransmission due to the presence of duplicate ACKs.</div>
</div>
<div class="paragraph">
<p>The effect of packet 3 being duplicated is to produce a series of duplicate ACKs from the receiver. This is enough to trigger a spurious fast retransmit, as the non-SACK sender may mistakenly believe that packets 5 and 6 have arrived earlier. With SACK (and DSACK, in particular) this is more easily diagnosed at the sender.</p>
</div>
<div class="paragraph">
<p>With DSACK, each of the duplicate ACKs for A3 contains DSACK information that segment 3 has already been received. Furthermore, none of them contains an indication of any out-of-order data, meaning the arriving packets (or their ACKs) must have been duplicates. TCP can often suppress spurious retransmissions in such cases.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="destination-metrics">8. Destination Metrics</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Newer TCP implementations maintain many of the metrics such as <em>srtt</em>, <em>rttvar</em> and so on. in a routing or forwarding table entry or other systemwide data structure that exists even after TCP connections are closed.</p>
</div>
<div class="paragraph">
<p>When a new connection is created, TCP consults the data structure to see if there is any preexisting information regarding the path to the destination host with which it will be communicating.</p>
</div>
<div class="paragraph">
<p>If so, initial values for <em>srtt</em>, <em>rttvar</em>, and so on can be initialized to some value based on previous, relatively recent experience.</p>
</div>
<div class="paragraph">
<p>When a TCP connection closes down, it has the opportunity to update the statistics. This can be accomplished by replacing the existing statistics or updating them in some other way.</p>
</div>
<div class="paragraph">
<p>In the case of Linux 2.6, the values are updated to be the maximum of the existing values and those measured by the most recent TCP. These values can be inspected using the <code>ip</code> program available from the iproute2 suite of tools:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>ip route show cache 10.170.109.10
<span class="go">10.170.109.10 via 192.168.91.137 dev ens32
    cache expires 558se cmtu 1500 rtt 29ms rttvar 29ms cwnd 2 advmss 1460 hoplimit 64</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="repacketization">9. Repacketization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When TCP times out and retransmits, it does not have to retransmit the identical segment. Instead, TCP is allowed to perform <em>repacketization</em>, sending a bigger segment, which can increase performance. Naturally, this bigger segment cannot exceed the MSS announced by the receiver and should not exceed the path MTU.</p>
</div>
<div class="paragraph">
<p>This is allowed in the protocol because TCP identifies the data being sent and acknowledged by its byte number, not its segment (or packet) number.</p>
</div>
<div class="paragraph">
<p>TCP&#8217;s ability to retransmit a segment with a different size from the original segment provides another way of addressing the retransmission ambiguity problem. This has been the basis of an idea called STODER <a href="#TZZ05">[TZZ05]</a> that uses repacketization to detect spurious timeouts.</p>
</div>
<div class="paragraph">
<p>We can easily see repacketization in action. We use our <code>nc</code> program as a server and connect to it with <code>telnet</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First we type the line <code>hello there</code>.</p>
<div class="paragraph">
<p>This produces a segment of 13 data bytes, including the carriage-return and newline characters produced when the Enter key is pressed.</p>
</div>
</li>
<li>
<p>We then disconnect the network and type <code>line number 2</code> (14 bytes, including the newline).</p>
</li>
<li>
<p>We then wait about 45s, type <code>and 3</code>, terminate the connection, and reconnect the network again:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-0:~$</span><span class="w"> </span>telnet node-1 6666
<span class="go">Trying 192.168.91.137...
Connected to node-1.
Escape character is '^]'.
hello there <i class="conum" data-value="1"></i><b>(1)</b>
line number 2 <i class="conum" data-value="2"></i><b>(2)</b>
and 3 <i class="conum" data-value="3"></i><b>(3)</b>
^]
</span><span class="gp">telnet&gt;</span><span class="w"> </span>q
<span class="go">Connection closed. <i class="conum" data-value="4"></i><b>(4)</b>
</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>(first line gets sent OK), (then we disconnect the Ethernet cable)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>(this line gets retransmitted)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>(this line gets transmitted and also carries the <em>FIN</em> bit field)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>(reconnect Ethernet)</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following highlighted line 7 show how the retransmission for sequence number 14 resulted in a repacketization to form a larger packet of size 22 bytes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="gp"> 00:00:03.941676 IP 192.168.91.128.36242 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>1:14, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3767361706 ecr 1569370162], length 13
<span class="gp"> 00:00:03.942475 IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.36242: Flags <span class="o">[</span>.], ack 14, win 509, options <span class="o">[</span>nop,nop,TS val 1569374104 ecr 3767361706], length 0
<span class="gp"> 00:00:19.901087 IP 192.168.91.128.36242 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>14:29, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3767377666 ecr 1569374104], length 15
<span class="c">....</span>
<span class="gp"> 00:00:46.705168 IP 192.168.91.128.36242 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>P.], <span class="nb">seq </span>14:29, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3767404470 ecr 1569374104], length 15
<span class="gp"> 00:00:51.189357 IP 192.168.91.128.36242 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>FP.], <span class="nb">seq </span>29:36, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3767408954 ecr 1569374104], length 7
<span class="hll"><span class="gp"> 00:01:13.587320 IP 192.168.91.128.36242 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>FP.], <span class="nb">seq </span>14:36, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val 3767431351 ecr 1569374104], length 22
</span><span class="gp"> 00:01:13.587777 IP 192.168.91.137.6666 &gt;</span><span class="w"> </span>192.168.91.128.36242: Flags <span class="o">[</span>F.], <span class="nb">seq </span>1, ack 37, win 509, options <span class="o">[</span>nop,nop,TS val 1569443750 ecr 3767431351], length 0
<span class="gp"> 00:01:13.587800 IP 192.168.91.128.36242 &gt;</span><span class="w"> </span>192.168.91.137.6666: Flags <span class="o">[</span>.], ack 2, win 502, options <span class="o">[</span>nop,nop,TS val 3767431352 ecr 1569443750], length 0
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dropping-packets-in-linux-using-tc-and-iptables">Appendix A: Dropping Packets in Linux using tc and iptables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are two simple ways to randomly drop packets on a Linux computer: using <code>tc</code>, the program dedicated for controlling traffic; and using <code>iptables</code>, the built-in firewall. <a href="#NETEM">[NETEM]</a><a href="#IPTABLES">[IPTABLES]</a><a href="#EBADNET">[EBADNET]</a><a href="#DPLTC">[DPLTC]</a></p>
</div>
<div class="sect2">
<h3 id="dropping-packets-with-tc">A.1. Dropping Packets with tc</h3>
<div class="paragraph">
<p><strong>tc</strong> controls the transmit queues of your kernel. Normally when applications on your computer generate data to send, the data is passed to your kernel (via TCP and IP) for transmission on the network interface. The packets are transmitted in a first-in-first-out (FIFO) order.</p>
</div>
<div class="paragraph">
<p><em>tc</em> allows you to change the queuing mechanisms (e.g. giving priority to specific type of packets), as well as emulate links by delaying and dropping packets.</p>
</div>
<div class="paragraph">
<p>Here we will use <em>tc</em> to drop packets. Because <em>tc</em> controls the transmit queues, we use it on a source computer (normally <em>tc</em> doesn&#8217;t impact on what is received by your computer, but there are exceptions).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>tc qdisc replace dev ens32 root netem loss 25%</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>netem</em> is a special type of queuing discipline used for emulating networks. The above command tells the Linux kernel to drop on average 25% of the packets in the transmit queue. You can use different values of loss (e.g. 10%).</p>
</div>
<div class="paragraph">
<p>When using <em>tc</em> you can show the current queue disciplines using:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>tc qdisc show dev ens32
<span class="go">qdisc netem 8001: root refcnt 2 limit 1000 loss 25%</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To show that it works, lets run an PING test. On computer <code>node-1</code> (the computer where <em>tc</em> is NOT used) run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-1:~$</span><span class="w"> </span>ping node-0 <span class="nt">-c</span> 4
<span class="go">PING node-0.localdomain (192.168.91.129) 56(84) bytes of data.
64 bytes from 192.168.91.129 (192.168.91.129): icmp_seq=1 ttl=64 time=0.424 ms
64 bytes from 192.168.91.129 (192.168.91.129): icmp_seq=3 ttl=64 time=3.14 ms
64 bytes from 192.168.91.129 (192.168.91.129): icmp_seq=4 ttl=64 time=0.643 ms

--- node-0.localdomain ping statistics ---
4 packets transmitted, 3 received, 25% packet loss, time 22ms
rtt min/avg/max/mdev = 0.424/1.400/3.135/1.230 ms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To delete the above queue discipline use the <em>delete</em> command instead of <em>replace</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>tc qdisc delete dev ens32 root netem loss 25%
<span class="gp">x@node-0:~$</span><span class="w"> </span><span class="nb">sudo </span>tc qdisc show dev ens32
<span class="go">qdisc pfifo_fast 0: root refcnt 2 bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1</span></code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When loss is used locally (not on a bridge or router), the loss is reported to the upper level protocols. This may cause TCP to resend and behave as if there was no loss. When testing protocol reponse to loss it is best to use a netem on a bridge or router. <a href="#netem">[netem]</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="dropping-packets-with-iptables">A.2. Dropping Packets with iptables</h3>
<div class="paragraph">
<p><code>iptables</code> allows you to create rules that specify how packets coming into your computer and going out of your computer are treated (and for routers, also forwarded by the router). The rules for packets coming in are in the INPUT chain, packets going out are OUTPUT, and packets forwarded are in the FORWARD chain. We will only use the INPUT chain.</p>
</div>
<div class="paragraph">
<p>The rules can filter packets based on common packet identifiers (IP addresses, ports, protocol numbers) as well as other matching criteria. We will use a special <em>statistic</em> matching module. For each packet that matches the filter, some action is applied (e.g. DROP the packet, ACCEPT the packet, or some more complex operation).</p>
</div>
<div class="paragraph">
<p>On computer <code>node-1</code> (the destination), to view the current set of rules:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-1:~$</span><span class="w"> </span><span class="nb">sudo </span>iptables <span class="nt">-L</span>
<span class="go">Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no rules in either of the three chains. Note that the default policy (if a packet does not match any rule) is to ACCEPT packets.</p>
</div>
<div class="paragraph">
<p>Now to add a rule to the INPUT chain to drop 25% of incoming packets on computer <code>node-1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-1:~$</span><span class="w"> </span><span class="nb">sudo </span>iptables <span class="nt">-A</span> INPUT <span class="nt">-m</span> statistic <span class="nt">--mode</span> random <span class="nt">--probability</span> 0.25 <span class="nt">-j</span> DROP
<span class="gp">x@node-1:~$</span><span class="w"> </span><span class="nb">sudo </span>iptables <span class="nt">-L</span> INPUT <span class="nt">--line-numbers</span>
<span class="go">Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination
1    DROP       all  --  anywhere             anywhere             statistic mode random probability 0.25000000000</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To demonstrate the packet dropping, run another PING test on the source <code>node-0</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-0:~$</span><span class="w"> </span>ping node-1.local <span class="nt">-c</span> 4
<span class="go">PING node-1.local (192.168.91.135) 56(84) bytes of data.
64 bytes from 192.168.91.135 (192.168.91.135): icmp_seq=1 ttl=64 time=0.547 ms
64 bytes from 192.168.91.135 (192.168.91.135): icmp_seq=2 ttl=64 time=1.91 ms
64 bytes from 192.168.91.135 (192.168.91.135): icmp_seq=3 ttl=64 time=0.513 ms

--- node-1.local ping statistics ---
4 packets transmitted, 3 received, 25% packet loss, time 3007ms
rtt min/avg/max/mdev = 0.513/0.988/1.905/0.648 ms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Returning to computer <code>node-1</code>, to delete a rule you can use the <code>-D</code> option:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-1:~$</span><span class="w"> </span><span class="nb">sudo </span>iptables <span class="nt">-D</span> INPUT <span class="nt">-m</span> statistic <span class="nt">--mode</span> random <span class="nt">--probability</span> 0.25 <span class="nt">-j</span> DROP
<span class="gp">x@node-1:~$</span><span class="w"> </span><span class="nb">sudo </span>iptables <span class="nt">-L</span> INPUT
<span class="go">Chain INPUT (policy ACCEPT)
target     prot opt source               destination</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(or you can refer to rules by number, e.g. <code>iptables -D INPUT 1</code> to delete rule 1 from the INPUT chain).</p>
</div>
<div class="paragraph">
<p>Alternatively we can specify to drop every <em>n</em> packets, starting from packet <em>p</em>. And we can combine with the standard filtering mechanisms of firewalls to only drop packets belong to a particular source/destination pair or application.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-1:~$</span><span class="w"> </span><span class="nb">sudo </span>iptables <span class="nt">-A</span> INPUT <span class="nt">-p</span> udp <span class="nt">--dport</span> 6666 <span class="nt">-m</span> statistic <span class="nt">--mode</span> nth <span class="nt">--every</span> 4 <span class="nt">--packet</span> 3 <span class="nt">-j</span> DROP</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule should drop packet 3, 7, 11, &#8230;&#8203; for only one of the connections (with destination port 6666).</p>
</div>
<div class="paragraph">
<p>Here is the output of an <code>iperf3</code> test at the source <code>node-0</code>. There are 25% packets dropped by the destination (receiver).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">x@node-0:~$</span><span class="w"> </span>iperf3 <span class="nt">-c</span> node-1 <span class="nt">-p</span> 6666 <span class="nt">-t</span> 10 <span class="nt">-u</span>
<span class="go">Connecting to host node-1, port 6666
[  5] local 192.168.91.128 port 52026 connected to 192.168.91.137 port 6666
</span><span class="c">....
</span><span class="go">- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams
[  5]   0.00-10.00  sec  1.25 MBytes  1.05 Mbits/sec  0.000 ms  0/906 (0%)  sender
[  5]   0.00-10.04  sec   962 KBytes   784 Kbits/sec  0.337 ms  226/906 (25%)  receiver</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="TCPIP1"></a>[TCPIP1] Kevin Fall, W. Stevens <em>TCP/IP Illustrated: The Protocols, Volume 1</em>. 2nd edition, Addison-Wesley Professional, 2011</p>
</li>
<li>
<p><a id="J88"></a>[J88] V. Jacobson, <em>Congestion Avoidance and Control</em>, See <a href="https://ee.lbl.gov/papers/congavoid.pdf" class="bare">https://ee.lbl.gov/papers/congavoid.pdf</a></p>
</li>
<li>
<p><a id="NETEM"></a>[NETEM] <a href="https://wiki.linuxfoundation.org/networking/netem" class="bare">https://wiki.linuxfoundation.org/networking/netem</a></p>
</li>
<li>
<p><a id="IPTABLES"></a>[IPTABLES] <em>Using iptables</em> [online]. <a href="https://www.netfilter.org/documentation/HOWTO/packet-filtering-HOWTO-7.html" class="bare">https://www.netfilter.org/documentation/HOWTO/packet-filtering-HOWTO-7.html</a></p>
</li>
<li>
<p><a id="EBADNET"></a>[EBADNET] <em>Emulating Bad Networks</em> [online]. <a href="https://samwho.dev/blog/emulating-bad-networks/" class="bare">https://samwho.dev/blog/emulating-bad-networks/</a></p>
</li>
<li>
<p><a id="DPLTC"></a>[DPLTC] <em>Dropping Packets in Ubuntu Linux using tc and iptables</em> [online]. <a href="https://sandilands.info/sgordon/dropping-packets-in-ubuntu-linux-using-tc-and-iptables" class="bare">https://sandilands.info/sgordon/dropping-packets-in-ubuntu-linux-using-tc-and-iptables</a></p>
</li>
<li>
<p><a id="RFC1122"></a>[RFC1122] R. Braden, ed., <em>Requirements for Internet Hosts—Communication Layers</em>, Internet RFC 1122/STD 0003, Oct. 1989, See <a href="https://www.rfc-editor.org/rfc/rfc1112" class="bare">https://www.rfc-editor.org/rfc/rfc1112</a></p>
</li>
<li>
<p><a id="RFC2018"></a>[RFC2018] M. Mathis, J. Mahdavi, S. Floyd, and A. Romanow, <em>TCP Selective Acknowledgment Options</em>, Internet RFC 2018, Oct. 1996, See <a href="https://www.rfc-editor.org/rfc/rfc2018" class="bare">https://www.rfc-editor.org/rfc/rfc2018</a></p>
</li>
<li>
<p><a id="RFC2883"></a>[RFC2883] S. Floyd, J. Mahdavi, M. Mathis, and M. Podolsky, <em>An Extension to the Selective Acknowledgement (SACK) Option for TCP</em>, Internet RFC 2883, July 2000, See <a href="https://www.rfc-editor.org/rfc/rfc2883" class="bare">https://www.rfc-editor.org/rfc/rfc2883</a></p>
</li>
<li>
<p><a id="RFC3517"></a>[RFC3517] E. Blanton, M. Allman, K. Fall, and L. Wang, <em>A Conservative Selective Acknowledgment (SACK)-Based Loss Recovery Algorithm for TCP</em>, Internet RFC 3517, Apr. 2003, See <a href="https://www.rfc-editor.org/rfc/rfc3517" class="bare">https://www.rfc-editor.org/rfc/rfc3517</a></p>
</li>
<li>
<p><a id="RFC3522"></a>[RFC3522] R. Ludwig and M. Meyer, <em>The Eifel Detection Algorithm for TCP</em>, Internet RFC 3522 (experimental), Apr. 2003.</p>
</li>
<li>
<p><a id="RFC5681"></a>[RFC5681] M. Allman, V. Paxson, E. Blanton, <em>TCP Congestion Control</em>, Internet RFC 5681, Sept. 2009, See <a href="https://www.rfc-editor.org/rfc/rfc5681" class="bare">https://www.rfc-editor.org/rfc/rfc5681</a></p>
</li>
<li>
<p><a id="RFC5682"></a>[RFC5682] P. Sarolahti, M. Kojo, K. Yamamoto, and M. Hata, <em>Forward RTORecovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP</em>, Internet RFC 5682, Sept. 2009.</p>
</li>
<li>
<p><a id="RFC6298"></a>[RFC6298] V. Paxson, M. Allman, and J. Chu, <em>Computing TCP’s Retransmission Timer</em>, Internet RFC 6298, June 2011, See <a href="https://www.rfc-editor.org/rfc/rfc6298" class="bare">https://www.rfc-editor.org/rfc/rfc6298</a></p>
</li>
<li>
<p><a id="J03"></a>[J03] S. Jaiswal et al. <em>Measurement and Classification of Out-of-Sequence Packets in a Tier-1 IP Backbone</em>, Proc. IEEE INFOCOM, Apr. 2003.</p>
</li>
<li>
<p><a id="LLY07"></a>[LLY07] K. Leung, V. Li, and D. Yang "An Overview of Packet Reordering in Transmission Control Protocol (TCP): Problems, Solutions and Challenges". <em>IEEE Trans. Parallel and Distributed Systems</em>, 18(4), Apr. 2007.</p>
</li>
<li>
<p><a id="TZZ05"></a>[TZZ05] K. Tan and Q. Zhang <em>STODER: A Robust and Efficient Algorithm for Handling Spurious Timeouts in TCP</em>. Proc. IEEE Globecomm, Dec. 2005.</p>
</li>
</ul>
</div>
</div>
</div>
  </div>

  <ul class="post-navigation">
    <li>
      
      <a href="/2023/01/10/tcp-ip-tcp-connection-management/">&laquo; TCP/IP: TCP Connection Management</a>
      
    </li>
    <li>
      
      <a href="/2023/01/31/tcp-ip-tcp-data-flow-and-window-management/">TCP/IP: TCP Data Flow and Window Management &raquo;</a>
      
    </li>
  </ul>
</article>

      </div>
    </div>

    <footer class="site-footer">
  <div class="license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details open>
    <summary>Extral Links</summary>
    <div>
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>


<!-- https://github.com/bryanbraun/anchorjs -->
<script src="/js/anchor.min.js"></script>
<script>
  anchors.add();
  anchors.remove(".site-title");
</script>




  </body>

</html>
