<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bing WebMaster -->
  <meta name="msvalidate.01" content="AB2FFF876C37F59D9121882CC8395DE5" />

  <title>Effective Go</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://blog.codefarm.me/2016/03/25/effective-go/">
  <link rel="alternate" type="application/rss+xml" title="CODE FARM" href="https://blog.codefarm.me/feed.xml">

  <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->
<script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>

  
<!-- Google Analytics Website tracking -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-83971182-1', 'auto');
  ga('send', 'pageview');

</script>


  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SN88FJ18E5');
</script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">
    <h2 class="site-title">
      <a class="site-title" href="/">CODE FARM</a>
    </h2>

     <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
        <div class="trigger">
            <ul>
                <li><a href="/">home</a>
                <li><a href="/category">category</a>
                <li><a href="/tag">tag</a>
                <li><a href="/archive">archive</a>
                <li><a href="/about">about</a>
                <li><a href="https://resume.github.io/?qqbuby" target="_blank">R&eacute;sum&eacute;</a>
            </ul>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Effective Go</h1>
    
    
    <p class="post-meta"><time datetime="2016-03-25T23:55:56+08:00" itemprop="datePublished">Mar 25, 2016</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>Reference from <a href="https://golang.org/doc/effective_go.html">Effective Go (golang.org/doc)</a></em></p>

<h2 id="overview">Overview</h2>
<p>Go is a new language. Although it borrows ideas from existing languages, it has unusual properties that make effetive Go program different in character from programs written in its relatives. A straightforword tranlation of a C++ or Java program into Go is unlikely to produce a satisfactory result-Java programs are written in Java, not Go. In other words, to write Go well, it’s important to understand its properties and idioms. It’s also important to know the established conventions for programming in Go, such as naming, formatting, program construction, and so on, so that programs you write will be easy for other Go programmers to understand.</p>

<p>This document gives tips for writing clear, idiomatic Go code.</p>

<h2 id="formatting">Formatting</h2>
<p>Formatting issues are the most contentious but the leat consequential. People can adapt to different formatting styles but it’s better if they don’t have to, and less time is devoted to the topic if every one adheres to the same style.
With Go we take an unusual approach and let the machine take care of most formatting issues. The <strong>gofmt</strong> program (also avaiable as <strong>go fmt</strong>, which operates at the package level rather than source file level) reads a Go program and emits the source in a standard style of indentation and vertical alignment, retaining and if necessary reformatting comments.</p>

<p>All Go code in the standard packages has been formatted with <em>gofmt</em>.</p>

<p>Some formatting details remain. Very briefly:</p>

<ul>
  <li>
    <p>Indentation</p>

    <p>We use tabs for indentation and <em>gofmt</em> emits them by default. Use spaces only if you must.</p>
  </li>
  <li>
    <p>Line lenght</p>

    <p>Go has no line limit. If a line feels two long, wrap it and indent with and extra tab.</p>
  </li>
  <li>
    <p>Parentheses</p>

    <p>Go needs fewer parentheses than C and Java: control structures (<strong>if</strong>, <strong>for</strong>, <strong>switch</strong>) do not have parentheses in their syntax.</p>
  </li>
</ul>

<h2 id="commentary">Commentary</h2>
<p>Go provides C-style /* */ block comments and C++-style // line comments. Line comments are the norm; block comments appear mostly as package comments, but are useful within an expression or to disable large swaths of code.</p>

<p>The program—and web server—<strong>godoc</strong> processes Go source files to extract documentation about the contents of the package. Comments that appear before top-level declarations, with no intervening newlines, are extracted along with the declaration to serve as explanatory text for the item. The nature and style of these comments determines the quality of the documentation <strong>godoc</strong> produces.</p>

<p>Every package should have a <em>package comment</em>, a block comment preceding the package clause. For multi-file packages, the package comment only needs to be present in one file, and any one will do.</p>

<p>Comments do not need extra formatting such as banners of stars. The generated output may not even be presented in a fixed-width font, so don’t depend on spacing for alignment—<strong>godoc</strong>, like <strong>gofmt</strong>, takes care of that. The comments are uninterpreted plain text, so HTML and ohter annotations such <strong>_this_</strong> will reproduce <em>verbatim</em> and should not be used.</p>

<p>Every exported (capitalized) name in a program should have a doc comment.</p>

<p>Go’s declaration syntax allows grouping of declarations. A single doc comment can introduce a group of related constants or variables.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Error codes returned by failures to parse an expression.
var (
	ErrInternal      = errors.New("regexp: internal error")
	ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
	ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
	...
)
</code></pre></div></div>

<h2 id="names">Names</h2>
<p>Names are as important in Go as in any other language. They even have semantic effect: <em>the visibility of a name outside a package is determined by whether its first character is upper case</em>.</p>

<h3 id="package-names">Package names</h3>

<p>When a package is imported, the package name becomes an accessor for the contents. After</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import "bytes"
</code></pre></div></div>

<p>the import package can talk about <code class="language-plaintext highlighter-rouge">bytes.Buffer</code>.</p>

<p>Packages name should be good: short, concise, evocative. By convention, packages are given lower case, single-word name; there should be no need for underscores or mixedCaps.</p>

<p>Another convention is that the package name is the base name of its source direcotry; the package in <em>src/encoding/base64</em> is imported as “encoding/base64” but has name base64, not encoding_base64 and not encodingBase64.</p>

<p>The importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid stutter.</p>

<h3 id="getters">Getters</h3>

<p>Go doesn’t provide automatic support for getters and setters. There’s nothing wrong with providing getters and setters yourself, and it’s often appropriate to do so, but it’s neither idomatic nor necessary to put <em>Get</em> into the getter’s name. If you have a filed called <em>owner</em> (lover case, unexported), the getter method should be called <em>Owner</em> (upper case, exported), not <em>GetOwner</em>. The use of upper-case names for export provides the hook to discriminate the field from the method. A setter function, if needed, will likely be called <em>SetOwner</em>. Both names read well in pratice:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
</code></pre></div></div>

<h3 id="interface-names">Interface names</h3>

<p>By convention, one-method interfaces are named by the method name plus an <em>-er</em> suffix or similar modification to construct an agent noun: Reader, Writer, Formatter, CloseNotifier etc.</p>

<p>To avoid confusion, don’t give your method one of those names unless it has the same signature and meaning. Conversely, if your type implements a method with the same meaning as a method on a well-known type, give it the same name and signature; call your string-converter method <em>String</em> not <em>ToString</em>.</p>

<h3 id="mixedcaps">MixedCaps</h3>

<p>Finally, the convention in Go is to use MixedCaps or mixedCaps rather than underscores to write multiword names.</p>

<h2 id="semicolons">Semicolons</h2>
<p>Like C, Go’s formal grammar uses semicolons to terminate statements, but unkie in C, those semicolons do not appear in the source. Instead the lexer uses a simple rule to insert semicolons automatically as it scans, so the input text is mostly free of them.
The rule is this. If the last token before a newline is an identifier (which includes words like <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">float63</code>), a basic literal such as a number or string constant, or one of the tokens</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>break continue fallthrough return ++ -- ) }
</code></pre></div></div>

<p>the lexer always inserts a semicolon after the token. This could be summarized as, “if the newline comes after a token that could end a statement, instert a semicolon”.</p>

<p>A semicolon can also be ommited immediately before a closing brace, so a statement such as</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go func() { for { dst &lt;- &lt;-src }}()
</code></pre></div></div>

<p>needs no semicolons. Idiomatic Go programs have semicolons only in places such as for loop clauses, to separate the intializer, condition, and continuation elements. They are also necessary to separate mulitple statements on a line, should you write code that way.</p>

<p>One consequence of the smicolon insertion rules is that you cannot put the opening brace of a control structure (if, for, switch, or select) on the next line. If you do, a semicolon will be inserted before the brace, which could cause unwanted effects. Write them like this</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if i &lt; f() {
    g()
}
</code></pre></div></div>

<p>not like</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if i &lt; f()  // wrong!
{           // wrong!
    g()
}
</code></pre></div></div>

<h2 id="control-structures">Control structures</h2>
<p>The control structures of Go are related to those of C but differ in important ways. There is no <em>do</em> or <em>while</em> loop, only a slightly generalized <em>for</em>; <em>switch</em> is more flexible; <em>if</em> and <em>switch</em> accept an optional initialization statement like that of <em>for</em>; <em>break</em> and <em>continue</em> statements take an optional label to identify what to break or continue; and there are new control structures including a type switch and a multiway communications multiplexer, <em>select</em>. The syntax is also slightly different: <em>there are no parentheses and the bodies must always be brace-delimited</em>.</p>

<h3 id="if">If</h3>
<p>In Go a simple if looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x &gt; 0 {
    return y
}
</code></pre></div></div>

<p>Mandatory braces encourage writing simple <em>if</em> statements on multiple lines. It’s good style to do so anyway, especially when the body contains a control statement such as a <em>return</em> or <em>break</em>.</p>

<p>Since <em>if</em> and <em>switch</em> accept an intialization statement, it’s common to see one used to set up a local variable.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
</code></pre></div></div>

<p>In the Go libraries, when an <em>if</em> statement doesn’t flow into the next statement—that is, the body ends in <em>break</em>, <em>continue</em>, <em>goto</em>, or <em>return</em>—the unnecessary <em>else</em> is omitted.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
</code></pre></div></div>

<h3 id="redeclaration-and-reassignment">Redeclaration and reassignment</h3>

<p>In a <strong>:=</strong> declaration a variable <em>v</em> may appear even if it has already been declared, provided:</p>

<ul>
  <li>this delcaration is in the same scope as the existing declaration of <em>v</em> (if <em>v</em> is already declared in an outer scope, the declaration will create a new variable <em>§</em>),</li>
  <li>the corresponding value in the intialization is assignable to <em>v</em>, and</li>
  <li>there is at least one other variable in the declaration that is being declared anew.</li>
</ul>

<p>§ It’s worth noting here that in Go the scope of function parameters and return values is the same as the function body, even though they appear lexically outside the braces that enclose the body.</p>

<h3 id="for">For</h3>

<p>The Go <em>for</em> loop is similar to—but not the same as—C’s. It unifies <em>for</em> and <em>while</em> and there is no <em>do-while</em>.</p>

<p>There are three forms, only one of which has semicolons.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
</code></pre></div></div>

<p>Short declarations make it easy to declare the index variable right in the loop.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sum := 0
for i := 0; i &lt; 10; i++ {
    sum += i
}
</code></pre></div></div>

<p>If you’re looping over an <em>array</em>, <em>slice</em>, <em>string</em>, or <em>map</em>, or reading from a <em>channel</em>, a <strong>range</strong> clause can manage the loop.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for key, value := range oldMap {
    newMap[key] value
}
</code></pre></div></div>

<p>If you only need the first item in the range (the key or index), drop the second:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
</code></pre></div></div>

<p>If you only need the second item in the range (the value), use the <em>blank indeifier</em>, an underscore, to discard the first:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sum := 0
for _, value := range array {
    sum += value
}
</code></pre></div></div>

<p>Finally, Go has no comma operator and ++ and – are statements not expressions. Thus if you want to run multiple variables in a <em>for</em> you should use parallel assignment (although that precludes ++ and –).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Reverse a
for i, j  := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
</code></pre></div></div>

<h3 id="switch">Switch</h3>

<p>Go’s <em>switch</em> is more general than C’s. The expressoins need not be constants or even integers, the cases are evaluated top to bottom until a match is found, and if the <em>switch</em> has no expression it switchs on <em>true</em>. It’s therefore possiable—and idomatic—to write and <em>if-else-if-else</em> chain as a <em>switch</em>.</p>

<p>There is no automatic fall through, but cases can be presented in comma-separated lists.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func shouldEscape(c byte) bool {
    switch c {
        case ' ', '?', '&amp;', '=', '#', '+', '%':
            return true
    }
    return false
}
</code></pre></div></div>

<p>Although they are not nearly as common in Go as some other C-like languages, <em>break</em> statements can be used to terminate a <em>switch</em> early.</p>

<p>Of course, the <em>continue</em> statement also accepts an optional label but it applies only to loops.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Compare returns an integer comparing the two byte slices,
// lexicographically.
// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b
func Compare(a, b []byte) int {
    for i := 0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ {
        switch {
        case a[i] &gt; b[i]:
            return 1
        case a[i] &lt; b[i]:
            return -1
        }
    }
    switch {
    case len(a) &gt; len(b):
        return 1
    case len(a) &lt; len(b):
        return -1
    }
    return 0
}
</code></pre></div></div>

<h3 id="type-switch">Type switch</h3>

<p>A <em>switch</em> can also be used to discover the dynamic type of and interface variable.
Such a <em>type switch</em> uses the syntax of a <em>type assertion</em> with the keyworkd <code class="language-plaintext highlighter-rouge">type</code> inside the parenthese. If the switch declares a variable in the expressoin, the variable will have the corresponding type in each caluse. It’s also idiomatic to reuse the name in such case, in effect declaring a new variable with the same name but a different type in each case.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf("unexpected type %T\n", t)     // %T prints  whatever type t has
case bool:
    fmt.Printf("boolean %t\n", t)             // t has type     bool
case int:
    fmt.Printf("integer %d\n", t)             // t has type     int
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t) // t has type     *bool
case *int:
    fmt.Printf("pointer to integer %d\n", *t) // t has type     *int
}
</code></pre></div></div>

<h2 id="functions">Functions</h2>
<h3 id="multiple-return-values">Multiple return values</h3>

<p>One of Go’s unusual features is that functions and methods can return multiple values. This form can be used to improve on a couple of clumsy idioms in C programs: in-band error returns such as -1 for EOF and modifying an argument passed by address.</p>

<p>In C, a write error is signaled by a negative count with the error code secreted away in a volatile location. In Go, <code class="language-plaintext highlighter-rouge">Write</code> can return a count <em>and</em> an error: “Yes, you wrote some bytes but not all of them because you filled the device”. The signature of the <code class="language-plaintext highlighter-rouge">Write</code> method on files form package <code class="language-plaintext highlighter-rouge">os</code> is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (file *File) Write(b []byte) (n int, err error)
</code></pre></div></div>

<p>and as the documentation says, it returns the number of bytes written and a non-nil <code class="language-plaintext highlighter-rouge">error</code> when <code class="language-plaintext highlighter-rouge">n != len(b)</code>.</p>

<h3 id="named-result-parameters">Named result parameters</h3>

<p>The return or result “parameters” of a Go function can be given names and used as regular variables, just like the incoming parameters. When named, they are initialized to the zero values of their types when the funciton begins; if the function executes a <em>return</em> statement with no arguments, the current values of the result parameters are used as the returned values.</p>

<p>Because named results are initialized and tied to an unadorned return, they can simplify as well as clarify.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) &gt; 0 &amp;&amp; err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
</code></pre></div></div>

<h3 id="defer">Defer</h3>

<p>Go’s <em>defer</em> statement schedules a function call (the <em>deferred</em> function) to be run immediately before the function executing the <em>defer</em> returns. It’s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Contents returns the file's contents as a string
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err := nil {
        return "", err
    }
    defer f.Close()     // f.Close will run when we're finished.
    //to do sth...
    return "content", nil
}
</code></pre></div></div>

<p>The arguments to the deferred function (which include the receiver if the function is a method) are evaluated when the <em>defer</em> executes, not the the <em>call</em> executes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i := 0; i &lt; 5; i++ {
    defer fmt.Printf("%d ", i)
}
</code></pre></div></div>

<p>Deferred functions are executed in LIFO order, so this code cause 4 3 2 1 0 to be printed when function returns. A more plausible example is a simple way to trace function execution through the program. We could write a couple of simple tracing routines like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func trace(s string)    { fmt.Println("entering:", s) }
func untrace(s string)  { fmt.Println("leaving:", s) }

// Use them like this:
func a() {
    trace("a")
    defer untrace("a")
    // do something....
}
</code></pre></div></div>

<h2 id="data">Data</h2>
<h3 id="allocation">Allocation</h3>
<p>Go has two allocation primitives, the built-in functions <code class="language-plaintext highlighter-rouge">new</code> and <code class="language-plaintext highlighter-rouge">make</code>. They do different things and apply to different types.</p>

<p><strong>Allocation with new</strong></p>

<p><strong>new</strong>, a built-in function that allocates memory, but unlike its namesakes in some other languages it does not <em>intialize</em> the memory, it only <em>zeros</em> it. That is, <code class="language-plaintext highlighter-rouge">new(T)</code> allocates zeroed storage for a new item of type <code class="language-plaintext highlighter-rouge">T</code> and return its address, a value of type <code class="language-plaintext highlighter-rouge">*T</code>. In Go terminology, it returns a pointer to a newly allocated zero value of type <code class="language-plaintext highlighter-rouge">T</code>.</p>

<p>Since the memory returned by <code class="language-plaintext highlighter-rouge">new</code> is zeroed, it’s helpful to arrange when designing your data structures that the zero of each type can be used without further initialization. This means a user of the data structure can create one with <code class="language-plaintext highlighter-rouge">new</code> and get right to work.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type SyncedBuffer struct {
    lock    sync.Mutex      // the zero value for a sync.Mutex is defined to be an unlocked mutex.
    buffer  sync.Buffer     // the zero value for Buffer is an empty buffer ready to use.
}
</code></pre></div></div>

<p>Values of type <code class="language-plaintext highlighter-rouge">SyncedBuffer</code> are also ready to use immediately upon allocation or just declaration. In the next snippet, both <code class="language-plaintext highlighter-rouge">p</code> and <code class="language-plaintext highlighter-rouge">v</code> will work correctly without further arrangement.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p := new(SyncedBuffer)      // type *SyncedBuffer
var v SyncedBuffer          // type  SyncedBuffer
</code></pre></div></div>

<p><strong>Constructors and compsite literals</strong></p>

<p>Sometimes the zero value isn’t good enough and an initializing constructor is necessary, as in this example derived form package <code class="language-plaintext highlighter-rouge">os</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
</code></pre></div></div>

<p>There’s a lot of boiler plate in there. We can simplify it using a <em>composite literal</em>, which is an expression that creates a new instance each time it is evaluated.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &amp;f
}
</code></pre></div></div>

<p>In fact, taking the address of a composite literal allocates a fresh instance each time it is evaluated, so we can combine these last two lines.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return &amp;File{fd, name, nil, 0}
</code></pre></div></div>

<p>The fields of a composite literal are laid out in order and must all be present. However, by labeling the elements explicitly as <em>field:value</em> pairs, the intializers can appear in any order, with the missing ones left as their respective zero values. Thus we could say</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return &amp;File{fd: fd, name: name}
</code></pre></div></div>

<p>As a limiting case, if a composite literal contains no fields at all, it create a zero value for the type. The expression <code class="language-plaintext highlighter-rouge">new(File)</code> and <code class="language-plaintext highlighter-rouge">&amp;File{}</code> are equivalent.</p>

<p>Composite literals can also be created for <em>arrays</em>, <em>slices</em>, and <em>maps</em>, with the field labels being indices or map keys as appropriate.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
</code></pre></div></div>

<p><strong>Allocation with make</strong></p>

<p>The built-in function <code class="language-plaintext highlighter-rouge">make(T, args)</code> serves a purpos different from <code class="language-plaintext highlighter-rouge">new(T)</code>. It creates <em>slices</em>, <em>maps</em>, and <em>channels</em> only, and it returns an <em>intialized</em> (not <em>zeroed</em>) value of type <code class="language-plaintext highlighter-rouge">T</code> (not <code class="language-plaintext highlighter-rouge">*T</code>). The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. A slice, for example, is a three-item descriptor containing a pointer to the data (inside an array), the lenght, and the capacity, and until those items are intialized, the slice is <code class="language-plaintext highlighter-rouge">nil</code>. For slices, maps, and channels, <code class="language-plaintext highlighter-rouge">make</code> intializes the internal data structure and prepares the value to use.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
</code></pre></div></div>

<p>Remember that <code class="language-plaintext highlighter-rouge">make</code> applies only to maps, slices and channels and does not return a pointer. To obtain an explicit pointer allocate with <code class="language-plaintext highlighter-rouge">new</code> or take the address of a variable explicitly.</p>

<h3 id="arrays">Arrays</h3>
<p>Arrays are useful when planning the detailed layout of memory and sometimes can help avoid allocation, but primarily they are a building block for slices.</p>

<p>There are major differences between the ways arrays work in Go and C. In Go,</p>

<ul>
  <li>Arrays are values. Assigning one array to another copies all the elements.</li>
  <li>In particluar, if you pass an array to a function, it will receive a <em>copy</em> of the array, not a pointer to it.</li>
  <li>The size of an array is part of its type. The type <code class="language-plaintext highlighter-rouge">[10]int</code> and <code class="language-plaintext highlighter-rouge">[20]int</code> are distinct.</li>
</ul>

<p>If you want C-like behavior and efficiency, you can pass a pointer to the array, but even this style isn’t idomatic Go. Use slcies instead.</p>

<h3 id="slices">Slices</h3>
<p>Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays.</p>

<p>Slices hold references to an underlying array, and if you assign one slice to another, both refer to the same array. If a function takes a slice argument, changes it makes to the elements of the slice will be visible to the caller, analogous to passing a pointer to the underlying array. A <code class="language-plaintext highlighter-rouge">Read</code> function can therefore accept a slice argument rather than a pointer and a count; the length within the slice sets an upper limit of how much data to read.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (f *File) Read(buf []byte) (n int, err error)
</code></pre></div></div>

<p>The method returns the number of bytes read and an error value, if any. To read into the first 32 bytes of a larger buffer <code class="language-plaintext highlighter-rouge">buf</code>, <em>slice</em> (here used as a verb) the buffer.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n, err := f.Read(buf[0:32])
</code></pre></div></div>

<p>The length of a slice may be changed as long as it still fits within the limits of the underlying array; just assign it to a slice of itself. The <em>capacity</em> of a slice, accessible by the built-in function <code class="language-plaintext highlighter-rouge">cap</code>, reports the maximum length the slice may assume.</p>

<h3 id="two-dimensional-slices">Two-dimensional slices</h3>
<p>Go’s arrays and slices are one-dimensinal. To create the equivalent of a 2D array or slice, it is necessary to define an array-of-arrays or slice-of-slices, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Transform [3][3]float64  // A 3x3 array, really an array of arrays.
type LinesOfText [][]byte     // A slice of byte slices.
</code></pre></div></div>

<p>Because slices are variable-length, it is possible to have each inner slice be a different length.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>text := LinesOfText{
    []byte("Now is the time"),
    []byte("for all good gophers"),
    []byte("to bring some fun to the party."),
}
</code></pre></div></div>

<p>Sometimes it’s necessary to allocate a 2D slice, a situation that can arise when processing scan lines of pixels, for instance. There are two ways to achieve this. One is to allocate each slice independently; the other is to allocate a single array and point the individual slices into it.</p>

<h3 id="maps">Maps</h3>
<p>Maps are a convenient and powerful built-in data structure that associate values of one type (the <em>key</em>) with values of another type (the <em>element</em> or <em>value</em>). The key can be of any type for which the equality operator is defined, such as integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays. Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references to an underlying data structure.</p>

<p>Maps can be constructed using the usual composite literal syntax with colon-separated key-value pairs.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var timeZone = map[string]int{
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
</code></pre></div></div>

<p>Assigining and fetching map values looks syntactically just like doing the same for arrays and slices except that the index doesn’t need to be an integer.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>offset := timeZone["EST"]
</code></pre></div></div>

<p>An attempt to fetch a map value with a key that is not present in the map will return zero value for the type of the entries in the map.</p>

<p>Sometimes you need to distinguish a missing entry from a zero value with a form of multiple assignment.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var seconds int
var ok bool
seconds, ok = timeZone[tz]
</code></pre></div></div>

<p>For obvious reasons this is called the “comma ok” idiom. In this example, if <code class="language-plaintext highlighter-rouge">tz</code> is present, <code class="language-plaintext highlighter-rouge">seconds</code> will be set appropriately and <code class="language-plaintext highlighter-rouge">ok</code> will be true; if not, <code class="language-plaintext highlighter-rouge">seconds</code> will be set to zero and <code class="language-plaintext highlighter-rouge">ok</code> will be false.</p>

<p>To test for presence in the map without worrying about the actual value, you can use the <em>blank identifier (_)</em> in place of the usual variable for the value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_, present := timeZone[tz]
</code></pre></div></div>

<p>To delete a map entry, use the <code class="language-plaintext highlighter-rouge">delete</code> built-in function, whose arguments are the map and the key to be deleted. If’s safe to do this even if the key is already absent from the map.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>delete(timeZone, "PDT")     // Now on Standard Time
</code></pre></div></div>

<h3 id="printing">Printing</h3>
<p>Formatted printing in Go uses a style similar to C’s <code class="language-plaintext highlighter-rouge">printf</code> family but is richer and more general. The functions live in the <code class="language-plaintext highlighter-rouge">fmt</code> package and have capitalized names: <code class="language-plaintext highlighter-rouge">fmt.Printf</code>, <code class="language-plaintext highlighter-rouge">fmt.Fprintf</code>, <code class="language-plaintext highlighter-rouge">fmt.Sprintf</code> and so on. The string functions (Sprintf etc.) return a string rather than filling in a provided buffer.</p>

<p>You don’t need to provide a format string. For each of <code class="language-plaintext highlighter-rouge">Printf</code>, <code class="language-plaintext highlighter-rouge">Fprintf</code>, and <code class="language-plaintext highlighter-rouge">Sprintf</code> there is another pair of functions, for instance <code class="language-plaintext highlighter-rouge">Print</code> and <code class="language-plaintext highlighter-rouge">Println</code>. These functions do not take a format string but instead generate a default format for each argument. The <code class="language-plaintext highlighter-rouge">Println</code> versions also insert a blank between arguments and append a newline to the output while the <code class="language-plaintext highlighter-rouge">Print</code> versions add blanks only if the operand on neither side is a string.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("Hello %d\n", 23)
fmt.Fprintf(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
</code></pre></div></div>

<p>The formatted print function <code class="language-plaintext highlighter-rouge">fmt.Fprint</code> and friends take as a first argument any object that implements the <code class="language-plaintext highlighter-rouge">io.Writer</code> interface; the variables <code class="language-plaintext highlighter-rouge">os.Stdout</code> and <code class="language-plaintext highlighter-rouge">os.Stderr</code> are familiar instances.</p>

<p>Here things start to diverge from C. First, the numeric formats such as <code class="language-plaintext highlighter-rouge">%d</code> do not take flags for signedness or size; instead, the printing routines use the type of the arguement to decide these properties.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var x uint64 = 1&lt;&lt;64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
</code></pre></div></div>

<p>prints</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>18446744073709551615 ffffffffffffffff; -1 -1
</code></pre></div></div>

<p>If you just want the default conversion, such as decimal for integers, you can use the catchall format <code class="language-plaintext highlighter-rouge">%v</code> (for “value”); the result is exactly what <code class="language-plaintext highlighter-rouge">Print</code> and <code class="language-plaintext highlighter-rouge">Println</code> would produce. Moreover, that format can print <em>any</em> value, even arrays, slices, structs, and maps.</p>

<p>When printing a struct, the modified format <code class="language-plaintext highlighter-rouge">%+v</code> annotates the fields of the structure with their names, and for any value the alternate format <code class="language-plaintext highlighter-rouge">%#v</code> prints the value in full Go syntax.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type T struct {
    a int
    b float64
    c string
}
t := &amp;T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
</code></pre></div></div>

<p>prints</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&amp;{7 -2.35 abc   def}
&amp;{a:7 b:-2.35 c:abc     def}
&amp;main.T{a:7, b:-2.35, c:"abc\tdef"}
</code></pre></div></div>

<p>(Note the ampersands.) That quoted string format is also available through <code class="language-plaintext highlighter-rouge">%q</code> when applied to a value of type <code class="language-plaintext highlighter-rouge">string</code> or <code class="language-plaintext highlighter-rouge">[]byte</code>. Also, <code class="language-plaintext highlighter-rouge">%x</code> works on strings, byte arrays and byte slices as well as on integers, generating a long hexadecimal string, and with a space in the format (% x) it puts space between the bytes.</p>

<p>Another handy format is <code class="language-plaintext highlighter-rouge">%T</code>, which prints the <em>type</em> of a value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("%T\n", timeZone)
</code></pre></div></div>

<p>prints</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>map[string] int
</code></pre></div></div>

<p>If you want to control the default format for a custom type, all that’s required is to define a method with the signature <code class="language-plaintext highlighter-rouge">String() string</code> on the type.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (t *T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
</code></pre></div></div>

<p>to print in the format</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7/-2.35/"abc\tdef"
</code></pre></div></div>

<p>(If you need to print <em>values</em> of type <code class="language-plaintext highlighter-rouge">T</code> as well as pointers to <code class="language-plaintext highlighter-rouge">T</code>, the receiver for <code class="language-plaintext highlighter-rouge">String</code> must be of value type; used a pointer because that’s more efficient and idiomatic for struct types.)</p>

<p>Our <code class="language-plaintext highlighter-rouge">String</code> method is able to call <code class="language-plaintext highlighter-rouge">Sprintf</code> because the print routines are fully reentrant and can be wrapped this way. There is one important detail to understand about this approach, however: don’t construct a <code class="language-plaintext highlighter-rouge">String</code> method by calling <code class="language-plaintext highlighter-rouge">Sprintf</code> in a way that will recur into your <code class="language-plaintext highlighter-rouge">String</code> method indefinitely. This can happen if the <code class="language-plaintext highlighter-rouge">Sprintf</code> call attempts to print the receiver directly as a string, which in turn will invoke the method again. It’s a common and easy mistake to make, as this example shows.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type MyString string

func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", m)    // Error: will recur forever.
}
</code></pre></div></div>

<p>It’s also easy to fix: convert the argument to the basic string type, which does not have the method.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type MyString string
func (m MyString) String() string {
    fmt.Sprintf("MyString=%s", string(m))   // OK: note conversion.
}
</code></pre></div></div>

<p>Another printing technique is to pass a print routine’s arguments directly to another such routine. The signature of <code class="language-plaintext highlighter-rouge">Printf</code> uses the  type <code class="language-plaintext highlighter-rouge">...interface{}</code> for its final argument to specify that an arbitrary number of parameters (of arbitrary type) can appear after the format.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func Printf(format string, v ...interface{}) (n int, err error) {
</code></pre></div></div>

<p>Within the function <code class="language-plaintext highlighter-rouge">Printf</code>, <code class="language-plaintext highlighter-rouge">v</code> acts like a variable of type <code class="language-plaintext highlighter-rouge">[]interface{}</code> but if it is passed to another variadic function, it acts like a regular list of arguments. Here is the implementation of the function <code class="language-plaintext highlighter-rouge">log.Println</code> we used above. It passes its arguments directly to <code class="language-plaintext highlighter-rouge">fmt.Sprintln</code> for the actual formatting.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Println prints to the standard logger in the manner of fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))   // Output takes parameters (int, string)
}
</code></pre></div></div>

<p>We write <strong>…</strong> after <code class="language-plaintext highlighter-rouge">v</code> in the nested call to <code class="language-plaintext highlighter-rouge">Sprintln</code> to tell the compiler to treat <code class="language-plaintext highlighter-rouge">v</code> as a list of arguments; otherwise it would just past <code class="language-plaintext highlighter-rouge">v</code> as a single slice argument.</p>

<p>By the way, a <strong>…</strong> parameter can be of a specific type, for instance <code class="language-plaintext highlighter-rouge">...int</code> for a min function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Min function that chooses the least of a list of integers
func Min(a ...int) int {
    min := int(^uint(0) &gt;&gt; 1)   // largest int
    for _, i : range a {
        if i &lt; min {
            min = i
        }
    }
    return min
}
</code></pre></div></div>

<h3 id="append">Append</h3>
<p>The signature of bulti-in funciton <code class="language-plaintext highlighter-rouge">append</code> as blows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func append(slice []T, elements ...T) []T
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">T</code> is a placeholder for any give type. You cann’t actually write a funciton in Go where the type <code class="language-plaintext highlighter-rouge">T</code> is determined by the caller. That’s why <code class="language-plaintext highlighter-rouge">append</code> is built in: it needs support from the compiler.</p>

<p>What <code class="language-plaintext highlighter-rouge">append</code> does is append the elements to the end of the slice and return the result. The result needs to be returned because the underlying array may change.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x := []int{1, 2, 3}
x = append(x, 4, 5, 6)
</code></pre></div></div>

<p>So <code class="language-plaintext highlighter-rouge">append</code> works a little like <code class="language-plaintext highlighter-rouge">Printf</code>, collecting an arbitrary number of arguments.</p>

<h2 id="intialization">Intialization</h2>
<p>Although it doesn’t llok superficially very different from initialization in C or C++, intialization in Go is more powerful. Complex structures can be built during intialziation and the ordering issues among initialized objects, even among different packages, are handled correctly.</p>

<h3 id="constants">Constants</h3>
<p>Constants in Go are just that-constant. They are created at compile time, even when defined as locals in fucntions, and can only be numbers, characters (runes), strings or booleans. Because of the compile-time restriction, the expressions that define them must be constant expressions, evalutable by the compiler. For instance, <code class="language-plaintext highlighter-rouge">1&lt;&lt;3</code> is a constant expression, while <code class="language-plaintext highlighter-rouge">math.Sin(math.Pi/4)</code> is not because the function call to <code class="language-plaintext highlighter-rouge">math.Sin</code> needs to happen at run time.</p>

<p>In Go, enumerated constants are created using the <strong>iota</strong> enumerator. Since <strong>iota</strong> can be part of an expression and expressions can be implicitly repeated, it is easy to build intricate sets of values.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type ByteSize float64

const (
    _           = iota // ignore first value by assigning to blank identifier
    KB ByteSize = 1 &lt;&lt; (10 * iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)
</code></pre></div></div>

<p>The ability to attach a method such <code class="language-plaintext highlighter-rouge">String</code> to any user-defined type makes it possible for arbitrary values to format themselves automatically for printing.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (b ByteSize) String() string {
    switch {
    case b &gt;= YB:
    return fmt.Sprintf("%.2fYB", b/YB)
    case b &gt;= ZB:
        return fmt.Sprintf("%.2fZB", b/ZB)
    case b &gt;= EB:
        return fmt.Sprintf("%.2fEB", b/EB)
    case b &gt;= PB:
        return fmt.Sprintf("%.2fPB", b/PB)
    case b &gt;= TB:
        return fmt.Sprintf("%.2fTB", b/TB)
    case b &gt;= GB:
        return fmt.Sprintf("%.2fGB", b/GB)
    case b &gt;= MB:
        return fmt.Sprintf("%.2fMB", b/MB)
    case b &gt;= KB:
        return fmt.Sprintf("%.2fKB", b/KB)
    }
    return fmt.Sprintf("%.2fB", b)
}
</code></pre></div></div>

<h3 id="variables">Variables</h3>
<p>Variables can be intialized just like constants but the initializer can be a general expression computed at run time.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var (
    home   = os.Getenv("HOME")
    user   = os.Getenv("USER")
    gopath = os.Getenv("GOPATH")
)
</code></pre></div></div>

<h3 id="the-init-function">The init function</h3>
<p>Finally, each source file can define its own niladic <code class="language-plaintext highlighter-rouge">init</code> function to set up whatever state is required. (Actually each file can have multiple <code class="language-plaintext highlighter-rouge">init</code> function.) And finally means finally: <code class="language-plaintext highlighter-rouge">init</code> is called after all the variable declarations in the package have evaluated their initializers, and those are evaluated only after all the imported packages have been intialized.</p>

<p>Besides initializations that cannot be expressed as declarations, a common use of `init’ functions is to verify or repair correctness of the program state before real execution begins.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func init() {
    if user == "" {
        log.Fatal("$USER not set")
    }
    if home == "" {
        home = "/home/" + user
    }
    if gopath == "" {
        gopath = home + "/go"
    }
    // gopath may be overridden by --gopath flag on command line.
    flag.StringVar(&amp;gopath, "gopath", gopath, "override     default GOPATH")
}
</code></pre></div></div>

<h2 id="methods">Methods</h2>
<h3 id="pointers-vs-values">Pointers vs. Values</h3>
<p>Methods can be defined for any named type (except a pointer or an interface).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type ByteSlice []byte
func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    //to do sth....
    *p = slice
    return len(data), nil
}
</code></pre></div></div>

<p>The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.</p>

<p>This rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception, though. When value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable <code class="language-plaintext highlighter-rouge">b</code> is addressable, so we can call its <code class="language-plaintext highlighter-rouge">Write</code> method with just <code class="language-plaintext highlighter-rouge">b.Write</code>. The compiler will rewrite that to <code class="language-plaintext highlighter-rouge">(&amp;b).Write</code> for us.</p>

<h2 id="interface-and-other-types">Interface and other types</h2>
<h3 id="interface">Interface</h3>
<p>Interfaces in Go provide a way to specify the behavior of an object: if something do <em>this</em>, then it can used <em>here</em>. Interfaces with only one or two methods are common in Go code, and are usually given a name derived from the method, sunch as <code class="language-plaintext highlighter-rouge">io.Writer</code> for something that implements <code class="language-plaintext highlighter-rouge">Write</code>. A type can implement multiple interfaces.</p>

<h3 id="conversions">Conversions</h3>
<p>It’s an idiom in Go program to convert the type of an expression to access a different set of methods.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Sequence []int

// Method for printing - sorts the elements before printing
func (s Sequence) String() string {
    sort.IntSlice(s).Sort()
    return fmt.Sprint([]int(s))
}
</code></pre></div></div>

<h3 id="interface-conversions-and-type-assertions">Interface conversions and type assertions</h3>
<p><em>Type switches</em> are a form of conversion: they take an interface and, foreach case in the switch, in a sence convert it to the type of that case.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Stringer interface {
    String() string
}

var value interface{} // Value provided by caller
switch str := value.(type) {
    case string:
        return str
    case Stringer:
        return str.String()
}
</code></pre></div></div>

<p>The first case finds a concrete value; the second converts the interface into another interface.</p>

<p>A <strong>type assertion</strong> takes an interface value and extracts from it a value of the specified explicit type. The syntax borrows from the clause opening a type switch, but with an explicit type rather than the <code class="language-plaintext highlighter-rouge">type</code> keyword:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>value.(typeName)
</code></pre></div></div>

<p>and the result is a new value with the static type <code class="language-plaintext highlighter-rouge">typeName</code>. That type must either be the concrete type held by the interface, or a second interface type that the value can be converted to. To extract the string we knwow is in the value, we could write:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>str := value.(string)
</code></pre></div></div>

<p>But if it turns out that the value does not contain a string, the program will crash with a run-time error. To guard against that, use the “comma, ok” idiom to test, safely, whether the value is a string:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>str, ok = value.(string)
if ok {
    fmt.Printf("string value is %q\n", str)
} else {
    fmt.Printf("value is not a string\n")
}
</code></pre></div></div>

<p>If the type assertion fails, <code class="language-plaintext highlighter-rouge">str</code> will still exist and be of type string, but it will have the zero value, an empty string.</p>

<p>As illustration of the capability, here’s an <em>if-else</em> statement that’s equvalent to the <em>type switch</em> that opened this section.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if str, ok := value.(string); ok {
    return str
} else if str, ok := value.(Stringer); ok {
    return str.String()
}
</code></pre></div></div>

<h3 id="generality">Generality</h3>
<p>If a type exists only to implement an interface and has no exported methods beyond that interface, there is no need to export the type itself. Exporting just the interfaace makes it clear that it’s the behavior that matters, not the implementation, and that other implementations with different properties can mirror the behavior of the original type. It also avoids the need to repeat the documentation on every instance of a common method.</p>

<p>In such cases, the constructor should return an interface value rather than an implementing type. As an example, in the hash libraries both <code class="language-plaintext highlighter-rouge">crc32.NewIEEE</code> and <code class="language-plaintext highlighter-rouge">adler32.New</code> return the interface type <code class="language-plaintext highlighter-rouge">hash.Hash32</code>. Substituting the CRC-32 algorithm for Adler-32 in a Go program requires only changing the constructor call; the rest of the code is unaffeted by the change of algorithm. (Depedency Inversion)</p>

<h3 id="interface-and-methods">Interface and methods</h3>
<p>Since almost anything can have methods attached, almost anything can satisfy an interface, all because interface are just sets of methods, which can be defined for (almost) any type (except pointers and interfaces).</p>

<h2 id="the-blank-identifier">The blank identifier</h2>
<p>The blank identifier can be assigned or declared with any value of any type, with the value discarded harmlessly. It’s a bit like writing to the Unix <em>/dev/null</em> file: it represents a write-only value to be used as a place-holder where a variable is needed but the actual value is irrelevant.</p>
<h3 id="the-blank-identifier-in-multiple-assignment">The blank identifier in multiple assignment</h3>
<p>The use of blank identifier in a <em>for range</em> loop is a special case of a general situaltion: multiple assignment.</p>

<p>If an assignment requires multiple values on the left side, but one of the values will not be used by the program, a blank identifier on the left-hand-side of the assignment avoids the need to create a dummy variable and make it clear that the value is to be discarded. For instance, when calling a function that returns a value and an error, but only the error is important, use the blank identifier to discard the irrelevant value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if _, err := os.Stat(pat); os.IsNotExist(err) {
    fmt.Printf("%s does not exist\n", path)
}
</code></pre></div></div>

<p>Occasionally you’ll see code that discard the error value in order to ignore the error; this is terrible pratice.</p>

<h3 id="unused-imports-and-variables">Unused imports and variables</h3>
<p>It is an error to import a package or to declare a varible without using it. Unused imports bloat the program and slow compilation, while a variable that is intialized but not used is at least a wasted computation and perhaps indicative of a larger bug. When a program is under active development, however, unsued imports and variables often arise and it can be annoying to delete them just to have the compilation proceed, only to have them be needed again later.</p>

<p>To silence compaints about the unused imports, use a blank identifier to refer to a symbol from the imported package. Similarly, assigning the unused variable <code class="language-plaintext highlighter-rouge">fd</code> to the blank identifier will silence the unused variable error.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

var _ = fmt.Printf // For debugging; delete when done.
var _ io.Reader    // For debugging; delete when done.

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: use fd.
    _ = fd
}
</code></pre></div></div>

<p>By convention, the global declarations to silence import erros should come right after the imports and be commented, both to make them easy to find and as a reminder to clean things up later.</p>

<h3 id="import-for-side-effect">Import for side effect</h3>
<p>Sometimes it is used to import a package only for side effects, without an explicit use. For example, during its <code class="language-plaintext highlighter-rouge">init</code> function, the <code class="language-plaintext highlighter-rouge">net/http/pprof</code> package registers HTTP handlers that provide debugging information. It has an exported API, but most clients need only the handler registration and access the data through a web page. To import the package only for its side effects, rename the package to the blank identifier:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import _ "net/http/pprof"
</code></pre></div></div>

<p>This form of import makes clear that the package is being imported for its side effects, because there no other possible use of the package: in this file, it doesn’t have a name. (If it did, and we didn’t use that name, the compiler would reject the program.)</p>

<h3 id="interface-checks">Interface checks</h3>
<p>A type need not declare explicitly that it implements an interface, instead, a type implements the interface just by implementing the interface’s methods. In practice, most interface conversions are static and therefore checked at compile time. For examle, pass an <code class="language-plaintext highlighter-rouge">*os.File</code> to a function expecting an <code class="language-plaintext highlighter-rouge">io.Reader</code> will compile unless <code class="language-plaintext highlighter-rouge">*os.File</code> implements the <code class="language-plaintext highlighter-rouge">io.Reader</code> interface.</p>

<p>Some interface checks do happen at rum-time, though. One instance is in the <code class="language-plaintext highlighter-rouge">encoding/json</code> package, which defines a <code class="language-plaintext highlighter-rouge">Marshaler</code> interface. When the JSON receives a value that implements that inferface, the encoder invokes the value’s marshaling method to convert it to JSON instead of doing the standard conversion. The encoder checks this property at run time with a <em>type assertion</em> like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m, ok := val.(json.Marshaler)
</code></pre></div></div>

<p>or</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_, ok := val.(json.Marshaler)
</code></pre></div></div>

<p>It it’s necessary only to ask whether a type implements an interface, without actually using the interface itself, perhaps as part of an error check.</p>

<p>One place this situation arises is when it is necessary to guarantee within the package implementing the type that it actually satisfies the interface.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var _ json.Marshaler = (*RawMessage)(nil)
</code></pre></div></div>

<p>In this declaration, the assignment involving a conversion of a <code class="language-plaintext highlighter-rouge">*RawMessage</code> to a <code class="language-plaintext highlighter-rouge">Marshaler</code> requires that <code class="language-plaintext highlighter-rouge">*RawMessage</code> implements <code class="language-plaintext highlighter-rouge">Marshaler</code>, and that property will be checked at compile time.</p>

<p>The appearance of the blank identifier in this construct indicates that the declaration exists only for type checking, no to create a variable. Don’t do this for every type that satisfies an interface, though. By Convention, such declarations are only used when there are no static conversions already present in the code, which is a rare event.</p>

<h2 id="embedding">Embedding</h2>
<p>Go does not provide the typical, type-driven notion of subclassing, but it does have the ablility to “borrow” pieces of an implementation by <em>embedding</em> types within a struct or interface.</p>

<p>Interface embedding is very simple.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package io

type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

// ReadWriter is the interface that combines the Reader and Writer interfaces.
type ReadWriter interface {
    Reader
    Writer
}
</code></pre></div></div>

<p>A <code class="language-plaintext highlighter-rouge">ReadWriter</code> can do what a <code class="language-plaintext highlighter-rouge">Reader</code> <em>and</em> what a <code class="language-plaintext highlighter-rouge">Writer</code> does; it is a union of the embedded interfaces (which must be disjoint sets of methods). Only interfaces can be embeded within interfaces.</p>

<p>The same basic idea applies to structs, but with more far-reaching implications.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package bufio

// ReadWriter stores pointer to a Reader and a Writer but does not give them field names.
// It implements io.ReadWriter
type ReadWriter struct {
    *Reader     // *buffio.Reader
    *Writer     // *buffio.Writer
}
</code></pre></div></div>

<p>The embedded elements are pointers to structs and of course must be intialized to point to valid structs before they can be used. The methods of embeded types come along for free.</p>

<p>The <code class="language-plaintext highlighter-rouge">ReadWriter</code> struct could be written as</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type ReadWriter struct {
    reader *Reader
    writer *Writer
}
</code></pre></div></div>

<p>but then to promote the methods of the fields and to satisfy the <code class="language-plaintext highlighter-rouge">io</code> interfaces, we would also need to provide forwarding methods, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (rw *ReadWriter) Read(p []byte) (n int, err error) {
    return rw.reader.Read(p)
}
</code></pre></div></div>

<p>There’s an important way in whch embedding differs from subclassing. When we embed a type, the methods of that type become methods of the outer type, but when they are invoked the receiver of the method is the inner type, not the outer one.</p>

<p>Embedding can also be a simple convenience.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Job struct {
    Command string
    *log.Logger
}
</code></pre></div></div>

<p>If we need to refer to an embedded field directly, the type name of the field, ignoring the package qualifier, serves as a field name, as it did in the <code class="language-plaintext highlighter-rouge">Read</code> method of the <code class="language-plaintext highlighter-rouge">ReadWriter</code> struct.</p>

<p>Embedding types introduce the problem of name conflicts.</p>

<ul>
  <li>First, a field or method <code class="language-plaintext highlighter-rouge">X</code> hides any other item <code class="language-plaintext highlighter-rouge">X</code> in a more deeply nested part of the type. If <code class="language-plaintext highlighter-rouge">log.Logger</code> contained a field or method called <code class="language-plaintext highlighter-rouge">Command</code>, the <code class="language-plaintext highlighter-rouge">Command</code> field of the <code class="language-plaintext highlighter-rouge">Job</code> wouble dominate it.</li>
  <li>Second, if the same name appears at the same nesting level, it is usually an error; it would be erroneous to embed <code class="language-plaintext highlighter-rouge">log.Logger</code> if the <code class="language-plaintext highlighter-rouge">Job</code> struct contianed anohter field or method called <code class="language-plaintext highlighter-rouge">Logger</code>. However, if the duplicate name is never mentiaioned in the program outside the type definition, it is OK. This qualification provides some protection against changes made to types embedded from outside; there is no problem if a field is added that confilcts with another field in another subtype if neither field is ever used.</li>
</ul>

<h2 id="concurrency">Concurrency</h2>
<h3 id="share-by-communicating">Share by communicating</h3>
<p>Concurrent programmig in many environments is made difficult by the subtleties required to implement correct access to shard variables. Go encourages a different approach in which shared values are passed around on channels and, in fact, never atively shared by separate threads of execution. Only one <code class="language-plaintext highlighter-rouge">goroutine</code> has access to the value at any given time. Data races cannot occur, by design. To encourage this way of thinking we have reduced it to a slogan:</p>

<p><strong>Do not communicate by sharing memory; instead, share memory by communicating.</strong></p>

<p>One way to think about this model is to consider a typical single-threaded program running on the CPU. It has no need for synchronization primitives. Now run another such instance; it too needs no synchronization. Now let those two communicate; if the communication is the synchronizer, there’s still no need for other synchroniztion. Unix pipelines, for example, fit this model perfectly. Although Go’s approach to concurrency originates in Hoare’s Communicating Sequential Processes (CSP), it can also been as a type-safe generalization of Unix pipes.</p>

<h3 id="goroutines">Goroutines</h3>
<p>They’are called <em>goroutines</em> because the existing terms—threads, coroutines, processes, and so on—convey inaccurate connotations. A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required.</p>

<p>Goroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I/O, others continue to run. Their design hides many of the complexities of thread creation and manangement.</p>

<p>Prefix a funciton or method call with the <strong>go</strong> keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently. (The effect is similar to the Unix shell’s <strong>&amp;</strong> notation for running a command in the background.)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go list.sort()  // run list.sort concurrently; don't wait for it
</code></pre></div></div>

<p>A function literal can be handy in a goroutine invocation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func Annouce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()     // Note the parentheses - must call the function.
}
</code></pre></div></div>

<p>In Go, function literals are <strong>closure</strong>s: the implementation makes sure the variables referred to by the function survive as long as they are active.</p>

<h3 id="channels">Channels</h3>
<p>Like maps, channels are allocated with <code class="language-plaintext highlighter-rouge">make</code>, and the resulting value acts as a reference to an underlying data structure. If an optional integer parameter is provided, it sets the buffer size for the channel. The default is zero, for an unbuffered or synchronous channel.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ci := make(chan int)            // unbuffered channel of integers
cj := make(chan int, 0)         // unbuffered channel of integers
cs := make(chan *os.File, 100)  // buffered channel of pointers to Files
</code></pre></div></div>

<p>Unbuffered channels combine communication—the exchange fo a value—with synchronization—guaranteeing that two calculations (goroutines) are in a know state.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// A channel can allow the launching goroutine to wait for the sort to complete.

c := make(chan int)     // Allocate a channel
// Start the sort in a goroutine; when it completes, signal on the channel.
go func() {
    list.Sort()
    c &lt;- 1  // Send a signal; value does not matter.
}()
doSomethingForAWhile()
&lt;-c     // Wati for sort to finish; discard sent value.
</code></pre></div></div>

<p>Receivers always block until there is data to receive. If the channel is unbuffered, the sender blocks until the receiver has received the value. If the channel has a buffer, the sender blocks only util the value has been copied to the buffer; if the buffer is full, this means waiting util some receiver has retrieved a value.</p>

<p>A buffered channel can be used like a semaphore, for instance to limit throughput.</p>

<p>In this example, incoming requests are passed to <code class="language-plaintext highlighter-rouge">handle</code>, which sends a value into the channel, processes the request, and then receives a value from the channel to ready the “semaphore” for the next consumer. The capacity of the channel buffer limits the number of simultaneous calls the <code class="language-plaintext highlighter-rouge">process</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem &lt;- 1    // Wait for active queue to drain.
    process(r)  // May take a long time.
    &lt;-sem       // Done; enable next request to run.
}

func Serve(queue chan *Request) {
    for {
        req := &lt;-queue
        go handle(req)  // Don't wait for handle to finish.
    }
}
</code></pre></div></div>

<p>This design has a problem, though: Serve creates a new goroutine for every incomming request, even though only <code class="language-plaintext highlighter-rouge">MaxOutstanding</code> of them can run at any moment. As a result, the program can consume unlimited resources if the requests come in too fast. We can address that deficiency by changing <code class="language-plaintext highlighter-rouge">Server</code> to gate the creation of the goroutines.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func Serve(queue chan *Request) {
    for req := range queue {
        sem &lt;- 1
        go func() {
            process(req) // Buggy; see explanation below.
            &lt;-sem
        }()
    }
}
</code></pre></div></div>

<p>The bug is that in a Go <em>for loop</em>, <strong><em>the loop variable is reused for each iteration</em></strong>, so the <code class="language-plaintext highlighter-rouge">req</code> variable is shared across all goroutines.</p>

<p>Here’s one way to do that, passing the value of <code class="language-plaintext highlighter-rouge">req</code> as an argument to the <strong>closure</strong> in the goroutine:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func Serve(queue chan *Request) {
    for req := range queue {
        sem &lt;- 1
        go func(req *Request) {
            process(req)
            &lt;-sem
        }(req)
    }
}
</code></pre></div></div>

<p>Another solution is just to create a new variable with the same name, as the belows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func Serve(queue chan *Request) {
    for req := range queue {
        req := req // Create new instance of req for the goroutine.
        sem &lt;- 1
        go func() {
            process(req)
            &lt;-sem
        }()
    }
}
</code></pre></div></div>

<p>It may seem odd to write</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>req := req // :=, redeclaration and reassignment
</code></pre></div></div>

<p>but it’s legal and idiomatic in Go to do this. You get a fresh version of the variable with the same name, deliberately shadowing the loop variable locally but unique to each goroutine.</p>

<h3 id="channels-of-channels">Channels of channels</h3>
<p>One of the most important properties of Go is that a channel is a first-class value that can be allocated and passed around like any other. A common use of this property is to implement safe, parallel demultiplexing.</p>

<p>If a type includes a channel on which to reply, each client can provide its own path for the answer. Here’s a schematic definition of type Request.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}
</code></pre></div></div>

<p>The client provides a function and its arguments, as well as a channel isnide the request object on which to receive the answer.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &amp;Request{[]int{3, 4, 5}, sum, make(chan int)}
// Send request
clientRequests &lt;- request
// Wait for response.
fmt.Printf("answer: %d\n", &lt;-request.resultChan)
</code></pre></div></div>

<p>On the server side, the handler function is the only thing that changes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan &lt;- req.f(req.args)
    }
}
</code></pre></div></div>

<p>There’s clearly a lot more to do make it realistic, but this code is a framework for a rate-limited, parallel, non-blocking RPC system, and there’s not a mutex in sight.</p>

<h3 id="parallelization">Parallelization</h3>
<p>If a calculation can be broken into separate pieces that can execute independently, it can be to parallelize across multiple CPU cores, with a channel to signal when each piece completes.</p>

<p>Let’s say we have an expensive operation to perform on a vector of itmes, and that the value of the operation on each item is independent, as in this idealized example.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Vector []float64

// Apply the operation to v[i], v[i+1] ... up to [vn-1].
func (v *Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i &lt; n; i++ {
        v[i] += u.Op(v[i])
    }
    c &lt;- 1      // signal that this piece is done
}

const numCPU = 4    // number of CPU cores

func (v Vector) DoAll(u Vector) {
    c := make(chan int, numCPU)     // Buffering optional but sensible.
    for i := 0; i &lt; numCPU; i++ {
        go v.DoSome(i*len(v)/numCPU, (i+1)*len(v)/numCPU, u, c)
    }
    // Drain the channel.
    for i := 0; i &lt; numCPU; i++ {
        &lt;-c     // wait for one task to complete
    }
    // All done.
}
</code></pre></div></div>

<p>Rather than create a constant value for numCPU, the function <code class="language-plaintext highlighter-rouge">runtime.NumCPU</code> can return the number of hardware CPU cores in the machine.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var numCPU = runtime.NumCPU()
</code></pre></div></div>

<p>There is also a function <code class="language-plaintext highlighter-rouge">runtime.GOMAXPROCS</code>, which reports (or sets) the user-specified number of cores that a Go program can have running simultaneously. It defaults to the value of <code class="language-plaintext highlighter-rouge">runtime.NumCPU</code> but can be overridden by setting the similarly named shell environment variable or by call the function with a positive number. Calling it with zero just qureis the value. Therefore if we want to honor the user’s resource request, we should write</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var numCPU = runtime.GOMAXPROCS(o)
</code></pre></div></div>

<p>Be sure not to confuse the ideas of <strong>concurrency</strong>—structuring a program as independentyly executing components—and <strong>parallelism</strong>—executing calculations in parallel for efficiency on multiple CPUs.</p>

<p>Although the concurrency features of Go can make some problems easy to structure as parallel computations, Go is a concurrent language, not a parallel one, and not all parallelization problems fit Go’s model.</p>

<h3 id="a-leaky-buffer">A leaky buffer</h3>
<p>To be continued….</p>

<h2 id="errors">Errors</h2>
<p>Libraries routines must often return some sort of error indication to the caller. As menthioned earlier, Go’s multivalue return makes it easy to return a detailed error description alongside the normal return value. It is good style to use this feature to provide detailed error information.</p>

<p>By convention, errors have type <code class="language-plaintext highlighter-rouge">error</code>, a simple built-in interface.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type error interface {
    Error() string
}
</code></pre></div></div>

<p>A library writer is free to implement this interface with a richer model under the convers, making it possible not only to see the error but also to provide some context.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package os

// PathError records an error and the operation and
// file path that caused it.
type PathError struct {
    Op string    // "open", "unlink", etc.
    Path string  // The associated file.
    Err error    // Returned by the system call.
}

func (e *PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
</code></pre></div></div>

<p>PathError’s Error generates a string like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open /etc/passwx: no such file or directory
</code></pre></div></div>

<p>It is much more informative than the plain “no such file or directory”.</p>

<p>When feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error. For example, in package <em>package</em>, the string representation for a decoding error due to an unkown format is “image: unkown format”.</p>

<p>Callers that care about the precise error details can use a <em>type switch</em> or a <em>type assertion</em> to look for specific errors and extract details.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for try := 0; try &lt; 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
    if e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
</code></pre></div></div>

<h3 id="panic">Panic</h3>
<p>The usual way to report an error to a caller is to return an <code class="language-plaintext highlighter-rouge">error</code> as an extra return value. But sometimes the program simply cannot continue with a error that is unrecoverable.</p>

<p>There is a built-in function <code class="language-plaintext highlighter-rouge">panic</code> that takes a single argument of arbitrary type—often a string—to printed as the program dies to create a run-time error that will stop the program. It’s also a way to indicate that something impossible has happened, such as exiting an infinite loop.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
    z := x/3   // Arbitrary initial value
    for i := 0; i &lt; 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // A million iterations has not converged; something is     wrong.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
</code></pre></div></div>

<p>This is only an example but real library functions should avoid <code class="language-plaintext highlighter-rouge">panic</code>. If the program can be masked or worked around, it’s always better to let things continue to run rather than taking down the whole program.</p>

<h3 id="recover">Recover</h3>
<p>When <code class="language-plaintext highlighter-rouge">panic</code> is called, including implicitly for run-time errors such indexing a slice out of bounds or failing a type assertion, it immediately stops execution of the current function and begins unwinding the stack of the goroutine, running any deferred functions along the way. If that unwinding reaches the top of the goroutine’s stack, the program dies. However, it is possible to use the built-in function <code class="language-plaintext highlighter-rouge">recover</code> to regain control of the goroutine and resume normal execution.</p>

<p>A call to <code class="language-plaintext highlighter-rouge">recover</code> stops the unwinding and returns the argument passed to <code class="language-plaintext highlighter-rouge">panic</code>. Because the only code that runs while unwinding is inside deferred functions, <code class="language-plaintext highlighter-rouge">recover</code> is only useful inside deferred functions.</p>

<p>On application of <code class="language-plaintext highlighter-rouge">recover</code> is to shut down a failing goroutine inside a server without killing the other executing goroutines.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func server(workChan &lt;-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
</code></pre></div></div>

<p>In this example, if <code class="language-plaintext highlighter-rouge">do(work)</code> panics, the result will be logged and the goroutine will exit cleanly without disturbing the others.</p>

<p>With the recovery pattern in place, the <code class="language-plaintext highlighter-rouge">do</code> function (and anything it calls) can get out of any bad situation cleanly by calling <code class="language-plaintext highlighter-rouge">panic</code>. We can use that idea to simplify error handling in complex software.</p>

<p>By the way, the re-panic idiom could changes the panic value if an actual error occurs.</p>

  </div>

  <ul class="post-navigation">
    <li>
      
      <a href="/2016/03/25/bubble-sorting-with-go-language/">&laquo; Bubble Sorting with Go language</a>
      
    </li>
    <li>
      
      <a href="/2016/03/26/installing-go-from-source/">Installing-Go-from-source &raquo;</a>
      
    </li>
  </ul>
</article>

      </div>
    </div>

    <footer class="site-footer">
  <div class="license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details open>
    <summary>Extral Links</summary>
    <div>
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>


<!-- https://github.com/bryanbraun/anchorjs -->
<script src="/js/anchor.min.js"></script>
<script>
  anchors.add();
  anchors.remove(".site-title");
</script>




  </body>

</html>
